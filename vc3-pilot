#! /usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Fatal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FATAL';
  package Fatal;
  
  # ABSTRACT: Replace functions with equivalents which succeed or die
  
  use 5.008;  # 5.8.x needed for autodie
  use Carp;
  use strict;
  use warnings;
  use Tie::RefHash;   # To cache subroutine refs
  use Config;
  use Scalar::Util qw(set_prototype);
  
  use autodie::Util qw(
    fill_protos
    install_subs
    make_core_trampoline
    on_end_of_compile_scope
  );
  
  use constant PERL510     => ( $] >= 5.010 );
  
  use constant LEXICAL_TAG => q{:lexical};
  use constant VOID_TAG    => q{:void};
  use constant INSIST_TAG  => q{!};
  
  # Keys for %Cached_fatalised_sub  (used in 3rd level)
  use constant CACHE_AUTODIE_LEAK_GUARD    => 0;
  use constant CACHE_FATAL_WRAPPER         => 1;
  use constant CACHE_FATAL_VOID            => 2;
  
  
  use constant ERROR_NOARGS    => 'Cannot use lexical %s with no arguments';
  use constant ERROR_VOID_LEX  => VOID_TAG.' cannot be used with lexical scope';
  use constant ERROR_LEX_FIRST => LEXICAL_TAG.' must be used as first argument';
  use constant ERROR_NO_LEX    => "no %s can only start with ".LEXICAL_TAG;
  use constant ERROR_BADNAME   => "Bad subroutine name for %s: %s";
  use constant ERROR_NOTSUB    => "%s is not a Perl subroutine";
  use constant ERROR_NOT_BUILT => "%s is neither a builtin, nor a Perl subroutine";
  use constant ERROR_NOHINTS   => "No user hints defined for %s";
  
  use constant ERROR_CANT_OVERRIDE => "Cannot make the non-overridable builtin %s fatal";
  
  use constant ERROR_NO_IPC_SYS_SIMPLE => "IPC::System::Simple required for Fatalised/autodying system()";
  
  use constant ERROR_IPC_SYS_SIMPLE_OLD => "IPC::System::Simple version %f required for Fatalised/autodying system().  We only have version %f";
  
  use constant ERROR_AUTODIE_CONFLICT => q{"no autodie '%s'" is not allowed while "use Fatal '%s'" is in effect};
  
  use constant ERROR_FATAL_CONFLICT => q{"use Fatal '%s'" is not allowed while "no autodie '%s'" is in effect};
  
  use constant ERROR_58_HINTS => q{Non-subroutine %s hints for %s are not supported under Perl 5.8.x};
  
  # Older versions of IPC::System::Simple don't support all the
  # features we need.
  
  use constant MIN_IPC_SYS_SIMPLE_VER => 0.12;
  
  our $VERSION = '2.29'; # VERSION: Generated by DZP::OurPkg::Version
  
  our $Debug ||= 0;
  
  # EWOULDBLOCK values for systems that don't supply their own.
  # Even though this is defined with our, that's to help our
  # test code.  Please don't rely upon this variable existing in
  # the future.
  
  our %_EWOULDBLOCK = (
      MSWin32 => 33,
  );
  
  $Carp::CarpInternal{'Fatal'} = 1;
  $Carp::CarpInternal{'autodie'} = 1;
  $Carp::CarpInternal{'autodie::exception'} = 1;
  
  # the linux parisc port has separate EAGAIN and EWOULDBLOCK,
  # and the kernel returns EAGAIN
  my $try_EAGAIN = ($^O eq 'linux' and $Config{archname} =~ /hppa|parisc/) ? 1 : 0;
  
  # We have some tags that can be passed in for use with import.
  # These are all assumed to be CORE::
  
  my %TAGS = (
      ':io'      => [qw(:dbm :file :filesys :ipc :socket
                         read seek sysread syswrite sysseek )],
      ':dbm'     => [qw(dbmopen dbmclose)],
      ':file'    => [qw(open close flock sysopen fcntl binmode
                       ioctl truncate)],
      ':filesys' => [qw(opendir closedir chdir link unlink rename mkdir
                        symlink rmdir readlink chmod chown utime)],
      ':ipc'     => [qw(:msg :semaphore :shm pipe kill)],
      ':msg'     => [qw(msgctl msgget msgrcv msgsnd)],
      ':threads' => [qw(fork)],
      ':semaphore'=>[qw(semctl semget semop)],
      ':shm'     => [qw(shmctl shmget shmread)],
      ':system'  => [qw(system exec)],
  
      # Can we use qw(getpeername getsockname)? What do they do on failure?
      # TODO - Can socket return false?
      ':socket'  => [qw(accept bind connect getsockopt listen recv send
                     setsockopt shutdown socketpair)],
  
      # Our defaults don't include system(), because it depends upon
      # an optional module, and it breaks the exotic form.
      #
      # This *may* change in the future.  I'd love IPC::System::Simple
      # to be a dependency rather than a recommendation, and hence for
      # system() to be autodying by default.
  
      ':default' => [qw(:io :threads)],
  
      # Everything in v2.07 and before. This was :default less chmod and chown
      ':v207'    => [qw(:threads :dbm :socket read seek sysread
                     syswrite sysseek open close flock sysopen fcntl fileno
                     binmode ioctl truncate opendir closedir chdir link unlink
                     rename mkdir symlink rmdir readlink umask
                     :msg :semaphore :shm pipe)],
  
      # Chmod was added in 2.13
      ':v213'    => [qw(:v207 chmod)],
  
      # chown, utime, kill were added in 2.14
      ':v214'    => [qw(:v213 chown utime kill)],
  
      # umask was removed in 2.26
      ':v225' => [qw(:io :threads umask fileno)],
  
      # Version specific tags.  These allow someone to specify
      # use autodie qw(:1.994) and know exactly what they'll get.
  
      ':1.994' => [qw(:v207)],
      ':1.995' => [qw(:v207)],
      ':1.996' => [qw(:v207)],
      ':1.997' => [qw(:v207)],
      ':1.998' => [qw(:v207)],
      ':1.999' => [qw(:v207)],
      ':1.999_01' => [qw(:v207)],
      ':2.00'  => [qw(:v207)],
      ':2.01'  => [qw(:v207)],
      ':2.02'  => [qw(:v207)],
      ':2.03'  => [qw(:v207)],
      ':2.04'  => [qw(:v207)],
      ':2.05'  => [qw(:v207)],
      ':2.06'  => [qw(:v207)],
      ':2.06_01' => [qw(:v207)],
      ':2.07'  => [qw(:v207)],     # Last release without chmod
      ':2.08'  => [qw(:v213)],
      ':2.09'  => [qw(:v213)],
      ':2.10'  => [qw(:v213)],
      ':2.11'  => [qw(:v213)],
      ':2.12'  => [qw(:v213)],
      ':2.13'  => [qw(:v213)],     # Last release without chown
      ':2.14'  => [qw(:v225)],
      ':2.15'  => [qw(:v225)],
      ':2.16'  => [qw(:v225)],
      ':2.17'  => [qw(:v225)],
      ':2.18'  => [qw(:v225)],
      ':2.19'  => [qw(:v225)],
      ':2.20'  => [qw(:v225)],
      ':2.21'  => [qw(:v225)],
      ':2.22'  => [qw(:v225)],
      ':2.23'  => [qw(:v225)],
      ':2.24'  => [qw(:v225)],
      ':2.25'  => [qw(:v225)],
      ':2.26'  => [qw(:default)],
      ':2.27'  => [qw(:default)],
      ':2.28'  => [qw(:default)],
      ':2.29'  => [qw(:default)],
  );
  
  
  {
      # Expand :all immediately by expanding and flattening all tags.
      # _expand_tag is not really optimised for expanding the ":all"
      # case (i.e. keys %TAGS, or values %TAGS for that matter), so we
      # just do it here.
      #
      # NB: The %tag_cache/_expand_tag relies on $TAGS{':all'} being
      # pre-expanded.
      my %seen;
      my @all = grep {
          !/^:/ && !$seen{$_}++
      } map { @{$_} } values %TAGS;
      $TAGS{':all'} = \@all;
  }
  
  # This hash contains subroutines for which we should
  # subroutine() // die() rather than subroutine() || die()
  
  my %Use_defined_or;
  
  # CORE::open returns undef on failure.  It can legitimately return
  # 0 on success, eg: open(my $fh, '-|') || exec(...);
  
  @Use_defined_or{qw(
      CORE::fork
      CORE::recv
      CORE::send
      CORE::open
      CORE::fileno
      CORE::read
      CORE::readlink
      CORE::sysread
      CORE::syswrite
      CORE::sysseek
      CORE::umask
  )} = ();
  
  # Some functions can return true because they changed *some* things, but
  # not all of them.  This is a list of offending functions, and how many
  # items to subtract from @_ to determine the "success" value they return.
  
  my %Returns_num_things_changed = (
      'CORE::chmod'  => 1,
      'CORE::chown'  => 2,
      'CORE::kill'   => 1,  # TODO: Could this return anything on negative args?
      'CORE::unlink' => 0,
      'CORE::utime'  => 2,
  );
  
  # Optional actions to take on the return value before returning it.
  
  my %Retval_action = (
      "CORE::open"        => q{
  
      # apply the open pragma from our caller
      if( defined $retval && !( @_ >= 3 && $_[1] =~ /:/ )) {
          # Get the caller's hint hash
          my $hints = (caller 0)[10];
  
          # Decide if we're reading or writing and apply the appropriate encoding
          # These keys are undocumented.
          # Match what PerlIO_context_layers() does.  Read gets the read layer,
          # everything else gets the write layer.
          my $encoding = $_[1] =~ /^\+?>/ ? $hints->{"open>"} : $hints->{"open<"};
  
          # Apply the encoding, if any.
          if( $encoding ) {
              binmode $_[0], $encoding;
          }
      }
  
  },
      "CORE::sysopen"     => q{
  
      # apply the open pragma from our caller
      if( defined $retval ) {
          # Get the caller's hint hash
          my $hints = (caller 0)[10];
  
          require Fcntl;
  
          # Decide if we're reading or writing and apply the appropriate encoding.
          # Match what PerlIO_context_layers() does.  Read gets the read layer,
          # everything else gets the write layer.
          my $open_read_only = !($_[2] ^ Fcntl::O_RDONLY());
          my $encoding = $open_read_only ? $hints->{"open<"} : $hints->{"open>"};
  
          # Apply the encoding, if any.
          if( $encoding ) {
              binmode $_[0], $encoding;
          }
      }
  
  },
  );
  
  my %reusable_builtins;
  
  # "Wait!" I hear you cry, "truncate() and chdir() are not reuseable! They can
  # take file and directory handles, which are package depedent."
  #
  # You would be correct, except that prototype() returns signatures which don't
  # allow for passing of globs, and nobody's complained about that. You can
  # still use \*FILEHANDLE, but that results in a reference coming through,
  # and it's already pointing to the filehandle in the caller's packge, so
  # it's all okay.
  
  @reusable_builtins{qw(
      CORE::fork
      CORE::kill
      CORE::truncate
      CORE::chdir
      CORE::link
      CORE::unlink
      CORE::rename
      CORE::mkdir
      CORE::symlink
      CORE::rmdir
      CORE::readlink
      CORE::umask
      CORE::chmod
      CORE::chown
      CORE::utime
      CORE::msgctl
      CORE::msgget
      CORE::msgrcv
      CORE::msgsnd
      CORE::semctl
      CORE::semget
      CORE::semop
      CORE::shmctl
      CORE::shmget
      CORE::shmread
      CORE::exec
      CORE::system
  )} = ();
  
  # Cached_fatalised_sub caches the various versions of our
  # fatalised subs as they're produced.  This means we don't
  # have to build our own replacement of CORE::open and friends
  # for every single package that wants to use them.
  
  my %Cached_fatalised_sub = ();
  
  # Every time we're called with package scope, we record the subroutine
  # (including package or CORE::) in %Package_Fatal.  This allows us
  # to detect illegal combinations of autodie and Fatal, and makes sure
  # we don't accidently make a Fatal function autodying (which isn't
  # very useful).
  
  my %Package_Fatal = ();
  
  # The first time we're called with a user-sub, we cache it here.
  # In the case of a "no autodie ..." we put back the cached copy.
  
  my %Original_user_sub = ();
  
  # Is_fatalised_sub simply records a big map of fatalised subroutine
  # refs.  It means we can avoid repeating work, or fatalising something
  # we've already processed.
  
  my  %Is_fatalised_sub = ();
  tie %Is_fatalised_sub, 'Tie::RefHash';
  
  # Our trampoline cache allows us to cache trampolines which are used to
  # bounce leaked wrapped core subroutines to their actual core counterparts.
  
  my %Trampoline_cache;
  
  # A cache mapping "CORE::<name>" to their prototype.  Turns out that if
  # you "use autodie;" enough times, this pays off.
  my %CORE_prototype_cache;
  
  # We use our package in a few hash-keys.  Having it in a scalar is
  # convenient.  The "guard $PACKAGE" string is used as a key when
  # setting up lexical guards.
  
  my $PACKAGE       = __PACKAGE__;
  my $NO_PACKAGE    = "no $PACKAGE";      # Used to detect 'no autodie'
  
  # Here's where all the magic happens when someone write 'use Fatal'
  # or 'use autodie'.
  
  sub import {
      my $class        = shift(@_);
      my @original_args = @_;
      my $void         = 0;
      my $lexical      = 0;
      my $insist_hints = 0;
  
      my ($pkg, $filename) = caller();
  
      @_ or return;   # 'use Fatal' is a no-op.
  
      # If we see the :lexical flag, then _all_ arguments are
      # changed lexically
  
      if ($_[0] eq LEXICAL_TAG) {
          $lexical = 1;
          shift @_;
  
          # It is currently an implementation detail that autodie is
          # implemented as "use Fatal qw(:lexical ...)".  For backwards
          # compatibility, we allow it - but not without a warning.
          # NB: Optimise for autodie as it is quite possibly the most
          # freq. consumer of this case.
          if ($class ne 'autodie' and not $class->isa('autodie')) {
              if ($class eq 'Fatal') {
                  warnings::warnif(
                      'deprecated',
                      '[deprecated] The "use Fatal qw(:lexical ...)" '
                      . 'should be replaced by "use autodie qw(...)". '
                      . 'Seen' # warnif appends " at <...>"
                      );
              } else {
                  warnings::warnif(
                      'deprecated',
                      "[deprecated] The class/Package $class is a "
                      . 'subclass of Fatal and used the :lexical. '
                      . 'If $class provides lexical error checking '
                      . 'it should extend autodie instead of using :lexical. '
                      . 'Seen' # warnif appends " at <...>"
                      );
              }
              # "Promote" the call to autodie from here on.  This is
              # already mostly the case (e.g. use Fatal qw(:lexical ...)
              # would throw autodie::exceptions on error rather than the
              # Fatal errors.
              $class = 'autodie';
              # This requires that autodie is in fact loaded; otherwise
              # the "$class->X()" method calls below will explode.
              require autodie;
              # TODO, when autodie and Fatal are cleanly separated, we
              # should go a "goto &autodie::import" here instead.
          }
  
          # If we see no arguments and :lexical, we assume they
          # wanted ':default'.
  
          if (@_ == 0) {
              push(@_, ':default');
          }
  
          # Don't allow :lexical with :void, it's needlessly confusing.
          if ( grep { $_ eq VOID_TAG } @_ ) {
              croak(ERROR_VOID_LEX);
          }
      }
  
      if ( grep { $_ eq LEXICAL_TAG } @_ ) {
          # If we see the lexical tag as the non-first argument, complain.
          croak(ERROR_LEX_FIRST);
      }
  
      my @fatalise_these =  @_;
  
      # These subs will get unloaded at the end of lexical scope.
      my %unload_later;
      # These subs are to be installed into callers namespace.
      my %install_subs;
  
      # Use _translate_import_args to expand tags for us.  It will
      # pass-through unknown tags (i.e. we have to manually handle
      # VOID_TAG).
      #
      # NB: _translate_import_args re-orders everything for us, so
      # we don't have to worry about stuff like:
      #
      #     :default :void :io
      #
      # That will (correctly) translated into
      #
      #     expand(:defaults-without-io) :void :io
      #
      # by _translate_import_args.
      for my $func ($class->_translate_import_args(@fatalise_these)) {
  
          if ($func eq VOID_TAG) {
  
              # When we see :void, set the void flag.
              $void = 1;
  
          } elsif ($func eq INSIST_TAG) {
  
              $insist_hints = 1;
  
          } else {
  
              # Otherwise, fatalise it.
  
              # Check to see if there's an insist flag at the front.
              # If so, remove it, and insist we have hints for this sub.
              my $insist_this = $insist_hints;
  
              if (substr($func, 0, 1) eq '!') {
                  $func = substr($func, 1);
                  $insist_this = 1;
              }
  
              # We're going to make a subroutine fatalistic.
              # However if we're being invoked with 'use Fatal qw(x)'
              # and we've already been called with 'no autodie qw(x)'
              # in the same scope, we consider this to be an error.
              # Mixing Fatal and autodie effects was considered to be
              # needlessly confusing on p5p.
  
              my $sub = $func;
              $sub = "${pkg}::$sub" unless $sub =~ /::/;
  
              # If we're being called as Fatal, and we've previously
              # had a 'no X' in scope for the subroutine, then complain
              # bitterly.
  
              if (! $lexical and $^H{$NO_PACKAGE}{$sub}) {
                   croak(sprintf(ERROR_FATAL_CONFLICT, $func, $func));
              }
  
              # We're not being used in a confusing way, so make
              # the sub fatal.  Note that _make_fatal returns the
              # old (original) version of the sub, or undef for
              # built-ins.
  
              my $sub_ref = $class->_make_fatal(
                  $func, $pkg, $void, $lexical, $filename,
                  $insist_this, \%install_subs,
              );
  
              $Original_user_sub{$sub} ||= $sub_ref;
  
              # If we're making lexical changes, we need to arrange
              # for them to be cleaned at the end of our scope, so
              # record them here.
  
              $unload_later{$func} = $sub_ref if $lexical;
          }
      }
  
      install_subs($pkg, \%install_subs);
  
      if ($lexical) {
  
          # Dark magic to have autodie work under 5.8
          # Copied from namespace::clean, that copied it from
          # autobox, that found it on an ancient scroll written
          # in blood.
  
          # This magic bit causes %^H to be lexically scoped.
  
          $^H |= 0x020000;
  
          # Our package guard gets invoked when we leave our lexical
          # scope.
  
          on_end_of_compile_scope(sub {
              install_subs($pkg, \%unload_later);
          });
  
          # To allow others to determine when autodie was in scope,
          # and with what arguments, we also set a %^H hint which
          # is how we were called.
  
          # This feature should be considered EXPERIMENTAL, and
          # may change without notice.  Please e-mail pjf@cpan.org
          # if you're actually using it.
  
          $^H{autodie} = "$PACKAGE @original_args";
  
      }
  
      return;
  
  }
  
  sub unimport {
      my $class = shift;
  
      # Calling "no Fatal" must start with ":lexical"
      if ($_[0] ne LEXICAL_TAG) {
          croak(sprintf(ERROR_NO_LEX,$class));
      }
  
      shift @_;   # Remove :lexical
  
      my $pkg = (caller)[0];
  
      # If we've been called with arguments, then the developer
      # has explicitly stated 'no autodie qw(blah)',
      # in which case, we disable Fatalistic behaviour for 'blah'.
  
      my @unimport_these = @_ ? @_ : ':all';
      my (%uninstall_subs, %reinstall_subs);
  
      for my $symbol ($class->_translate_import_args(@unimport_these)) {
  
          my $sub = $symbol;
          $sub = "${pkg}::$sub" unless $sub =~ /::/;
  
          # If 'blah' was already enabled with Fatal (which has package
          # scope) then, this is considered an error.
  
          if (exists $Package_Fatal{$sub}) {
              croak(sprintf(ERROR_AUTODIE_CONFLICT,$symbol,$symbol));
          }
  
          # Record 'no autodie qw($sub)' as being in effect.
          # This is to catch conflicting semantics elsewhere
          # (eg, mixing Fatal with no autodie)
  
          $^H{$NO_PACKAGE}{$sub} = 1;
          # Record the current sub to be reinstalled at end of scope
          # and then restore the original (can be undef for "CORE::"
          # subs)
          $reinstall_subs{$symbol} = \&$sub;
          $uninstall_subs{$symbol} = $Original_user_sub{$sub};
  
      }
  
      install_subs($pkg, \%uninstall_subs);
      on_end_of_compile_scope(sub {
          install_subs($pkg, \%reinstall_subs);
      });
  
      return;
  
  }
  
  sub _translate_import_args {
      my ($class, @args) = @_;
      my @result;
      my %seen;
  
      if (@args < 2) {
          # Optimize for this case, as it is fairly common.  (e.g. use
          # autodie; or use autodie qw(:all); both trigger this).
          return unless @args;
  
          # Not a (known) tag, pass through.
          return @args unless exists($TAGS{$args[0]});
  
          # Strip "CORE::" from all elements in the list as import and
          # unimport does not handle the "CORE::" prefix too well.
          #
          # NB: we use substr as it is faster than s/^CORE::// and
          # it does not change the elements.
          return map { substr($_, 6) } @{ $class->_expand_tag($args[0]) };
      }
  
      # We want to translate
      #
      #     :default :void :io
      #
      # into (pseudo-ish):
      #
      #     expanded(:threads) :void expanded(:io)
      #
      # We accomplish this by "reverse, expand + filter, reverse".
      for my $a (reverse(@args)) {
          if (exists $TAGS{$a}) {
              my $expanded = $class->_expand_tag($a);
              push(@result,
                   # Remove duplicates after ...
                   grep { !$seen{$_}++ }
                   # we have stripped CORE:: (see above)
                   map { substr($_, 6) }
                   # We take the elements in reverse order
                   # (as @result be reversed later).
                   reverse(@{$expanded}));
          } else {
              # pass through - no filtering here for tags.
              #
              # The reason for not filtering tags cases like:
              #
              #    ":default :void :io :void :threads"
              #
              # As we have reversed args, we see this as:
              #
              #    ":threads :void :io :void* :default*"
              #
              # (Entries marked with "*" will be filtered out completely).  When
              # reversed again, this will be:
              #
              #    ":io :void :threads"
              #
              # But we would rather want it to be:
              #
              #    ":void :io :threads" or ":void :io :void :threads"
              #
  
              my $letter = substr($a, 0, 1);
              if ($letter ne ':' && $a ne INSIST_TAG) {
                  next if $seen{$a}++;
                  if ($letter eq '!' and $seen{substr($a, 1)}++) {
                      my $name = substr($a, 1);
                      # People are being silly and doing:
                      #
                      #    use autodie qw(!a a);
                      #
                      # Enjoy this little O(n) clean up...
                      @result = grep { $_ ne $name } @result;
                  }
              }
              push @result, $a;
          }
      }
      # Reverse the result to restore the input order
      return reverse(@result);
  }
  
  
  # NB: Perl::Critic's dump-autodie-tag-contents depends upon this
  # continuing to work.
  
  {
      # We assume that $TAGS{':all'} is pre-expanded and just fill it in
      # from the beginning.
      my %tag_cache = (
          'all' => [map { "CORE::$_" } @{$TAGS{':all'}}],
      );
  
      # Expand a given tag (e.g. ":default") into a listref containing
      # all sub names covered by that tag.  Each sub is returned as
      # "CORE::<name>" (i.e. "CORE::open" rather than "open").
      #
      # NB: the listref must not be modified.
      sub _expand_tag {
          my ($class, $tag) = @_;
  
          if (my $cached = $tag_cache{$tag}) {
              return $cached;
          }
  
          if (not exists $TAGS{$tag}) {
              croak "Invalid exception class $tag";
          }
  
          my @to_process = @{$TAGS{$tag}};
  
          # If the tag is basically an alias of another tag (like e.g. ":2.11"),
          # then just share the resulting reference with the original content (so
          # we only pay for an extra reference for the alias memory-wise).
          if (@to_process == 1 && substr($to_process[0], 0, 1) eq ':') {
              # We could do this for "non-tags" as well, but that only occurs
              # once at the time of writing (":threads" => ["fork"]), so
              # probably not worth it.
              my $expanded = $class->_expand_tag($to_process[0]);
              $tag_cache{$tag} = $expanded;
              return $expanded;
          }
  
          my %seen = ();
          my @taglist = ();
  
          for my $item (@to_process) {
              # substr is more efficient than m/^:/ for stuff like this,
              # at the price of being a bit more verbose/low-level.
              if (substr($item, 0, 1) eq ':') {
                  # Use recursion here to ensure we expand a tag at most once.
  
                  my $expanded = $class->_expand_tag($item);
                  push @taglist, grep { !$seen{$_}++ } @{$expanded};
              } else {
                  my $subname = "CORE::$item";
                  push @taglist, $subname
                      unless $seen{$subname}++;
              }
          }
  
          $tag_cache{$tag} = \@taglist;
  
          return \@taglist;
  
      }
  
  }
  
  # This is a backwards compatible version of _write_invocation.  It's
  # recommended you don't use it.
  
  sub write_invocation {
      my ($core, $call, $name, $void, @args) = @_;
  
      return Fatal->_write_invocation(
          $core, $call, $name, $void,
          0,      # Lexical flag
          undef,  # Sub, unused in legacy mode
          undef,  # Subref, unused in legacy mode.
          @args
      );
  }
  
  # This version of _write_invocation is used internally.  It's not
  # recommended you call it from external code, as the interface WILL
  # change in the future.
  
  sub _write_invocation {
  
      my ($class, $core, $call, $name, $void, $lexical, $sub, $sref, @argvs) = @_;
  
      if (@argvs == 1) {        # No optional arguments
  
          my @argv = @{$argvs[0]};
          shift @argv;
  
          return $class->_one_invocation($core,$call,$name,$void,$sub,! $lexical, $sref, @argv);
  
      } else {
          my $else = "\t";
          my (@out, @argv, $n);
          while (@argvs) {
              @argv = @{shift @argvs};
              $n = shift @argv;
  
              my $condition = "\@_ == $n";
  
              if (@argv and $argv[-1] =~ /[#@]_/) {
                  # This argv ends with '@' in the prototype, so it matches
                  # any number of args >= the number of expressions in the
                  # argv.
                  $condition = "\@_ >= $n";
              }
  
              push @out, "${else}if ($condition) {\n";
  
              $else = "\t} els";
  
          push @out, $class->_one_invocation($core,$call,$name,$void,$sub,! $lexical, $sref, @argv);
          }
          push @out, qq[
              }
              die "Internal error: $name(\@_): Do not expect to get ", scalar(\@_), " arguments";
      ];
  
          return join '', @out;
      }
  }
  
  
  # This is a slim interface to ensure backward compatibility with
  # anyone doing very foolish things with old versions of Fatal.
  
  sub one_invocation {
      my ($core, $call, $name, $void, @argv) = @_;
  
      return Fatal->_one_invocation(
          $core, $call, $name, $void,
          undef,   # Sub.  Unused in back-compat mode.
          1,       # Back-compat flag
          undef,   # Subref, unused in back-compat mode.
          @argv
      );
  
  }
  
  # This is the internal interface that generates code.
  # NOTE: This interface WILL change in the future.  Please do not
  # call this subroutine directly.
  
  # TODO: Whatever's calling this code has already looked up hints.  Pass
  # them in, rather than look them up a second time.
  
  sub _one_invocation {
      my ($class, $core, $call, $name, $void, $sub, $back_compat, $sref, @argv) = @_;
  
  
      # If someone is calling us directly (a child class perhaps?) then
      # they could try to mix void without enabling backwards
      # compatibility.  We just don't support this at all, so we gripe
      # about it rather than doing something unwise.
  
      if ($void and not $back_compat) {
          Carp::confess("Internal error: :void mode not supported with $class");
      }
  
      # @argv only contains the results of the in-built prototype
      # function, and is therefore safe to interpolate in the
      # code generators below.
  
      # TODO - The following clobbers context, but that's what the
      #        old Fatal did.  Do we care?
  
      if ($back_compat) {
  
          # Use Fatal qw(system) will never be supported.  It generated
          # a compile-time error with legacy Fatal, and there's no reason
          # to support it when autodie does a better job.
  
          if ($call eq 'CORE::system') {
              return q{
                  croak("UNIMPLEMENTED: use Fatal qw(system) not supported.");
              };
          }
  
          local $" = ', ';
  
          if ($void) {
              return qq/return (defined wantarray)?$call(@argv):
                     $call(@argv) || Carp::croak("Can't $name(\@_)/ .
                     ($core ? ': $!' : ', \$! is \"$!\"') . '")'
          } else {
              return qq{return $call(@argv) || Carp::croak("Can't $name(\@_)} .
                     ($core ? ': $!' : ', \$! is \"$!\"') . '")';
          }
      }
  
      # The name of our original function is:
      #   $call if the function is CORE
      #   $sub if our function is non-CORE
  
      # The reason for this is that $call is what we're actually
      # calling.  For our core functions, this is always
      # CORE::something.  However for user-defined subs, we're about to
      # replace whatever it is that we're calling; as such, we actually
      # calling a subroutine ref.
  
      my $human_sub_name = $core ? $call : $sub;
  
      # Should we be testing to see if our result is defined, or
      # just true?
  
      my $use_defined_or;
  
      my $hints;      # All user-sub hints, including list hints.
  
      if ( $core ) {
  
          # Core hints are built into autodie.
  
          $use_defined_or = exists ( $Use_defined_or{$call} );
  
      }
      else {
  
          # User sub hints are looked up using autodie::hints,
          # since users may wish to add their own hints.
  
          require autodie::hints;
  
          $hints = autodie::hints->get_hints_for( $sref );
  
          # We'll look up the sub's fullname.  This means we
          # get better reports of where it came from in our
          # error messages, rather than what imported it.
  
          $human_sub_name = autodie::hints->sub_fullname( $sref );
  
      }
  
      # Checks for special core subs.
  
      if ($call eq 'CORE::system') {
  
          # Leverage IPC::System::Simple if we're making an autodying
          # system.
  
          local $" = ", ";
  
          # We need to stash $@ into $E, rather than using
          # local $@ for the whole sub.  If we don't then
          # any exceptions from internal errors in autodie/Fatal
          # will mysteriously disappear before propagating
          # upwards.
  
          return qq{
              my \$retval;
              my \$E;
  
  
              {
                  local \$@;
  
                  eval {
                      \$retval = IPC::System::Simple::system(@argv);
                  };
  
                  \$E = \$@;
              }
  
              if (\$E) {
  
                  # TODO - This can't be overridden in child
                  # classes!
  
                  die autodie::exception::system->new(
                      function => q{CORE::system}, args => [ @argv ],
                      message => "\$E", errno => \$!,
                  );
              }
  
              return \$retval;
          };
  
      }
  
      local $" = ', ';
  
      # If we're going to throw an exception, here's the code to use.
      my $die = qq{
          die $class->throw(
              function => q{$human_sub_name}, args => [ @argv ],
              pragma => q{$class}, errno => \$!,
              context => \$context, return => \$retval,
              eval_error => \$@
          )
      };
  
      if ($call eq 'CORE::flock') {
  
          # flock needs special treatment.  When it fails with
          # LOCK_UN and EWOULDBLOCK, then it's not really fatal, it just
          # means we couldn't get the lock right now.
  
          require POSIX;      # For POSIX::EWOULDBLOCK
  
          local $@;   # Don't blat anyone else's $@.
  
          # Ensure that our vendor supports EWOULDBLOCK.  If they
          # don't (eg, Windows), then we use known values for its
          # equivalent on other systems.
  
          my $EWOULDBLOCK = eval { POSIX::EWOULDBLOCK(); }
                            || $_EWOULDBLOCK{$^O}
                            || _autocroak("Internal error - can't overload flock - EWOULDBLOCK not defined on this system.");
          my $EAGAIN = $EWOULDBLOCK;
          if ($try_EAGAIN) {
              $EAGAIN = eval { POSIX::EAGAIN(); }
                            || _autocroak("Internal error - can't overload flock - EAGAIN not defined on this system.");
          }
  
          require Fcntl;      # For Fcntl::LOCK_NB
  
          return qq{
  
              my \$context = wantarray() ? "list" : "scalar";
  
              # Try to flock.  If successful, return it immediately.
  
              my \$retval = $call(@argv);
              return \$retval if \$retval;
  
              # If we failed, but we're using LOCK_NB and
              # returned EWOULDBLOCK, it's not a real error.
  
              if (\$_[1] & Fcntl::LOCK_NB() and
                  (\$! == $EWOULDBLOCK or
                  ($try_EAGAIN and \$! == $EAGAIN ))) {
                  return \$retval;
              }
  
              # Otherwise, we failed.  Die noisily.
  
              $die;
  
          };
      }
  
      if (exists $Returns_num_things_changed{$call}) {
  
          # Some things return the number of things changed (like
          # chown, kill, chmod, etc). We only consider these successful
          # if *all* the things are changed.
  
          return qq[
              my \$num_things = \@_ - $Returns_num_things_changed{$call};
              my \$retval = $call(@argv);
  
              if (\$retval != \$num_things) {
  
                  # We need \$context to throw an exception.
                  # It's *always* set to scalar, because that's how
                  # autodie calls chown() above.
  
                  my \$context = "scalar";
                  $die;
              }
  
              return \$retval;
          ];
      }
  
      # AFAIK everything that can be given an unopned filehandle
      # will fail if it tries to use it, so we don't really need
      # the 'unopened' warning class here.  Especially since they
      # then report the wrong line number.
  
      # Other warnings are disabled because they produce excessive
      # complaints from smart-match hints under 5.10.1.
  
      my $code = qq[
          no warnings qw(unopened uninitialized numeric);
          no if \$\] >= 5.017011, warnings => "experimental::smartmatch";
  
          if (wantarray) {
              my \@results = $call(@argv);
              my \$retval  = \\\@results;
              my \$context = "list";
  
      ];
  
      my $retval_action = $Retval_action{$call} || '';
  
      if ( $hints and ( ref($hints->{list} ) || "" ) eq 'CODE' ) {
  
          # NB: Subroutine hints are passed as a full list.
          # This differs from the 5.10.0 smart-match behaviour,
          # but means that context unaware subroutines can use
          # the same hints in both list and scalar context.
  
          $code .= qq{
              if ( \$hints->{list}->(\@results) ) { $die };
          };
      }
      elsif ( PERL510 and $hints ) {
          $code .= qq{
              if ( \@results ~~ \$hints->{list} ) { $die };
          };
      }
      elsif ( $hints ) {
          croak sprintf(ERROR_58_HINTS, 'list', $sub);
      }
      else {
          $code .= qq{
              # An empty list, or a single undef is failure
              if (! \@results or (\@results == 1 and ! defined \$results[0])) {
                  $die;
              }
          }
      }
  
      # Tidy up the end of our wantarray call.
  
      $code .= qq[
              return \@results;
          }
      ];
  
  
      # Otherwise, we're in scalar context.
      # We're never in a void context, since we have to look
      # at the result.
  
      $code .= qq{
          my \$retval  = $call(@argv);
          my \$context = "scalar";
      };
  
      if ( $hints and ( ref($hints->{scalar} ) || "" ) eq 'CODE' ) {
  
          # We always call code refs directly, since that always
          # works in 5.8.x, and always works in 5.10.1
  
          return $code .= qq{
              if ( \$hints->{scalar}->(\$retval) ) { $die };
              $retval_action
              return \$retval;
          };
  
      }
      elsif (PERL510 and $hints) {
          return $code . qq{
  
              if ( \$retval ~~ \$hints->{scalar} ) { $die };
              $retval_action
              return \$retval;
          };
      }
      elsif ( $hints ) {
          croak sprintf(ERROR_58_HINTS, 'scalar', $sub);
      }
  
      return $code .
      ( $use_defined_or ? qq{
  
          $die if not defined \$retval;
          $retval_action
          return \$retval;
  
      } : qq{
  
          $retval_action
          return \$retval || $die;
  
      } ) ;
  
  }
  
  # This returns the old copy of the sub, so we can
  # put it back at end of scope.
  
  # TODO : Check to make sure prototypes are restored correctly.
  
  # TODO: Taking a huge list of arguments is awful.  Rewriting to
  #       take a hash would be lovely.
  
  # TODO - BACKCOMPAT - This is not yet compatible with 5.10.0
  
  sub _make_fatal {
      my($class, $sub, $pkg, $void, $lexical, $filename, $insist, $install_subs) = @_;
      my($code, $sref, $proto, $core, $call, $hints, $cache, $cache_type);
      my $ini = $sub;
      my $name = $sub;
  
  
      if (index($sub, '::') == -1) {
          $sub = "${pkg}::$sub";
          if (substr($name, 0, 1) eq '&') {
              $name = substr($name, 1);
          }
      } else {
          $name =~ s/.*:://;
      }
  
  
      # Figure if we're using lexical or package semantics and
      # twiddle the appropriate bits.
  
      if (not $lexical) {
          $Package_Fatal{$sub} = 1;
      }
  
      # TODO - We *should* be able to do skipping, since we know when
      # we've lexicalised / unlexicalised a subroutine.
  
  
      warn  "# _make_fatal: sub=$sub pkg=$pkg name=$name void=$void\n" if $Debug;
      croak(sprintf(ERROR_BADNAME, $class, $name)) unless $name =~ /^\w+$/;
  
      if (defined(&$sub)) {   # user subroutine
  
          # NOTE: Previously we would localise $@ at this point, so
          # the following calls to eval {} wouldn't interfere with anything
          # that's already in $@.  Unfortunately, it would also stop
          # any of our croaks from triggering(!), which is even worse.
  
          # This could be something that we've fatalised that
          # was in core.
  
  	# Store the current sub in case we need to restore it.
  	$sref = \&$sub;
  
          if ( $Package_Fatal{$sub} and exists($CORE_prototype_cache{"CORE::$name"})) {
  
              # Something we previously made Fatal that was core.
              # This is safe to replace with an autodying to core
              # version.
  
              $core  = 1;
              $call  = "CORE::$name";
              $proto = $CORE_prototype_cache{$call};
  
              # We return our $sref from this subroutine later
              # on, indicating this subroutine should be placed
              # back when we're finished.
  
  
  
          } else {
  
              # If this is something we've already fatalised or played with,
              # then look-up the name of the original sub for the rest of
              # our processing.
  
              if (exists($Is_fatalised_sub{$sref})) {
                  # $sub is one of our wrappers around a CORE sub or a
                  # user sub.  Instead of wrapping our wrapper, lets just
                  # generate a new wrapper for the original sub.
                  # - NB: the current wrapper might be for a different class
                  #   than the one we are generating now (e.g. some limited
                  #   mixing between use Fatal + use autodie can occur).
                  # - Even for nested autodie, we need this as the leak guards
                  #   differ.
                  my $s = $Is_fatalised_sub{$sref};
                  if (defined($s)) {
                      # It is a wrapper for a user sub
                      $sub = $s;
                  } else {
                      # It is a wrapper for a CORE:: sub
                      $core = 1;
                      $call = "CORE::$name";
                      $proto = $CORE_prototype_cache{$call};
                  }
              }
  
              # A regular user sub, or a user sub wrapping a
              # core sub.
  
              if (!$core) {
                  # A non-CORE sub might have hints and such...
                  $proto = prototype($sref);
                  $call = '&$sref';
                  require autodie::hints;
  
                  $hints = autodie::hints->get_hints_for( $sref );
  
                  # If we've insisted on hints, but don't have them, then
                  # bail out!
  
                  if ($insist and not $hints) {
                      croak(sprintf(ERROR_NOHINTS, $name));
                  }
  
                  # Otherwise, use the default hints if we don't have
                  # any.
  
                  $hints ||= autodie::hints::DEFAULT_HINTS();
              }
  
          }
  
      } elsif ($sub eq $ini && $sub !~ /^CORE::GLOBAL::/) {
          # Stray user subroutine
          croak(sprintf(ERROR_NOTSUB,$sub));
  
      } elsif ($name eq 'system') {
  
          # If we're fatalising system, then we need to load
          # helper code.
  
          # The business with $E is to avoid clobbering our caller's
          # $@, and to avoid $@ being localised when we croak.
  
          my $E;
  
          {
              local $@;
  
              eval {
                  require IPC::System::Simple; # Only load it if we need it.
                  require autodie::exception::system;
              };
              $E = $@;
          }
  
          if ($E) { croak ERROR_NO_IPC_SYS_SIMPLE; }
  
          # Make sure we're using a recent version of ISS that actually
          # support fatalised system.
          if ($IPC::System::Simple::VERSION < MIN_IPC_SYS_SIMPLE_VER) {
              croak sprintf(
              ERROR_IPC_SYS_SIMPLE_OLD, MIN_IPC_SYS_SIMPLE_VER,
              $IPC::System::Simple::VERSION
              );
          }
  
          $call = 'CORE::system';
          $core = 1;
  
      } elsif ($name eq 'exec') {
          # Exec doesn't have a prototype.  We don't care.  This
          # breaks the exotic form with lexical scope, and gives
          # the regular form a "do or die" behavior as expected.
  
          $call = 'CORE::exec';
          $core = 1;
  
      } else {            # CORE subroutine
          $call = "CORE::$name";
          if (exists($CORE_prototype_cache{$call})) {
              $proto = $CORE_prototype_cache{$call};
          } else {
              my $E;
              {
                  local $@;
                  $proto = eval { prototype $call };
                  $E = $@;
              }
              croak(sprintf(ERROR_NOT_BUILT,$name)) if $E;
              croak(sprintf(ERROR_CANT_OVERRIDE,$name)) if not defined $proto;
              $CORE_prototype_cache{$call} = $proto;
          }
          $core = 1;
      }
  
      # TODO: This caching works, but I don't like using $void and
      # $lexical as keys.  In particular, I suspect our code may end up
      # wrapping already wrapped code when autodie and Fatal are used
      # together.
  
      # NB: We must use '$sub' (the name plus package) and not
      # just '$name' (the short name) here.  Failing to do so
      # results code that's in the wrong package, and hence has
      # access to the wrong package filehandles.
  
      $cache = $Cached_fatalised_sub{$class}{$sub};
      if ($lexical) {
          $cache_type = CACHE_AUTODIE_LEAK_GUARD;
      } else {
          $cache_type = CACHE_FATAL_WRAPPER;
          $cache_type = CACHE_FATAL_VOID if $void;
      }
  
      if (my $subref = $cache->{$cache_type}) {
          $install_subs->{$name} = $subref;
          return $sref;
      }
  
      # If our subroutine is reusable (ie, not package depdendent),
      # then check to see if we've got a cached copy, and use that.
      # See RT #46984. (Thanks to Niels Thykier for being awesome!)
  
      if ($core && exists $reusable_builtins{$call}) {
          # For non-lexical subs, we can just use this cache directly
          # - for lexical variants, we need a leak guard as well.
          $code = $reusable_builtins{$call}{$lexical};
          if (!$lexical && defined($code)) {
              $install_subs->{$name} = $code;
              return $sref;
          }
      }
  
      if (!($lexical && $core) && !defined($code)) {
          # No code available, generate it now.
          my $wrapper_pkg = $pkg;
          $wrapper_pkg = undef if (exists($reusable_builtins{$call}));
          $code = $class->_compile_wrapper($wrapper_pkg, $core, $call, $name,
                                           $void, $lexical, $sub, $sref,
                                           $hints, $proto);
          if (!defined($wrapper_pkg)) {
              # cache it so we don't recompile this part again
              $reusable_builtins{$call}{$lexical} = $code;
          }
      }
  
      # Now we need to wrap our fatalised sub inside an itty bitty
      # closure, which can detect if we've leaked into another file.
      # Luckily, we only need to do this for lexical (autodie)
      # subs.  Fatal subs can leak all they want, it's considered
      # a "feature" (or at least backwards compatible).
  
      # TODO: Cache our leak guards!
  
      # TODO: This is pretty hairy code.  A lot more tests would
      # be really nice for this.
  
      my $installed_sub = $code;
  
      if ($lexical) {
          $installed_sub = $class->_make_leak_guard($filename, $code, $sref, $call,
                                                    $pkg, $proto);
      }
  
      $cache->{$cache_type} = $code;
  
      $install_subs->{$name} = $installed_sub;
  
      # Cache that we've now overridden this sub.  If we get called
      # again, we may need to find that find subroutine again (eg, for hints).
  
      $Is_fatalised_sub{$installed_sub} = $sref;
  
      return $sref;
  
  }
  
  # This subroutine exists primarily so that child classes can override
  # it to point to their own exception class.  Doing this is significantly
  # less complex than overriding throw()
  
  sub exception_class { return "autodie::exception" };
  
  {
      my %exception_class_for;
      my %class_loaded;
  
      sub throw {
          my ($class, @args) = @_;
  
          # Find our exception class if we need it.
          my $exception_class =
               $exception_class_for{$class} ||= $class->exception_class;
  
          if (not $class_loaded{$exception_class}) {
              if ($exception_class =~ /[^\w:']/) {
                  confess "Bad exception class '$exception_class'.\nThe '$class->exception_class' method wants to use $exception_class\nfor exceptions, but it contains characters which are not word-characters or colons.";
              }
  
              # Alas, Perl does turn barewords into modules unless they're
              # actually barewords.  As such, we're left doing a string eval
              # to make sure we load our file correctly.
  
              my $E;
  
              {
                  local $@;   # We can't clobber $@, it's wrong!
                  my $pm_file = $exception_class . ".pm";
                  $pm_file =~ s{ (?: :: | ' ) }{/}gx;
                  eval { require $pm_file };
                  $E = $@;    # Save $E despite ending our local.
              }
  
              # We need quotes around $@ to make sure it's stringified
              # while still in scope.  Without them, we run the risk of
              # $@ having been cleared by us exiting the local() block.
  
              confess "Failed to load '$exception_class'.\nThis may be a typo in the '$class->exception_class' method,\nor the '$exception_class' module may not exist.\n\n $E" if $E;
  
              $class_loaded{$exception_class}++;
  
          }
  
          return $exception_class->new(@args);
      }
  }
  
  # Creates and returns a leak guard (with prototype if needed).
  sub _make_leak_guard {
      my ($class, $filename, $wrapped_sub, $orig_sub, $call, $pkg, $proto) = @_;
  
      # The leak guard is rather lengthly (in fact it makes up the most
      # of _make_leak_guard).  It is possible to split it into a large
      # "generic" part and a small wrapper with call-specific
      # information.  This was done in v2.19 and profiling suggested
      # that we ended up using a substantial amount of runtime in "goto"
      # between the leak guard(s) and the final sub.  Therefore, the two
      # parts were merged into one to reduce the runtime overhead.
  
      my $leak_guard = sub {
          my $caller_level = 0;
          my $caller;
  
          while ( ($caller = (caller $caller_level)[1]) =~ m{^\(eval \d+\)$} ) {
  
              # If our filename is actually an eval, and we
              # reach it, then go to our autodying code immediatately.
  
              last if ($caller eq $filename);
              $caller_level++;
          }
  
          # We're now out of the eval stack.
  
          if ($caller eq $filename) {
              # No leak, call the wrapper.  NB: In this case, it doesn't
              # matter if it is a CORE sub or not.
              if (!defined($wrapped_sub)) {
                  # CORE sub that we were too lazy to compile when we
                  # created this leak guard.
                  die "$call is not CORE::<something>"
                      if substr($call, 0, 6) ne 'CORE::';
  
                  my $name = substr($call, 6);
                  my $sub = $name;
                  my $lexical = 1;
                  my $wrapper_pkg = $pkg;
                  my $code;
                  if (exists($reusable_builtins{$call})) {
                      $code = $reusable_builtins{$call}{$lexical};
                      $wrapper_pkg = undef;
                  }
                  if (!defined($code)) {
                      $code = $class->_compile_wrapper($wrapper_pkg,
                                                       1, # core
                                                       $call,
                                                       $name,
                                                       0, # void
                                                       $lexical,
                                                       $sub,
                                                       undef, # subref (not used for core)
                                                       undef, # hints (not used for core)
                                                       $proto);
  
                      if (!defined($wrapper_pkg)) {
                          # cache it so we don't recompile this part again
                          $reusable_builtins{$call}{$lexical} = $code;
                      }
                  }
                  # As $wrapped_sub is "closed over", updating its value will
                  # be "remembered" for the next call.
                  $wrapped_sub = $code;
              }
              goto $wrapped_sub;
          }
  
          # We leaked, time to call the original function.
          # - for non-core functions that will be $orig_sub
          # - for CORE functions, $orig_sub may be a trampoline
          goto $orig_sub if defined($orig_sub);
  
          # We are wrapping a CORE sub and we do not have a trampoline
          # yet.
          #
          # If we've cached a trampoline, then use it.  Usually only
          # resuable subs will have cache hits, but non-reusuably ones
          # can get it as well in (very) rare cases.  It is mostly in
          # cases where a package uses autodie multiple times and leaks
          # from multiple places.  Possibly something like:
          #
          #  package Pkg::With::LeakyCode;
          #  sub a {
          #      use autodie;
          #      code_that_leaks();
          #  }
          #
          #  sub b {
          #      use autodie;
          #      more_leaky_code();
          #  }
          #
          # Note that we use "Fatal" as package name for reusable subs
          # because A) that allows us to trivially re-use the
          # trampolines as well and B) because the reusable sub is
          # compiled into "package Fatal" as well.
  
          $pkg = 'Fatal' if exists $reusable_builtins{$call};
          $orig_sub = $Trampoline_cache{$pkg}{$call};
  
          if (not $orig_sub) {
              # If we don't have a trampoline, we need to build it.
              #
              # We only generate trampolines when we need them, and
              # we can cache them by subroutine + package.
              #
              # As $orig_sub is "closed over", updating its value will
              # be "remembered" for the next call.
  
              $orig_sub = make_core_trampoline($call, $pkg, $proto);
  
              # We still cache it despite remembering it in $orig_sub as
              # well.  In particularly, we rely on this to avoid
              # re-compiling the reusable trampolines.
              $Trampoline_cache{$pkg}{$call} = $orig_sub;
          }
  
          # Bounce to our trampoline, which takes us to our core sub.
          goto $orig_sub;
      };  # <-- end of leak guard
  
      # If there is a prototype on the original sub, copy it to the leak
      # guard.
      if (defined $proto) {
          # The "\&" may appear to be redundant but set_prototype
          # croaks when it is removed.
          set_prototype(\&$leak_guard, $proto);
      }
  
      return $leak_guard;
  }
  
  sub _compile_wrapper {
      my ($class, $wrapper_pkg, $core, $call, $name, $void, $lexical, $sub, $sref, $hints, $proto) = @_;
      my $real_proto = '';
      my @protos;
      my $code;
      if (defined $proto) {
          $real_proto = " ($proto)";
      } else {
          $proto = '@';
      }
  
      @protos = fill_protos($proto);
      $code = qq[
          sub$real_proto {
      ];
  
      if (!$lexical) {
          $code .= q[
             local($", $!) = (', ', 0);
          ];
      }
  
      # Don't have perl whine if exec fails, since we'll be handling
      # the exception now.
      $code .= "no warnings qw(exec);\n" if $call eq "CORE::exec";
  
      $code .= $class->_write_invocation($core, $call, $name, $void, $lexical,
                                         $sub, $sref, @protos);
      $code .= "}\n";
      warn $code if $Debug;
  
      # I thought that changing package was a monumental waste of
      # time for CORE subs, since they'll always be the same.  However
      # that's not the case, since they may refer to package-based
      # filehandles (eg, with open).
      #
      # The %reusable_builtins hash defines ones we can aggressively
      # cache as they never depend upon package-based symbols.
  
      my $E;
  
      {
          no strict 'refs'; ## no critic # to avoid: Can't use string (...) as a symbol ref ...
          local $@;
          if (defined($wrapper_pkg)) {
              $code = eval("package $wrapper_pkg; require Carp; $code");  ## no critic
          } else {
              $code = eval("require Carp; $code");  ## no critic
  
          }
          $E = $@;
      }
  
      if (not $code) {
          my $true_name = $core ? $call : $sub;
          croak("Internal error in autodie/Fatal processing $true_name: $E");
      }
      return $code;
  }
  
  # For some reason, dying while replacing our subs doesn't
  # kill our calling program.  It simply stops the loading of
  # autodie and keeps going with everything else.  The _autocroak
  # sub allows us to die with a vengeance.  It should *only* ever be
  # used for serious internal errors, since the results of it can't
  # be captured.
  
  sub _autocroak {
      warn Carp::longmess(@_);
      exit(255);  # Ugh!
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Fatal - Replace functions with equivalents which succeed or die
  
  =head1 SYNOPSIS
  
      use Fatal qw(open close);
  
      open(my $fh, "<", $filename);  # No need to check errors!
  
      use File::Copy qw(move);
      use Fatal qw(move);
  
      move($file1, $file2); # No need to check errors!
  
      sub juggle { . . . }
      Fatal->import('juggle');
  
  =head1 BEST PRACTICE
  
  B<Fatal has been obsoleted by the new L<autodie> pragma.> Please use
  L<autodie> in preference to C<Fatal>.  L<autodie> supports lexical scoping,
  throws real exception objects, and provides much nicer error messages.
  
  The use of C<:void> with Fatal is discouraged.
  
  =head1 DESCRIPTION
  
  C<Fatal> provides a way to conveniently replace
  functions which normally return a false value when they fail with
  equivalents which raise exceptions if they are not successful.  This
  lets you use these functions without having to test their return
  values explicitly on each call.  Exceptions can be caught using
  C<eval{}>.  See L<perlfunc> and L<perlvar> for details.
  
  The do-or-die equivalents are set up simply by calling Fatal's
  C<import> routine, passing it the names of the functions to be
  replaced.  You may wrap both user-defined functions and overridable
  CORE operators (except C<exec>, C<system>, C<print>, or any other
  built-in that cannot be expressed via prototypes) in this way.
  
  If the symbol C<:void> appears in the import list, then functions
  named later in that import list raise an exception only when
  these are called in void context--that is, when their return
  values are ignored.  For example
  
      use Fatal qw/:void open close/;
  
      # properly checked, so no exception raised on error
      if (not open(my $fh, '<', '/bogotic') {
          warn "Can't open /bogotic: $!";
      }
  
      # not checked, so error raises an exception
      close FH;
  
  The use of C<:void> is discouraged, as it can result in exceptions
  not being thrown if you I<accidentally> call a method without
  void context.  Use L<autodie> instead if you need to be able to
  disable autodying/Fatal behaviour for a small block of code.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Bad subroutine name for Fatal: %s
  
  You've called C<Fatal> with an argument that doesn't look like
  a subroutine name, nor a switch that this version of Fatal
  understands.
  
  =item %s is not a Perl subroutine
  
  You've asked C<Fatal> to try and replace a subroutine which does not
  exist, or has not yet been defined.
  
  =item %s is neither a builtin, nor a Perl subroutine
  
  You've asked C<Fatal> to replace a subroutine, but it's not a Perl
  built-in, and C<Fatal> couldn't find it as a regular subroutine.
  It either doesn't exist or has not yet been defined.
  
  =item Cannot make the non-overridable %s fatal
  
  You've tried to use C<Fatal> on a Perl built-in that can't be
  overridden, such as C<print> or C<system>, which means that
  C<Fatal> can't help you, although some other modules might.
  See the L</"SEE ALSO"> section of this documentation.
  
  =item Internal error: %s
  
  You've found a bug in C<Fatal>.  Please report it using
  the C<perlbug> command.
  
  =back
  
  =head1 BUGS
  
  C<Fatal> clobbers the context in which a function is called and always
  makes it a scalar context, except when the C<:void> tag is used.
  This problem does not exist in L<autodie>.
  
  "Used only once" warnings can be generated when C<autodie> or C<Fatal>
  is used with package filehandles (eg, C<FILE>).  It's strongly recommended
  you use scalar filehandles instead.
  
  =head1 AUTHOR
  
  Original module by Lionel Cons (CERN).
  
  Prototype updates by Ilya Zakharevich <ilya@math.ohio-state.edu>.
  
  L<autodie> support, bugfixes, extended diagnostics, C<system>
  support, and major overhauling by Paul Fenwick <pjf@perltraining.com.au>
  
  =head1 LICENSE
  
  This module is free software, you may distribute it under the
  same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<autodie> for a nicer way to use lexical Fatal.
  
  L<IPC::System::Simple> for a similar idea for calls to C<system()>
  and backticks.
  
  =for Pod::Coverage exception_class fill_protos one_invocation throw write_invocation ERROR_NO_IPC_SYS_SIMPLE LEXICAL_TAG
  
  =cut
FATAL

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  # vim: ts=4 sts=4 sw=4 et:
  package HTTP::Tiny;
  use strict;
  use warnings;
  # ABSTRACT: A small, simple, correct HTTP/1.1 client
  
  our $VERSION = '0.058';
  
  use Carp ();
  
  #pod =method new
  #pod
  #pod     $http = HTTP::Tiny->new( %attributes );
  #pod
  #pod This constructor returns a new HTTP::Tiny object.  Valid attributes include:
  #pod
  #pod =for :list
  #pod * C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If
  #pod   C<agent> — ends in a space character, the default user-agent string is
  #pod   appended.
  #pod * C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class
  #pod   that supports the C<add> and C<cookie_header> methods
  #pod * C<default_headers> — A hashref of default headers to apply to requests
  #pod * C<local_address> — The local IP address to bind to
  #pod * C<keep_alive> — Whether to reuse the last connection (if for the same
  #pod   scheme, host and port) (defaults to 1)
  #pod * C<max_redirect> — Maximum number of redirects allowed (defaults to 5)
  #pod * C<max_size> — Maximum response size in bytes (only when not using a data
  #pod   callback).  If defined, responses larger than this will return an
  #pod   exception.
  #pod * C<http_proxy> — URL of a proxy server to use for HTTP connections
  #pod   (default is C<$ENV{http_proxy}> — if set)
  #pod * C<https_proxy> — URL of a proxy server to use for HTTPS connections
  #pod   (default is C<$ENV{https_proxy}> — if set)
  #pod * C<proxy> — URL of a generic proxy server for both HTTP and HTTPS
  #pod   connections (default is C<$ENV{all_proxy}> — if set)
  #pod * C<no_proxy> — List of domain suffixes that should not be proxied.  Must
  #pod   be a comma-separated string or an array reference. (default is
  #pod   C<$ENV{no_proxy}> —)
  #pod * C<timeout> — Request timeout in seconds (default is 60) If a socket open,
  #pod   read or write takes longer than the timeout, an exception is thrown.
  #pod * C<verify_SSL> — A boolean that indicates whether to validate the SSL
  #pod   certificate of an C<https> — connection (default is false)
  #pod * C<SSL_options> — A hashref of C<SSL_*> — options to pass through to
  #pod   L<IO::Socket::SSL>
  #pod
  #pod Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
  #pod prevent getting the corresponding proxies from the environment.
  #pod
  #pod Exceptions from C<max_size>, C<timeout> or other errors will result in a
  #pod pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
  #pod content field in the response will contain the text of the exception.
  #pod
  #pod The C<keep_alive> parameter enables a persistent connection, but only to a
  #pod single destination scheme, host and port.  Also, if any connection-relevant
  #pod attributes are modified, or if the process ID or thread ID change, the
  #pod persistent connection will be dropped.  If you want persistent connections
  #pod across multiple destinations, use multiple HTTP::Tiny objects.
  #pod
  #pod See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
  #pod
  #pod =cut
  
  my @attributes;
  BEGIN {
      @attributes = qw(
          cookie_jar default_headers http_proxy https_proxy keep_alive
          local_address max_redirect max_size proxy no_proxy
          SSL_options verify_SSL
      );
      my %persist_ok = map {; $_ => 1 } qw(
          cookie_jar default_headers max_redirect max_size
      );
      no strict 'refs';
      no warnings 'uninitialized';
      for my $accessor ( @attributes ) {
          *{$accessor} = sub {
              @_ > 1
                  ? do {
                      delete $_[0]->{handle} if !$persist_ok{$accessor} && $_[1] ne $_[0]->{$accessor};
                      $_[0]->{$accessor} = $_[1]
                  }
                  : $_[0]->{$accessor};
          };
      }
  }
  
  sub agent {
      my($self, $agent) = @_;
      if( @_ > 1 ){
          $self->{agent} =
              (defined $agent && $agent =~ / $/) ? $agent . $self->_agent : $agent;
      }
      return $self->{agent};
  }
  
  sub timeout {
      my ($self, $timeout) = @_;
      if ( @_ > 1 ) {
          $self->{timeout} = $timeout;
          if ($self->{handle}) {
              $self->{handle}->timeout($timeout);
          }
      }
      return $self->{timeout};
  }
  
  sub new {
      my($class, %args) = @_;
  
      my $self = {
          max_redirect => 5,
          timeout      => 60,
          keep_alive   => 1,
          verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, # no verification by default
          no_proxy     => $ENV{no_proxy},
      };
  
      bless $self, $class;
  
      $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};
  
      for my $key ( @attributes ) {
          $self->{$key} = $args{$key} if exists $args{$key}
      }
  
      $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );
  
      $self->_set_proxies;
  
      return $self;
  }
  
  sub _set_proxies {
      my ($self) = @_;
  
      # get proxies from %ENV only if not provided; explicit undef will disable
      # getting proxies from the environment
  
      # generic proxy
      if (! exists $self->{proxy} ) {
          $self->{proxy} = $ENV{all_proxy} || $ENV{ALL_PROXY};
      }
  
      if ( defined $self->{proxy} ) {
          $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
      }
      else {
          delete $self->{proxy};
      }
  
      # http proxy
      if (! exists $self->{http_proxy} ) {
          # under CGI, bypass HTTP_PROXY as request sets it from Proxy header
          local $ENV{HTTP_PROXY} if $ENV{REQUEST_METHOD};
          $self->{http_proxy} = $ENV{http_proxy} || $ENV{HTTP_PROXY} || $self->{proxy};
      }
  
      if ( defined $self->{http_proxy} ) {
          $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
          $self->{_has_proxy}{http} = 1;
      }
      else {
          delete $self->{http_proxy};
      }
  
      # https proxy
      if (! exists $self->{https_proxy} ) {
          $self->{https_proxy} = $ENV{https_proxy} || $ENV{HTTPS_PROXY} || $self->{proxy};
      }
  
      if ( $self->{https_proxy} ) {
          $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
          $self->{_has_proxy}{https} = 1;
      }
      else {
          delete $self->{https_proxy};
      }
  
      # Split no_proxy to array reference if not provided as such
      unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
          $self->{no_proxy} =
              (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
      }
  
      return;
  }
  
  #pod =method get|head|put|post|delete
  #pod
  #pod     $response = $http->get($url);
  #pod     $response = $http->get($url, \%options);
  #pod     $response = $http->head($url);
  #pod
  #pod These methods are shorthand for calling C<request()> for the given method.  The
  #pod URL must have unsafe characters escaped and international domain names encoded.
  #pod See C<request()> for valid options and a description of the response.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX.
  #pod
  #pod =cut
  
  for my $sub_name ( qw/get head put post delete/ ) {
      my $req_method = uc $sub_name;
      no strict 'refs';
      eval <<"HERE"; ## no critic
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
  }
  
  #pod =method post_form
  #pod
  #pod     $response = $http->post_form($url, $form_data);
  #pod     $response = $http->post_form($url, $form_data, \%options);
  #pod
  #pod This method executes a C<POST> request and sends the key/value pairs from a
  #pod form data hash or array reference to the given URL with a C<content-type> of
  #pod C<application/x-www-form-urlencoded>.  If data is provided as an array
  #pod reference, the order is preserved; if provided as a hash reference, the terms
  #pod are sorted on key and value for consistency.  See documentation for the
  #pod C<www_form_urlencode> method for details on the encoding.
  #pod
  #pod The URL must have unsafe characters escaped and international domain names
  #pod encoded.  See C<request()> for valid options and a description of the response.
  #pod Any C<content-type> header or content in the options hashref will be ignored.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX.
  #pod
  #pod =cut
  
  sub post_form {
      my ($self, $url, $data, $args) = @_;
      (@_ == 3 || @_ == 4 && ref $args eq 'HASH')
          or Carp::croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ . "\n");
  
      my $headers = {};
      while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
          $headers->{lc $key} = $value;
      }
      delete $args->{headers};
  
      return $self->request('POST', $url, {
              %$args,
              content => $self->www_form_urlencode($data),
              headers => {
                  %$headers,
                  'content-type' => 'application/x-www-form-urlencoded'
              },
          }
      );
  }
  
  #pod =method mirror
  #pod
  #pod     $response = $http->mirror($url, $file, \%options)
  #pod     if ( $response->{success} ) {
  #pod         print "$file is up to date\n";
  #pod     }
  #pod
  #pod Executes a C<GET> request for the URL and saves the response body to the file
  #pod name provided.  The URL must have unsafe characters escaped and international
  #pod domain names encoded.  If the file already exists, the request will include an
  #pod C<If-Modified-Since> header with the modification timestamp of the file.  You
  #pod may specify a different C<If-Modified-Since> header yourself in the C<<
  #pod $options->{headers} >> hash.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX
  #pod or if the status code is 304 (unmodified).
  #pod
  #pod If the file was modified and the server response includes a properly
  #pod formatted C<Last-Modified> header, the file modification time will
  #pod be updated accordingly.
  #pod
  #pod =cut
  
  sub mirror {
      my ($self, $url, $file, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ . "\n");
      if ( -e $file and my $mtime = (stat($file))[9] ) {
          $args->{headers}{'if-modified-since'} ||= $self->_http_date($mtime);
      }
      my $tempfile = $file . int(rand(2**31));
  
      require Fcntl;
      sysopen my $fh, $tempfile, Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()
         or Carp::croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);
      binmode $fh;
      $args->{data_callback} = sub { print {$fh} $_[0] };
      my $response = $self->request('GET', $url, $args);
      close $fh
          or Carp::croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);
  
      if ( $response->{success} ) {
          rename $tempfile, $file
              or Carp::croak(qq/Error replacing $file with $tempfile: $!\n/);
          my $lm = $response->{headers}{'last-modified'};
          if ( $lm and my $mtime = $self->_parse_http_date($lm) ) {
              utime $mtime, $mtime, $file;
          }
      }
      $response->{success} ||= $response->{status} eq '304';
      unlink $tempfile;
      return $response;
  }
  
  #pod =method request
  #pod
  #pod     $response = $http->request($method, $url);
  #pod     $response = $http->request($method, $url, \%options);
  #pod
  #pod Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
  #pod 'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
  #pod international domain names encoded.
  #pod
  #pod If the URL includes a "user:password" stanza, they will be used for Basic-style
  #pod authorization headers.  (Authorization headers will not be included in a
  #pod redirected request.) For example:
  #pod
  #pod     $http->request('GET', 'http://Aladdin:open sesame@example.com/');
  #pod
  #pod If the "user:password" stanza contains reserved characters, they must
  #pod be percent-escaped:
  #pod
  #pod     $http->request('GET', 'http://john%40example.com:password@example.com/');
  #pod
  #pod A hashref of options may be appended to modify the request.
  #pod
  #pod Valid options are:
  #pod
  #pod =for :list
  #pod * C<headers> —
  #pod     A hashref containing headers to include with the request.  If the value for
  #pod     a header is an array reference, the header will be output multiple times with
  #pod     each value in the array.  These headers over-write any default headers.
  #pod * C<content> —
  #pod     A scalar to include as the body of the request OR a code reference
  #pod     that will be called iteratively to produce the body of the request
  #pod * C<trailer_callback> —
  #pod     A code reference that will be called if it exists to provide a hashref
  #pod     of trailing headers (only used with chunked transfer-encoding)
  #pod * C<data_callback> —
  #pod     A code reference that will be called for each chunks of the response
  #pod     body received.
  #pod * C<peer> —
  #pod     Override host resolution and force all connections to go only to a
  #pod     specific peer address, regardless of the URL of the request.  This will
  #pod     include any redirections!  This options should be used with extreme
  #pod     caution (e.g. debugging or very special circumstances).
  #pod
  #pod The C<Host> header is generated from the URL in accordance with RFC 2616.  It
  #pod is a fatal error to specify C<Host> in the C<headers> option.  Other headers
  #pod may be ignored or overwritten if necessary for transport compliance.
  #pod
  #pod If the C<content> option is a code reference, it will be called iteratively
  #pod to provide the content body of the request.  It should return the empty
  #pod string or undef when the iterator is exhausted.
  #pod
  #pod If the C<content> option is the empty string, no C<content-type> or
  #pod C<content-length> headers will be generated.
  #pod
  #pod If the C<data_callback> option is provided, it will be called iteratively until
  #pod the entire response body is received.  The first argument will be a string
  #pod containing a chunk of the response body, the second argument will be the
  #pod in-progress response hash reference, as described below.  (This allows
  #pod customizing the action of the callback based on the C<status> or C<headers>
  #pod received prior to the content body.)
  #pod
  #pod The C<request> method returns a hashref containing the response.  The hashref
  #pod will have the following keys:
  #pod
  #pod =for :list
  #pod * C<success> —
  #pod     Boolean indicating whether the operation returned a 2XX status code
  #pod * C<url> —
  #pod     URL that provided the response. This is the URL of the request unless
  #pod     there were redirections, in which case it is the last URL queried
  #pod     in a redirection chain
  #pod * C<status> —
  #pod     The HTTP status code of the response
  #pod * C<reason> —
  #pod     The response phrase returned by the server
  #pod * C<content> —
  #pod     The body of the response.  If the response does not have any content
  #pod     or if a data callback is provided to consume the response body,
  #pod     this will be the empty string
  #pod * C<headers> —
  #pod     A hashref of header fields.  All header field names will be normalized
  #pod     to be lower case. If a header is repeated, the value will be an arrayref;
  #pod     it will otherwise be a scalar string containing the value
  #pod * C<redirects>
  #pod     If this field exists, it is an arrayref of response hash references from
  #pod     redirects in the same order that redirections occurred.  If it does
  #pod     not exist, then no redirections occurred.
  #pod
  #pod On an exception during the execution of the request, the C<status> field will
  #pod contain 599, and the C<content> field will contain the text of the exception.
  #pod
  #pod =cut
  
  my %idempotent = map { $_ => 1 } qw/GET HEAD PUT DELETE OPTIONS TRACE/;
  
  sub request {
      my ($self, $method, $url, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ . "\n");
      $args ||= {}; # we keep some state in this during _request
  
      # RFC 2616 Section 8.1.4 mandates a single retry on broken socket
      my $response;
      for ( 0 .. 1 ) {
          $response = eval { $self->_request($method, $url, $args) };
          last unless $@ && $idempotent{$method}
              && $@ =~ m{^(?:Socket closed|Unexpected end)};
      }
  
      if (my $e = $@) {
          # maybe we got a response hash thrown from somewhere deep
          if ( ref $e eq 'HASH' && exists $e->{status} ) {
              return $e;
          }
  
          # otherwise, stringify it
          $e = "$e";
          $response = {
              url     => $url,
              success => q{},
              status  => 599,
              reason  => 'Internal Exception',
              content => $e,
              headers => {
                  'content-type'   => 'text/plain',
                  'content-length' => length $e,
              }
          };
      }
      return $response;
  }
  
  #pod =method www_form_urlencode
  #pod
  #pod     $params = $http->www_form_urlencode( $data );
  #pod     $response = $http->get("http://example.com/query?$params");
  #pod
  #pod This method converts the key/value pairs from a data hash or array reference
  #pod into a C<x-www-form-urlencoded> string.  The keys and values from the data
  #pod reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
  #pod array reference, the key will be repeated with each of the values of the array
  #pod reference.  If data is provided as a hash reference, the key/value pairs in the
  #pod resulting string will be sorted by key and value for consistent ordering.
  #pod
  #pod =cut
  
  sub www_form_urlencode {
      my ($self, $data) = @_;
      (@_ == 2 && ref $data)
          or Carp::croak(q/Usage: $http->www_form_urlencode(DATAREF)/ . "\n");
      (ref $data eq 'HASH' || ref $data eq 'ARRAY')
          or Carp::croak("form data must be a hash or array reference\n");
  
      my @params = ref $data eq 'HASH' ? %$data : @$data;
      @params % 2 == 0
          or Carp::croak("form data reference must have an even number of terms\n");
  
      my @terms;
      while( @params ) {
          my ($key, $value) = splice(@params, 0, 2);
          if ( ref $value eq 'ARRAY' ) {
              unshift @params, map { $key => $_ } @$value;
          }
          else {
              push @terms, join("=", map { $self->_uri_escape($_) } $key, $value);
          }
      }
  
      return join("&", (ref $data eq 'ARRAY') ? (@terms) : (sort @terms) );
  }
  
  #pod =method can_ssl
  #pod
  #pod     $ok         = HTTP::Tiny->can_ssl;
  #pod     ($ok, $why) = HTTP::Tiny->can_ssl;
  #pod     ($ok, $why) = $http->can_ssl;
  #pod
  #pod Indicates if SSL support is available.  When called as a class object, it
  #pod checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
  #pod When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
  #pod is set in C<SSL_options>, it checks that a CA file is available.
  #pod
  #pod In scalar context, returns a boolean indicating if SSL is available.
  #pod In list context, returns the boolean and a (possibly multi-line) string of
  #pod errors indicating why SSL isn't available.
  #pod
  #pod =cut
  
  sub can_ssl {
      my ($self) = @_;
  
      my($ok, $reason) = (1, '');
  
      # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
      unless (eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)}) {
          $ok = 0;
          $reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/;
      }
  
      # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
      unless (eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)}) {
          $ok = 0;
          $reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/;
      }
  
      # If an object, check that SSL config lets us get a CA if necessary
      if ( ref($self) && ( $self->{verify_SSL} || $self->{SSL_options}{SSL_verify_mode} ) ) {
          my $handle = HTTP::Tiny::Handle->new(
              SSL_options => $self->{SSL_options},
              verify_SSL  => $self->{verify_SSL},
          );
          unless ( eval { $handle->_find_CA_file; 1 } ) {
              $ok = 0;
              $reason .= "$@";
          }
      }
  
      wantarray ? ($ok, $reason) : $ok;
  }
  
  #pod =method connected
  #pod
  #pod     $host = $http->connected;
  #pod     ($host, $port) = $http->connected;
  #pod
  #pod Indicates if a connection to a peer is being kept alive, per the C<keep_alive>
  #pod option.
  #pod
  #pod In scalar context, returns the peer host and port, joined with a colon, or
  #pod C<undef> (if no peer is connected).
  #pod In list context, returns the peer host and port or an empty list (if no peer
  #pod is connected).
  #pod
  #pod B<Note>: This method cannot reliably be used to discover whether the remote
  #pod host has closed its end of the socket.
  #pod
  #pod =cut
  
  sub connected {
      my ($self) = @_;
  
      # If a socket exists...
      if ($self->{handle} && $self->{handle}{fh}) {
          my $socket = $self->{handle}{fh};
  
          # ...and is connected, return the peer host and port.
          if ($socket->connected) {
              return wantarray
                  ? ($socket->peerhost, $socket->peerport)
                  : join(':', $socket->peerhost, $socket->peerport);
          }
      }
      return;
  }
  
  #--------------------------------------------------------------------------#
  # private methods
  #--------------------------------------------------------------------------#
  
  my %DefaultPort = (
      http => 80,
      https => 443,
  );
  
  sub _agent {
      my $class = ref($_[0]) || $_[0];
      (my $default_agent = $class) =~ s{::}{-}g;
      return $default_agent . "/" . $class->VERSION;
  }
  
  sub _request {
      my ($self, $method, $url, $args) = @_;
  
      my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);
  
      my $request = {
          method    => $method,
          scheme    => $scheme,
          host      => $host,
          port      => $port,
          host_port => ($port == $DefaultPort{$scheme} ? $host : "$host:$port"),
          uri       => $path_query,
          headers   => {},
      };
  
      my $peer = $args->{peer} || $host;
  
      # We remove the cached handle so it is not reused in the case of redirect.
      # If all is well, it will be recached at the end of _request.  We only
      # reuse for the same scheme, host and port
      my $handle = delete $self->{handle};
      if ( $handle ) {
          unless ( $handle->can_reuse( $scheme, $host, $port, $peer ) ) {
              $handle->close;
              undef $handle;
          }
      }
      $handle ||= $self->_open_handle( $request, $scheme, $host, $port, $peer );
  
      $self->_prepare_headers_and_cb($request, $args, $url, $auth);
      $handle->write_request($request);
  
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
  
      $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};
      my @redir_args = $self->_maybe_redirect($request, $response, $args);
  
      my $known_message_length;
      if ($method eq 'HEAD' || $response->{status} =~ /^[23]04/) {
          # response has no message body
          $known_message_length = 1;
      }
      else {
          # Ignore any data callbacks during redirection.
          my $cb_args = @redir_args ? +{} : $args;
          my $data_cb = $self->_prepare_data_cb($response, $cb_args);
          $known_message_length = $handle->read_body($data_cb, $response);
      }
  
      if ( $self->{keep_alive}
          && $known_message_length
          && $response->{protocol} eq 'HTTP/1.1'
          && ($response->{headers}{connection} || '') ne 'close'
      ) {
          $self->{handle} = $handle;
      }
      else {
          $handle->close;
      }
  
      $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
      $response->{url} = $url;
  
      # Push the current response onto the stack of redirects if redirecting.
      if (@redir_args) {
          push @{$args->{_redirects}}, $response;
          return $self->_request(@redir_args, $args);
      }
  
      # Copy the stack of redirects into the response before returning.
      $response->{redirects} = delete $args->{_redirects}
        if @{$args->{_redirects}};
      return $response;
  }
  
  sub _open_handle {
      my ($self, $request, $scheme, $host, $port, $peer) = @_;
  
      my $handle  = HTTP::Tiny::Handle->new(
          timeout         => $self->{timeout},
          SSL_options     => $self->{SSL_options},
          verify_SSL      => $self->{verify_SSL},
          local_address   => $self->{local_address},
          keep_alive      => $self->{keep_alive}
      );
  
      if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @{$self->{no_proxy}}) {
          return $self->_proxy_connect( $request, $handle );
      }
      else {
          return $handle->connect($scheme, $host, $port, $peer);
      }
  }
  
  sub _proxy_connect {
      my ($self, $request, $handle) = @_;
  
      my @proxy_vars;
      if ( $request->{scheme} eq 'https' ) {
          Carp::croak(qq{No https_proxy defined}) unless $self->{https_proxy};
          @proxy_vars = $self->_split_proxy( https_proxy => $self->{https_proxy} );
          if ( $proxy_vars[0] eq 'https' ) {
              Carp::croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}});
          }
      }
      else {
          Carp::croak(qq{No http_proxy defined}) unless $self->{http_proxy};
          @proxy_vars = $self->_split_proxy( http_proxy => $self->{http_proxy} );
      }
  
      my ($p_scheme, $p_host, $p_port, $p_auth) = @proxy_vars;
  
      if ( length $p_auth && ! defined $request->{headers}{'proxy-authorization'} ) {
          $self->_add_basic_auth_header( $request, 'proxy-authorization' => $p_auth );
      }
  
      $handle->connect($p_scheme, $p_host, $p_port, $p_host);
  
      if ($request->{scheme} eq 'https') {
          $self->_create_proxy_tunnel( $request, $handle );
      }
      else {
          # non-tunneled proxy requires absolute URI
          $request->{uri} = "$request->{scheme}://$request->{host_port}$request->{uri}";
      }
  
      return $handle;
  }
  
  sub _split_proxy {
      my ($self, $type, $proxy) = @_;
  
      my ($scheme, $host, $port, $path_query, $auth) = eval { $self->_split_url($proxy) };
  
      unless(
          defined($scheme) && length($scheme) && length($host) && length($port)
          && $path_query eq '/'
      ) {
          Carp::croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n});
      }
  
      return ($scheme, $host, $port, $auth);
  }
  
  sub _create_proxy_tunnel {
      my ($self, $request, $handle) = @_;
  
      $handle->_assert_ssl;
  
      my $agent = exists($request->{headers}{'user-agent'})
          ? $request->{headers}{'user-agent'} : $self->{agent};
  
      my $connect_request = {
          method    => 'CONNECT',
          uri       => "$request->{host}:$request->{port}",
          headers   => {
              host => "$request->{host}:$request->{port}",
              'user-agent' => $agent,
          }
      };
  
      if ( $request->{headers}{'proxy-authorization'} ) {
          $connect_request->{headers}{'proxy-authorization'} =
              delete $request->{headers}{'proxy-authorization'};
      }
  
      $handle->write_request($connect_request);
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
  
      # if CONNECT failed, throw the response so it will be
      # returned from the original request() method;
      unless (substr($response->{status},0,1) eq '2') {
          die $response;
      }
  
      # tunnel established, so start SSL handshake
      $handle->start_ssl( $request->{host} );
  
      return;
  }
  
  sub _prepare_headers_and_cb {
      my ($self, $request, $args, $url, $auth) = @_;
  
      for ($self->{default_headers}, $args->{headers}) {
          next unless defined;
          while (my ($k, $v) = each %$_) {
              $request->{headers}{lc $k} = $v;
              $request->{header_case}{lc $k} = $k;
          }
      }
  
      if (exists $request->{headers}{'host'}) {
          die(qq/The 'Host' header must not be provided as header option\n/);
      }
  
      $request->{headers}{'host'}         = $request->{host_port};
      $request->{headers}{'user-agent'} ||= $self->{agent};
      $request->{headers}{'connection'}   = "close"
          unless $self->{keep_alive};
  
      if ( defined $args->{content} ) {
          if (ref $args->{content} eq 'CODE') {
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'transfer-encoding'} = 'chunked'
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = $args->{content};
          }
          elsif ( length $args->{content} ) {
              my $content = $args->{content};
              if ( $] ge '5.008' ) {
                  utf8::downgrade($content, 1)
                      or die(qq/Wide character in request message body\n/);
              }
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'content-length'} = length $content
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = sub { substr $content, 0, length $content, '' };
          }
          $request->{trailer_cb} = $args->{trailer_callback}
              if ref $args->{trailer_callback} eq 'CODE';
      }
  
      ### If we have a cookie jar, then maybe add relevant cookies
      if ( $self->{cookie_jar} ) {
          my $cookies = $self->cookie_jar->cookie_header( $url );
          $request->{headers}{cookie} = $cookies if length $cookies;
      }
  
      # if we have Basic auth parameters, add them
      if ( length $auth && ! defined $request->{headers}{authorization} ) {
          $self->_add_basic_auth_header( $request, 'authorization' => $auth );
      }
  
      return;
  }
  
  sub _add_basic_auth_header {
      my ($self, $request, $header, $auth) = @_;
      require MIME::Base64;
      $request->{headers}{$header} =
          "Basic " . MIME::Base64::encode_base64($auth, "");
      return;
  }
  
  sub _prepare_data_cb {
      my ($self, $response, $args) = @_;
      my $data_cb = $args->{data_callback};
      $response->{content} = '';
  
      if (!$data_cb || $response->{status} !~ /^2/) {
          if (defined $self->{max_size}) {
              $data_cb = sub {
                  $_[1]->{content} .= $_[0];
                  die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
                    if length $_[1]->{content} > $self->{max_size};
              };
          }
          else {
              $data_cb = sub { $_[1]->{content} .= $_[0] };
          }
      }
      return $data_cb;
  }
  
  sub _update_cookie_jar {
      my ($self, $url, $response) = @_;
  
      my $cookies = $response->{headers}->{'set-cookie'};
      return unless defined $cookies;
  
      my @cookies = ref $cookies ? @$cookies : $cookies;
  
      $self->cookie_jar->add( $url, $_ ) for @cookies;
  
      return;
  }
  
  sub _validate_cookie_jar {
      my ($class, $jar) = @_;
  
      # duck typing
      for my $method ( qw/add cookie_header/ ) {
          Carp::croak(qq/Cookie jar must provide the '$method' method\n/)
              unless ref($jar) && ref($jar)->can($method);
      }
  
      return;
  }
  
  sub _maybe_redirect {
      my ($self, $request, $response, $args) = @_;
      my $headers = $response->{headers};
      my ($status, $method) = ($response->{status}, $request->{method});
      $args->{_redirects} ||= [];
  
      if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))
          and $headers->{location}
          and @{$args->{_redirects}} < $self->{max_redirect}
      ) {
          my $location = ($headers->{location} =~ /^\//)
              ? "$request->{scheme}://$request->{host_port}$headers->{location}"
              : $headers->{location} ;
          return (($status eq '303' ? 'GET' : $method), $location);
      }
      return;
  }
  
  sub _split_url {
      my $url = pop;
  
      # URI regex adapted from the URI module
      my ($scheme, $host, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
        or die(qq/Cannot parse URL: '$url'\n/);
  
      $scheme     = lc $scheme;
      $path_query = "/$path_query" unless $path_query =~ m<\A/>;
  
      my $auth = '';
      if ( (my $i = index $host, '@') != -1 ) {
          # user:pass@host
          $auth = substr $host, 0, $i, ''; # take up to the @ for auth
          substr $host, 0, 1, '';          # knock the @ off the host
  
          # userinfo might be percent escaped, so recover real auth info
          $auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
      }
      my $port = $host =~ s/:(\d*)\z// && length $1 ? $1
               : $scheme eq 'http'                  ? 80
               : $scheme eq 'https'                 ? 443
               : undef;
  
      return ($scheme, (length $host ? lc $host : "localhost") , $port, $path_query, $auth);
  }
  
  # Date conversions adapted from HTTP::Date
  my $DoW = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
  my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
  sub _http_date {
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($_[1]);
      return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
          substr($DoW,$wday*4,3),
          $mday, substr($MoY,$mon*4,3), $year+1900,
          $hour, $min, $sec
      );
  }
  
  sub _parse_http_date {
      my ($self, $str) = @_;
      require Time::Local;
      my @tl_parts;
      if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/ ) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/ ) {
          @tl_parts = ($5, $4, $3, $2, (index($MoY,$1)/4), $6);
      }
      return eval {
          my $t = @tl_parts ? Time::Local::timegm(@tl_parts) : -1;
          $t < 0 ? undef : $t;
      };
  }
  
  # URI escaping adapted from URI::Escape
  # c.f. http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
  # perl 5.6 ready UTF-8 encoding adapted from JSON::PP
  my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
  $escapes{' '}="+";
  my $unsafe_char = qr/[^A-Za-z0-9\-\._~]/;
  
  sub _uri_escape {
      my ($self, $str) = @_;
      if ( $] ge '5.008' ) {
          utf8::encode($str);
      }
      else {
          $str = pack("U*", unpack("C*", $str)) # UTF-8 encode a byte string
              if ( length $str == do { use bytes; length $str } );
          $str = pack("C*", unpack("C*", $str)); # clear UTF-8 flag
      }
      $str =~ s/($unsafe_char)/$escapes{$1}/ge;
      return $str;
  }
  
  package
      HTTP::Tiny::Handle; # hide from PAUSE/indexers
  use strict;
  use warnings;
  
  use Errno      qw[EINTR EPIPE];
  use IO::Socket qw[SOCK_STREAM];
  use Socket     qw[SOL_SOCKET SO_KEEPALIVE];
  
  # PERL_HTTP_TINY_IPV4_ONLY is a private environment variable to force old
  # behavior if someone is unable to boostrap CPAN from a new perl install; it is
  # not intended for general, per-client use and may be removed in the future
  my $SOCKET_CLASS =
      $ENV{PERL_HTTP_TINY_IPV4_ONLY} ? 'IO::Socket::INET' :
      eval { require IO::Socket::IP; IO::Socket::IP->VERSION(0.25) } ? 'IO::Socket::IP' :
      'IO::Socket::INET';
  
  sub BUFSIZE () { 32768 } ## no critic
  
  my $Printable = sub {
      local $_ = shift;
      s/\r/\\r/g;
      s/\n/\\n/g;
      s/\t/\\t/g;
      s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;
      $_;
  };
  
  my $Token = qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;
  my $Field_Content = qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;
  
  sub new {
      my ($class, %args) = @_;
      return bless {
          rbuf             => '',
          timeout          => 60,
          max_line_size    => 16384,
          max_header_lines => 64,
          verify_SSL       => 0,
          SSL_options      => {},
          %args
      }, $class;
  }
  
  sub timeout {
      my ($self, $timeout) = @_;
      if ( @_ > 1 ) {
          $self->{timeout} = $timeout;
          if ( $self->{fh} && $self->{fh}->can('timeout') ) {
              $self->{fh}->timeout($timeout);
          }
      }
      return $self->{timeout};
  }
  
  sub connect {
      @_ == 5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ . "\n");
      my ($self, $scheme, $host, $port, $peer) = @_;
  
      if ( $scheme eq 'https' ) {
          $self->_assert_ssl;
      }
      elsif ( $scheme ne 'http' ) {
        die(qq/Unsupported URL scheme '$scheme'\n/);
      }
      $self->{fh} = $SOCKET_CLASS->new(
          PeerHost  => $peer,
          PeerPort  => $port,
          $self->{local_address} ?
              ( LocalAddr => $self->{local_address} ) : (),
          Proto     => 'tcp',
          Type      => SOCK_STREAM,
          Timeout   => $self->{timeout},
      ) or die(qq/Could not connect to '$host:$port': $@\n/);
  
      binmode($self->{fh})
        or die(qq/Could not binmode() socket: '$!'\n/);
  
      if ( $self->{keep_alive} ) {
          unless ( defined( $self->{fh}->setsockopt( SOL_SOCKET, SO_KEEPALIVE, 1 ) ) ) {
              CORE::close($self->{fh});
              die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/);
          }
      }
  
      $self->start_ssl($host) if $scheme eq 'https';
  
      $self->{scheme} = $scheme;
      $self->{host} = $host;
      $self->{peer} = $peer;
      $self->{port} = $port;
      $self->{pid} = $$;
      $self->{tid} = _get_tid();
  
      return $self;
  }
  
  sub start_ssl {
      my ($self, $host) = @_;
  
      # As this might be used via CONNECT after an SSL session
      # to a proxy, we shut down any existing SSL before attempting
      # the handshake
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          unless ( $self->{fh}->stop_SSL ) {
              my $ssl_err = IO::Socket::SSL->errstr;
              die(qq/Error halting prior SSL connection: $ssl_err/);
          }
      }
  
      my $ssl_args = $self->_ssl_args($host);
      IO::Socket::SSL->start_SSL(
          $self->{fh},
          %$ssl_args,
          SSL_create_ctx_callback => sub {
              my $ctx = shift;
              Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
          },
      );
  
      unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          my $ssl_err = IO::Socket::SSL->errstr;
          die(qq/SSL connection failed for $host: $ssl_err\n/);
      }
  }
  
  sub close {
      @_ == 1 || die(q/Usage: $handle->close()/ . "\n");
      my ($self) = @_;
      CORE::close($self->{fh})
        or die(qq/Could not close socket: '$!'\n/);
  }
  
  sub write {
      @_ == 2 || die(q/Usage: $handle->write(buf)/ . "\n");
      my ($self, $buf) = @_;
  
      if ( $] ge '5.008' ) {
          utf8::downgrade($buf, 1)
              or die(qq/Wide character in write()\n/);
      }
  
      my $len = length $buf;
      my $off = 0;
  
      local $SIG{PIPE} = 'IGNORE';
  
      while () {
          $self->can_write
            or die(qq/Timed out while waiting for socket to become ready for writing\n/);
          my $r = syswrite($self->{fh}, $buf, $len, $off);
          if (defined $r) {
              $len -= $r;
              $off += $r;
              last unless $len > 0;
          }
          elsif ($! == EPIPE) {
              die(qq/Socket closed by remote server: $!\n/);
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not write to SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not write to socket: '$!'\n/);
              }
  
          }
      }
      return $off;
  }
  
  sub read {
      @_ == 2 || @_ == 3 || die(q/Usage: $handle->read(len [, allow_partial])/ . "\n");
      my ($self, $len, $allow_partial) = @_;
  
      my $buf  = '';
      my $got = length $self->{rbuf};
  
      if ($got) {
          my $take = ($got < $len) ? $got : $len;
          $buf  = substr($self->{rbuf}, 0, $take, '');
          $len -= $take;
      }
  
      while ($len > 0) {
          $self->can_read
            or die(q/Timed out while waiting for socket to become ready for reading/ . "\n");
          my $r = sysread($self->{fh}, $buf, $len, length $buf);
          if (defined $r) {
              last unless $r;
              $len -= $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      if ($len && !$allow_partial) {
          die(qq/Unexpected end of stream\n/);
      }
      return $buf;
  }
  
  sub readline {
      @_ == 1 || die(q/Usage: $handle->readline()/ . "\n");
      my ($self) = @_;
  
      while () {
          if ($self->{rbuf} =~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x) {
              return $1;
          }
          if (length $self->{rbuf} >= $self->{max_line_size}) {
              die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/);
          }
          $self->can_read
            or die(qq/Timed out while waiting for socket to become ready for reading\n/);
          my $r = sysread($self->{fh}, $self->{rbuf}, BUFSIZE, length $self->{rbuf});
          if (defined $r) {
              last unless $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      die(qq/Unexpected end of stream while looking for line\n/);
  }
  
  sub read_header_lines {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->read_header_lines([headers])/ . "\n");
      my ($self, $headers) = @_;
      $headers ||= {};
      my $lines   = 0;
      my $val;
  
      while () {
           my $line = $self->readline;
  
           if (++$lines >= $self->{max_header_lines}) {
               die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/);
           }
           elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x) {
               my ($field_name) = lc $1;
               if (exists $headers->{$field_name}) {
                   for ($headers->{$field_name}) {
                       $_ = [$_] unless ref $_ eq "ARRAY";
                       push @$_, $2;
                       $val = \$_->[-1];
                   }
               }
               else {
                   $val = \($headers->{$field_name} = $2);
               }
           }
           elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x) {
               $val
                 or die(qq/Unexpected header continuation line\n/);
               next unless length $1;
               $$val .= ' ' if length $$val;
               $$val .= $1;
           }
           elsif ($line =~ /\A \x0D?\x0A \z/x) {
              last;
           }
           else {
              die(q/Malformed header line: / . $Printable->($line) . "\n");
           }
      }
      return $headers;
  }
  
  sub write_request {
      @_ == 2 || die(q/Usage: $handle->write_request(request)/ . "\n");
      my($self, $request) = @_;
      $self->write_request_header(@{$request}{qw/method uri headers header_case/});
      $self->write_body($request) if $request->{cb};
      return;
  }
  
  # Standard request header names/case from HTTP/1.1 RFCs
  my @rfc_request_headers = qw(
    Accept Accept-Charset Accept-Encoding Accept-Language Authorization
    Cache-Control Connection Content-Length Expect From Host
    If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
    Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer
    Transfer-Encoding Upgrade User-Agent Via
  );
  
  my @other_request_headers = qw(
    Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin
    X-XSS-Protection
  );
  
  my %HeaderCase = map { lc($_) => $_ } @rfc_request_headers, @other_request_headers;
  
  # to avoid multiple small writes and hence nagle, you can pass the method line or anything else to
  # combine writes.
  sub write_header_lines {
      (@_ >= 2 && @_ <= 4 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ . "\n");
      my($self, $headers, $header_case, $prefix_data) = @_;
      $header_case ||= {};
  
      my $buf = (defined $prefix_data ? $prefix_data : '');
  
      # Per RFC, control fields should be listed first
      my %seen;
      for my $k ( qw/host cache-control expect max-forwards pragma range te/ ) {
          next unless exists $headers->{$k};
          $seen{$k}++;
          my $field_name = $HeaderCase{$k};
          my $v = $headers->{$k};
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              $_ = '' unless defined $_;
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
  
      # Other headers sent in arbitrary order
      while (my ($k, $v) = each %$headers) {
          my $field_name = lc $k;
          next if $seen{$field_name};
          if (exists $HeaderCase{$field_name}) {
              $field_name = $HeaderCase{$field_name};
          }
          else {
              if (exists $header_case->{$field_name}) {
                  $field_name = $header_case->{$field_name};
              }
              else {
                  $field_name =~ s/\b(\w)/\u$1/g;
              }
              $field_name =~ /\A $Token+ \z/xo
                or die(q/Invalid HTTP header field name: / . $Printable->($field_name) . "\n");
              $HeaderCase{lc $field_name} = $field_name;
          }
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              # unwrap a field value if pre-wrapped by user
              s/\x0D?\x0A\s+/ /g;
              die(qq/Invalid HTTP header field value ($field_name): / . $Printable->($_). "\n")
                unless $_ eq '' || /\A $Field_Content \z/xo;
              $_ = '' unless defined $_;
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
      $buf .= "\x0D\x0A";
      return $self->write($buf);
  }
  
  # return value indicates whether message length was defined; this is generally
  # true unless there was no content-length header and we just read until EOF.
  # Other message length errors are thrown as exceptions
  sub read_body {
      @_ == 3 || die(q/Usage: $handle->read_body(callback, response)/ . "\n");
      my ($self, $cb, $response) = @_;
      my $te = $response->{headers}{'transfer-encoding'} || '';
      my $chunked = grep { /chunked/i } ( ref $te eq 'ARRAY' ? @$te : $te ) ;
      return $chunked
          ? $self->read_chunked_body($cb, $response)
          : $self->read_content_body($cb, $response);
  }
  
  sub write_body {
      @_ == 2 || die(q/Usage: $handle->write_body(request)/ . "\n");
      my ($self, $request) = @_;
      if ($request->{headers}{'content-length'}) {
          return $self->write_content_body($request);
      }
      else {
          return $self->write_chunked_body($request);
      }
  }
  
  sub read_content_body {
      @_ == 3 || @_ == 4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ . "\n");
      my ($self, $cb, $response, $content_length) = @_;
      $content_length ||= $response->{headers}{'content-length'};
  
      if ( defined $content_length ) {
          my $len = $content_length;
          while ($len > 0) {
              my $read = ($len > BUFSIZE) ? BUFSIZE : $len;
              $cb->($self->read($read, 0), $response);
              $len -= $read;
          }
          return length($self->{rbuf}) == 0;
      }
  
      my $chunk;
      $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );
  
      return;
  }
  
  sub write_content_body {
      @_ == 2 || die(q/Usage: $handle->write_content_body(request)/ . "\n");
      my ($self, $request) = @_;
  
      my ($len, $content_length) = (0, $request->{headers}{'content-length'});
      while () {
          my $data = $request->{cb}->();
  
          defined $data && length $data
            or last;
  
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_content()\n/);
          }
  
          $len += $self->write($data);
      }
  
      $len == $content_length
        or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);
  
      return $len;
  }
  
  sub read_chunked_body {
      @_ == 3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ . "\n");
      my ($self, $cb, $response) = @_;
  
      while () {
          my $head = $self->readline;
  
          $head =~ /\A ([A-Fa-f0-9]+)/x
            or die(q/Malformed chunk head: / . $Printable->($head) . "\n");
  
          my $len = hex($1)
            or last;
  
          $self->read_content_body($cb, $response, $len);
  
          $self->read(2) eq "\x0D\x0A"
            or die(qq/Malformed chunk: missing CRLF after chunk data\n/);
      }
      $self->read_header_lines($response->{headers});
      return 1;
  }
  
  sub write_chunked_body {
      @_ == 2 || die(q/Usage: $handle->write_chunked_body(request)/ . "\n");
      my ($self, $request) = @_;
  
      my $len = 0;
      while () {
          my $data = $request->{cb}->();
  
          defined $data && length $data
            or last;
  
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_chunked_body()\n/);
          }
  
          $len += length $data;
  
          my $chunk  = sprintf '%X', length $data;
             $chunk .= "\x0D\x0A";
             $chunk .= $data;
             $chunk .= "\x0D\x0A";
  
          $self->write($chunk);
      }
      $self->write("0\x0D\x0A");
      $self->write_header_lines($request->{trailer_cb}->())
          if ref $request->{trailer_cb} eq 'CODE';
      return $len;
  }
  
  sub read_response_header {
      @_ == 1 || die(q/Usage: $handle->read_response_header()/ . "\n");
      my ($self) = @_;
  
      my $line = $self->readline;
  
      $line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x
        or die(q/Malformed Status-Line: / . $Printable->($line). "\n");
  
      my ($protocol, $version, $status, $reason) = ($1, $2, $3, $4);
  
      die (qq/Unsupported HTTP protocol: $protocol\n/)
          unless $version =~ /0*1\.0*[01]/;
  
      return {
          status       => $status,
          reason       => $reason,
          headers      => $self->read_header_lines,
          protocol     => $protocol,
      };
  }
  
  sub write_request_header {
      @_ == 5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ . "\n");
      my ($self, $method, $request_uri, $headers, $header_case) = @_;
  
      return $self->write_header_lines($headers, $header_case, "$method $request_uri HTTP/1.1\x0D\x0A");
  }
  
  sub _do_timeout {
      my ($self, $type, $timeout) = @_;
      $timeout = $self->{timeout}
          unless defined $timeout && $timeout >= 0;
  
      my $fd = fileno $self->{fh};
      defined $fd && $fd >= 0
        or die(qq/select(2): 'Bad file descriptor'\n/);
  
      my $initial = time;
      my $pending = $timeout;
      my $nfound;
  
      vec(my $fdset = '', $fd, 1) = 1;
  
      while () {
          $nfound = ($type eq 'read')
              ? select($fdset, undef, undef, $pending)
              : select(undef, $fdset, undef, $pending) ;
          if ($nfound == -1) {
              $! == EINTR
                or die(qq/select(2): '$!'\n/);
              redo if !$timeout || ($pending = $timeout - (time - $initial)) > 0;
              $nfound = 0;
          }
          last;
      }
      $! = 0;
      return $nfound;
  }
  
  sub can_read {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_read([timeout])/ . "\n");
      my $self = shift;
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          return 1 if $self->{fh}->pending;
      }
      return $self->_do_timeout('read', @_)
  }
  
  sub can_write {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_write([timeout])/ . "\n");
      my $self = shift;
      return $self->_do_timeout('write', @_)
  }
  
  sub _assert_ssl {
      my($ok, $reason) = HTTP::Tiny->can_ssl();
      die $reason unless $ok;
  }
  
  sub can_reuse {
      my ($self,$scheme,$host,$port,$peer) = @_;
      return 0 if
          $self->{pid} != $$
          || $self->{tid} != _get_tid()
          || length($self->{rbuf})
          || $scheme ne $self->{scheme}
          || $host ne $self->{host}
          || $port ne $self->{port}
          || $peer ne $self->{peer}
          || eval { $self->can_read(0) }
          || $@ ;
          return 1;
  }
  
  # Try to find a CA bundle to validate the SSL cert,
  # prefer Mozilla::CA or fallback to a system file
  sub _find_CA_file {
      my $self = shift();
  
      my $ca_file =
        defined( $self->{SSL_options}->{SSL_ca_file} )
        ? $self->{SSL_options}->{SSL_ca_file}
        : $ENV{SSL_CERT_FILE};
  
      if ( defined $ca_file ) {
          unless ( -r $ca_file ) {
              die qq/SSL_ca_file '$ca_file' not found or not readable\n/;
          }
          return $ca_file;
      }
  
      return Mozilla::CA::SSL_ca_file()
          if eval { require Mozilla::CA; 1 };
  
      # cert list copied from golang src/crypto/x509/root_unix.go
      foreach my $ca_bundle (
          "/etc/ssl/certs/ca-certificates.crt",     # Debian/Ubuntu/Gentoo etc.
          "/etc/pki/tls/certs/ca-bundle.crt",       # Fedora/RHEL
          "/etc/ssl/ca-bundle.pem",                 # OpenSUSE
          "/etc/openssl/certs/ca-certificates.crt", # NetBSD
          "/etc/ssl/cert.pem",                      # OpenBSD
          "/usr/local/share/certs/ca-root-nss.crt", # FreeBSD/DragonFly
          "/etc/pki/tls/cacert.pem",                # OpenELEC
          "/etc/certs/ca-certificates.crt",         # Solaris 11.2+
      ) {
          return $ca_bundle if -e $ca_bundle;
      }
  
      die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/
        . qq/Try installing Mozilla::CA from CPAN\n/;
  }
  
  # for thread safety, we need to know thread id if threads are loaded
  sub _get_tid {
      no warnings 'reserved'; # for 'threads'
      return threads->can("tid") ? threads->tid : 0;
  }
  
  sub _ssl_args {
      my ($self, $host) = @_;
  
      my %ssl_args;
  
      # This test reimplements IO::Socket::SSL::can_client_sni(), which wasn't
      # added until IO::Socket::SSL 1.84
      if ( Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000 ) {
          $ssl_args{SSL_hostname} = $host,          # Sane SNI support
      }
  
      if ($self->{verify_SSL}) {
          $ssl_args{SSL_verifycn_scheme}  = 'http'; # enable CN validation
          $ssl_args{SSL_verifycn_name}    = $host;  # set validation hostname
          $ssl_args{SSL_verify_mode}      = 0x01;   # enable cert validation
          $ssl_args{SSL_ca_file}          = $self->_find_CA_file;
      }
      else {
          $ssl_args{SSL_verifycn_scheme}  = 'none'; # disable CN validation
          $ssl_args{SSL_verify_mode}      = 0x00;   # disable cert validation
      }
  
      # user options override settings from verify_SSL
      for my $k ( keys %{$self->{SSL_options}} ) {
          $ssl_args{$k} = $self->{SSL_options}{$k} if $k =~ m/^SSL_/;
      }
  
      return \%ssl_args;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Tiny - A small, simple, correct HTTP/1.1 client
  
  =head1 VERSION
  
  version 0.058
  
  =head1 SYNOPSIS
  
      use HTTP::Tiny;
  
      my $response = HTTP::Tiny->new->get('http://example.com/');
  
      die "Failed!\n" unless $response->{success};
  
      print "$response->{status} $response->{reason}\n";
  
      while (my ($k, $v) = each %{$response->{headers}}) {
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              print "$k: $_\n";
          }
      }
  
      print $response->{content} if length $response->{content};
  
  =head1 DESCRIPTION
  
  This is a very simple HTTP/1.1 client, designed for doing simple
  requests without the overhead of a large framework like L<LWP::UserAgent>.
  
  It is more correct and more complete than L<HTTP::Lite>.  It supports
  proxies and redirection.  It also correctly resumes after EINTR.
  
  If L<IO::Socket::IP> 0.25 or later is installed, HTTP::Tiny will use it instead
  of L<IO::Socket::INET> for transparent support for both IPv4 and IPv6.
  
  Cookie support requires L<HTTP::CookieJar> or an equivalent class.
  
  =head1 METHODS
  
  =head2 new
  
      $http = HTTP::Tiny->new( %attributes );
  
  This constructor returns a new HTTP::Tiny object.  Valid attributes include:
  
  =over 4
  
  =item *
  
  C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> — ends in a space character, the default user-agent string is appended.
  
  =item *
  
  C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class that supports the C<add> and C<cookie_header> methods
  
  =item *
  
  C<default_headers> — A hashref of default headers to apply to requests
  
  =item *
  
  C<local_address> — The local IP address to bind to
  
  =item *
  
  C<keep_alive> — Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
  
  =item *
  
  C<max_redirect> — Maximum number of redirects allowed (defaults to 5)
  
  =item *
  
  C<max_size> — Maximum response size in bytes (only when not using a data callback).  If defined, responses larger than this will return an exception.
  
  =item *
  
  C<http_proxy> — URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> — if set)
  
  =item *
  
  C<https_proxy> — URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> — if set)
  
  =item *
  
  C<proxy> — URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> — if set)
  
  =item *
  
  C<no_proxy> — List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}> —)
  
  =item *
  
  C<timeout> — Request timeout in seconds (default is 60) If a socket open, read or write takes longer than the timeout, an exception is thrown.
  
  =item *
  
  C<verify_SSL> — A boolean that indicates whether to validate the SSL certificate of an C<https> — connection (default is false)
  
  =item *
  
  C<SSL_options> — A hashref of C<SSL_*> — options to pass through to L<IO::Socket::SSL>
  
  =back
  
  Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
  prevent getting the corresponding proxies from the environment.
  
  Exceptions from C<max_size>, C<timeout> or other errors will result in a
  pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
  content field in the response will contain the text of the exception.
  
  The C<keep_alive> parameter enables a persistent connection, but only to a
  single destination scheme, host and port.  Also, if any connection-relevant
  attributes are modified, or if the process ID or thread ID change, the
  persistent connection will be dropped.  If you want persistent connections
  across multiple destinations, use multiple HTTP::Tiny objects.
  
  See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
  
  =head2 get|head|put|post|delete
  
      $response = $http->get($url);
      $response = $http->get($url, \%options);
      $response = $http->head($url);
  
  These methods are shorthand for calling C<request()> for the given method.  The
  URL must have unsafe characters escaped and international domain names encoded.
  See C<request()> for valid options and a description of the response.
  
  The C<success> field of the response will be true if the status code is 2XX.
  
  =head2 post_form
  
      $response = $http->post_form($url, $form_data);
      $response = $http->post_form($url, $form_data, \%options);
  
  This method executes a C<POST> request and sends the key/value pairs from a
  form data hash or array reference to the given URL with a C<content-type> of
  C<application/x-www-form-urlencoded>.  If data is provided as an array
  reference, the order is preserved; if provided as a hash reference, the terms
  are sorted on key and value for consistency.  See documentation for the
  C<www_form_urlencode> method for details on the encoding.
  
  The URL must have unsafe characters escaped and international domain names
  encoded.  See C<request()> for valid options and a description of the response.
  Any C<content-type> header or content in the options hashref will be ignored.
  
  The C<success> field of the response will be true if the status code is 2XX.
  
  =head2 mirror
  
      $response = $http->mirror($url, $file, \%options)
      if ( $response->{success} ) {
          print "$file is up to date\n";
      }
  
  Executes a C<GET> request for the URL and saves the response body to the file
  name provided.  The URL must have unsafe characters escaped and international
  domain names encoded.  If the file already exists, the request will include an
  C<If-Modified-Since> header with the modification timestamp of the file.  You
  may specify a different C<If-Modified-Since> header yourself in the C<<
  $options->{headers} >> hash.
  
  The C<success> field of the response will be true if the status code is 2XX
  or if the status code is 304 (unmodified).
  
  If the file was modified and the server response includes a properly
  formatted C<Last-Modified> header, the file modification time will
  be updated accordingly.
  
  =head2 request
  
      $response = $http->request($method, $url);
      $response = $http->request($method, $url, \%options);
  
  Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
  'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
  international domain names encoded.
  
  If the URL includes a "user:password" stanza, they will be used for Basic-style
  authorization headers.  (Authorization headers will not be included in a
  redirected request.) For example:
  
      $http->request('GET', 'http://Aladdin:open sesame@example.com/');
  
  If the "user:password" stanza contains reserved characters, they must
  be percent-escaped:
  
      $http->request('GET', 'http://john%40example.com:password@example.com/');
  
  A hashref of options may be appended to modify the request.
  
  Valid options are:
  
  =over 4
  
  =item *
  
  C<headers> — A hashref containing headers to include with the request.  If the value for a header is an array reference, the header will be output multiple times with each value in the array.  These headers over-write any default headers.
  
  =item *
  
  C<content> — A scalar to include as the body of the request OR a code reference that will be called iteratively to produce the body of the request
  
  =item *
  
  C<trailer_callback> — A code reference that will be called if it exists to provide a hashref of trailing headers (only used with chunked transfer-encoding)
  
  =item *
  
  C<data_callback> — A code reference that will be called for each chunks of the response body received.
  
  =item *
  
  C<peer> — Override host resolution and force all connections to go only to a specific peer address, regardless of the URL of the request.  This will include any redirections!  This options should be used with extreme caution (e.g. debugging or very special circumstances).
  
  =back
  
  The C<Host> header is generated from the URL in accordance with RFC 2616.  It
  is a fatal error to specify C<Host> in the C<headers> option.  Other headers
  may be ignored or overwritten if necessary for transport compliance.
  
  If the C<content> option is a code reference, it will be called iteratively
  to provide the content body of the request.  It should return the empty
  string or undef when the iterator is exhausted.
  
  If the C<content> option is the empty string, no C<content-type> or
  C<content-length> headers will be generated.
  
  If the C<data_callback> option is provided, it will be called iteratively until
  the entire response body is received.  The first argument will be a string
  containing a chunk of the response body, the second argument will be the
  in-progress response hash reference, as described below.  (This allows
  customizing the action of the callback based on the C<status> or C<headers>
  received prior to the content body.)
  
  The C<request> method returns a hashref containing the response.  The hashref
  will have the following keys:
  
  =over 4
  
  =item *
  
  C<success> — Boolean indicating whether the operation returned a 2XX status code
  
  =item *
  
  C<url> — URL that provided the response. This is the URL of the request unless there were redirections, in which case it is the last URL queried in a redirection chain
  
  =item *
  
  C<status> — The HTTP status code of the response
  
  =item *
  
  C<reason> — The response phrase returned by the server
  
  =item *
  
  C<content> — The body of the response.  If the response does not have any content or if a data callback is provided to consume the response body, this will be the empty string
  
  =item *
  
  C<headers> — A hashref of header fields.  All header field names will be normalized to be lower case. If a header is repeated, the value will be an arrayref; it will otherwise be a scalar string containing the value
  
  =item *
  
  C<redirects> If this field exists, it is an arrayref of response hash references from redirects in the same order that redirections occurred.  If it does not exist, then no redirections occurred.
  
  =back
  
  On an exception during the execution of the request, the C<status> field will
  contain 599, and the C<content> field will contain the text of the exception.
  
  =head2 www_form_urlencode
  
      $params = $http->www_form_urlencode( $data );
      $response = $http->get("http://example.com/query?$params");
  
  This method converts the key/value pairs from a data hash or array reference
  into a C<x-www-form-urlencoded> string.  The keys and values from the data
  reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
  array reference, the key will be repeated with each of the values of the array
  reference.  If data is provided as a hash reference, the key/value pairs in the
  resulting string will be sorted by key and value for consistent ordering.
  
  =head2 can_ssl
  
      $ok         = HTTP::Tiny->can_ssl;
      ($ok, $why) = HTTP::Tiny->can_ssl;
      ($ok, $why) = $http->can_ssl;
  
  Indicates if SSL support is available.  When called as a class object, it
  checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
  When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
  is set in C<SSL_options>, it checks that a CA file is available.
  
  In scalar context, returns a boolean indicating if SSL is available.
  In list context, returns the boolean and a (possibly multi-line) string of
  errors indicating why SSL isn't available.
  
  =head2 connected
  
      $host = $http->connected;
      ($host, $port) = $http->connected;
  
  Indicates if a connection to a peer is being kept alive, per the C<keep_alive>
  option.
  
  In scalar context, returns the peer host and port, joined with a colon, or
  C<undef> (if no peer is connected).
  In list context, returns the peer host and port or an empty list (if no peer
  is connected).
  
  B<Note>: This method cannot reliably be used to discover whether the remote
  host has closed its end of the socket.
  
  =for Pod::Coverage SSL_options
  agent
  cookie_jar
  default_headers
  http_proxy
  https_proxy
  keep_alive
  local_address
  max_redirect
  max_size
  no_proxy
  proxy
  timeout
  verify_SSL
  
  =head1 SSL SUPPORT
  
  Direct C<https> connections are supported only if L<IO::Socket::SSL> 1.56 or
  greater and L<Net::SSLeay> 1.49 or greater are installed. An exception will be
  thrown if new enough versions of these modules are not installed or if the SSL
  encryption fails. You can also use C<HTTP::Tiny::can_ssl()> utility function
  that returns boolean to see if the required modules are installed.
  
  An C<https> connection may be made via an C<http> proxy that supports the CONNECT
  command (i.e. RFC 2817).  You may not proxy C<https> via a proxy that itself
  requires C<https> to communicate.
  
  SSL provides two distinct capabilities:
  
  =over 4
  
  =item *
  
  Encrypted communication channel
  
  =item *
  
  Verification of server identity
  
  =back
  
  B<By default, HTTP::Tiny does not verify server identity>.
  
  Server identity verification is controversial and potentially tricky because it
  depends on a (usually paid) third-party Certificate Authority (CA) trust model
  to validate a certificate as legitimate.  This discriminates against servers
  with self-signed certificates or certificates signed by free, community-driven
  CA's such as L<CAcert.org|http://cacert.org>.
  
  By default, HTTP::Tiny does not make any assumptions about your trust model,
  threat level or risk tolerance.  It just aims to give you an encrypted channel
  when you need one.
  
  Setting the C<verify_SSL> attribute to a true value will make HTTP::Tiny verify
  that an SSL connection has a valid SSL certificate corresponding to the host
  name of the connection and that the SSL certificate has been verified by a CA.
  Assuming you trust the CA, this will protect against a L<man-in-the-middle
  attack|http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If you are
  concerned about security, you should enable this option.
  
  Certificate verification requires a file containing trusted CA certificates.
  
  If the environment variable C<SSL_CERT_FILE> is present, HTTP::Tiny
  will try to find a CA certificate file in that location.
  
  If the L<Mozilla::CA> module is installed, HTTP::Tiny will use the CA file
  included with it as a source of trusted CA's.  (This means you trust Mozilla,
  the author of Mozilla::CA, the CPAN mirror where you got Mozilla::CA, the
  toolchain used to install it, and your operating system security, right?)
  
  If that module is not available, then HTTP::Tiny will search several
  system-specific default locations for a CA certificate file:
  
  =over 4
  
  =item *
  
  /etc/ssl/certs/ca-certificates.crt
  
  =item *
  
  /etc/pki/tls/certs/ca-bundle.crt
  
  =item *
  
  /etc/ssl/ca-bundle.pem
  
  =back
  
  An exception will be raised if C<verify_SSL> is true and no CA certificate file
  is available.
  
  If you desire complete control over SSL connections, the C<SSL_options> attribute
  lets you provide a hash reference that will be passed through to
  C<IO::Socket::SSL::start_SSL()>, overriding any options set by HTTP::Tiny. For
  example, to provide your own trusted CA file:
  
      SSL_options => {
          SSL_ca_file => $file_path,
      }
  
  The C<SSL_options> attribute could also be used for such things as providing a
  client certificate for authentication to a server or controlling the choice of
  cipher used for the SSL connection. See L<IO::Socket::SSL> documentation for
  details.
  
  =head1 PROXY SUPPORT
  
  HTTP::Tiny can proxy both C<http> and C<https> requests.  Only Basic proxy
  authorization is supported and it must be provided as part of the proxy URL:
  C<http://user:pass@proxy.example.com/>.
  
  HTTP::Tiny supports the following proxy environment variables:
  
  =over 4
  
  =item *
  
  http_proxy or HTTP_PROXY
  
  =item *
  
  https_proxy or HTTPS_PROXY
  
  =item *
  
  all_proxy or ALL_PROXY
  
  =back
  
  If the C<REQUEST_METHOD> environment variable is set, then this might be a CGI
  process and C<HTTP_PROXY> would be set from the C<Proxy:> header, which is a
  security risk.  If C<REQUEST_METHOD> is set, C<HTTP_PROXY> (the upper case
  variant only) is ignored.
  
  Tunnelling C<https> over an C<http> proxy using the CONNECT method is
  supported.  If your proxy uses C<https> itself, you can not tunnel C<https>
  over it.
  
  Be warned that proxying an C<https> connection opens you to the risk of a
  man-in-the-middle attack by the proxy server.
  
  The C<no_proxy> environment variable is supported in the format of a
  comma-separated list of domain extensions proxy should not be used for.
  
  Proxy arguments passed to C<new> will override their corresponding
  environment variables.
  
  =head1 LIMITATIONS
  
  HTTP::Tiny is I<conditionally compliant> with the
  L<HTTP/1.1 specifications|http://www.w3.org/Protocols/>:
  
  =over 4
  
  =item *
  
  "Message Syntax and Routing" [RFC7230]
  
  =item *
  
  "Semantics and Content" [RFC7231]
  
  =item *
  
  "Conditional Requests" [RFC7232]
  
  =item *
  
  "Range Requests" [RFC7233]
  
  =item *
  
  "Caching" [RFC7234]
  
  =item *
  
  "Authentication" [RFC7235]
  
  =back
  
  It attempts to meet all "MUST" requirements of the specification, but does not
  implement all "SHOULD" requirements.  (Note: it was developed against the
  earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235
  spec.)
  
  Some particular limitations of note include:
  
  =over
  
  =item *
  
  HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring
  that user-defined headers and content are compliant with the HTTP/1.1
  specification.
  
  =item *
  
  Users must ensure that URLs are properly escaped for unsafe characters and that
  international domain names are properly encoded to ASCII. See L<URI::Escape>,
  L<URI::_punycode> and L<Net::IDN::Encode>.
  
  =item *
  
  Redirection is very strict against the specification.  Redirection is only
  automatic for response codes 301, 302, 307 and 308 if the request method is
  'GET' or 'HEAD'.  Response code 303 is always converted into a 'GET'
  redirection, as mandated by the specification.  There is no automatic support
  for status 305 ("Use proxy") redirections.
  
  =item *
  
  There is no provision for delaying a request body using an C<Expect> header.
  Unexpected C<1XX> responses are silently ignored as per the specification.
  
  =item *
  
  Only 'chunked' C<Transfer-Encoding> is supported.
  
  =item *
  
  There is no support for a Request-URI of '*' for the 'OPTIONS' request.
  
  =item *
  
  Headers mentioned in the RFCs and some other, well-known headers are
  generated with their canonical case.  Other headers are sent in the
  case provided by the user.  Except for control headers (which are sent first),
  headers are sent in arbitrary order.
  
  =back
  
  Despite the limitations listed above, HTTP::Tiny is considered
  feature-complete.  New feature requests should be directed to
  L<HTTP::Tiny::UA>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<HTTP::Tiny::UA> - Higher level UA features for HTTP::Tiny
  
  =item *
  
  L<HTTP::Thin> - HTTP::Tiny wrapper with L<HTTP::Request>/L<HTTP::Response> compatibility
  
  =item *
  
  L<HTTP::Tiny::Mech> - Wrap L<WWW::Mechanize> instance in HTTP::Tiny compatible interface
  
  =item *
  
  L<IO::Socket::IP> - Required for IPv6 support
  
  =item *
  
  L<IO::Socket::SSL> - Required for SSL support
  
  =item *
  
  L<LWP::UserAgent> - If HTTP::Tiny isn't enough for you, this is the "standard" way to do things
  
  =item *
  
  L<Mozilla::CA> - Required if you want to validate SSL certificates
  
  =item *
  
  L<Net::SSLeay> - Required for SSL support
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/chansen/p5-http-tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/chansen/p5-http-tiny>
  
    git clone https://github.com/chansen/p5-http-tiny.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Christian Hansen <chansen@cpan.org>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Alan Gardner Alessandro Ghedini A. Sinan Unur Brad Gilbert brian m. carlson Chris Nehren Weyl Claes Jakobsson Clinton Gormley David Golden Dean Pearce Edward Zborowski James Raspass Jeremy Mates Jess Robinson Lukas Eklund Martin J. Evans Martin-Louis Bright Mike Doherty Olaf Alders Olivier Mengué Petr Písař SkyMarshal Sören Kornetzki Syohei YOSHIDA Tatsuhiko Miyagawa Tom Hukins Tony Cook
  
  =over 4
  
  =item *
  
  Alan Gardner <gardner@pythian.com>
  
  =item *
  
  Alessandro Ghedini <al3xbio@gmail.com>
  
  =item *
  
  A. Sinan Unur <nanis@cpan.org>
  
  =item *
  
  Brad Gilbert <bgills@cpan.org>
  
  =item *
  
  brian m. carlson <sandals@crustytoothpaste.net>
  
  =item *
  
  Chris Nehren <apeiron@cpan.org>
  
  =item *
  
  Chris Weyl <cweyl@alumni.drew.edu>
  
  =item *
  
  Claes Jakobsson <claes@surfar.nu>
  
  =item *
  
  Clinton Gormley <clint@traveljury.com>
  
  =item *
  
  David Golden <xdg@xdg.me>
  
  =item *
  
  Dean Pearce <pearce@pythian.com>
  
  =item *
  
  Edward Zborowski <ed@rubensteintech.com>
  
  =item *
  
  James Raspass <jraspass@gmail.com>
  
  =item *
  
  Jeremy Mates <jmates@cpan.org>
  
  =item *
  
  Jess Robinson <castaway@desert-island.me.uk>
  
  =item *
  
  Lukas Eklund <leklund@gmail.com>
  
  =item *
  
  Martin J. Evans <mjegh@ntlworld.com>
  
  =item *
  
  Martin-Louis Bright <mlbright@gmail.com>
  
  =item *
  
  Mike Doherty <doherty@cpan.org>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Petr Písař <ppisar@redhat.com>
  
  =item *
  
  SkyMarshal <skymarshal1729@gmail.com>
  
  =item *
  
  Sören Kornetzki <soeren.kornetzki@delti.com>
  
  =item *
  
  Syohei YOSHIDA <syohex@gmail.com>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  Tom Hukins <tom@eborcom.com>
  
  =item *
  
  Tony Cook <tony@develop-help.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Christian Hansen.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_TINY

$fatpacked{"JSON/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_TINY';
  package JSON::Tiny;
  
  # Minimalistic JSON. Adapted from Mojo::JSON. (c)2012-2015 David Oswald
  # License: Artistic 2.0 license.
  # http://www.perlfoundation.org/artistic_license_2_0
  
  use strict;
  use warnings;
  use Carp 'croak';
  use Exporter 'import';
  use Scalar::Util 'blessed';
  use Encode ();
  
  our $VERSION = '0.56';
  our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);
  
  # Literal names
  # Users may override Booleans with literal 0 or 1 if desired.
  our($FALSE, $TRUE) = map { bless \(my $dummy = $_), 'JSON::Tiny::_Bool' } 0, 1;
  
  # Escaped special character map with u2028 and u2029
  my %ESCAPE = (
    '"'     => '"',
    '\\'    => '\\',
    '/'     => '/',
    'b'     => "\x08",
    'f'     => "\x0c",
    'n'     => "\x0a",
    'r'     => "\x0d",
    't'     => "\x09",
    'u2028' => "\x{2028}",
    'u2029' => "\x{2029}"
  );
  my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;
  
  for(0x00 .. 0x1f) {
    my $packed = pack 'C', $_;
    $REVERSE{$packed} = sprintf '\u%.4X', $_ unless defined $REVERSE{$packed};
  }
  
  sub decode_json {
    my $err = _decode(\my $value, shift);
    return defined $err ? croak $err : $value;
  }
  
  sub encode_json { Encode::encode 'UTF-8', _encode_value(shift) }
  
  sub false () {$FALSE}  ## no critic (prototypes)
  
  sub from_json {
    my $err = _decode(\my $value, shift, 1);
    return defined $err ? croak $err : $value;
  }
  
  sub j {
    return encode_json $_[0] if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
    return decode_json $_[0];
  }
  
  sub to_json { _encode_value(shift) }
  
  sub true () {$TRUE} ## no critic (prototypes)
  
  sub _decode {
    my $valueref = shift;
  
    eval {
  
      # Missing input
      die "Missing or empty input\n" unless length( local $_ = shift );
  
      # UTF-8
      $_ = eval { Encode::decode('UTF-8', $_, 1) } unless shift;
      die "Input is not UTF-8 encoded\n" unless defined $_;
  
      # Value
      $$valueref = _decode_value();
  
      # Leftover data
      return m/\G[\x20\x09\x0a\x0d]*\z/gc || _throw('Unexpected data');
    } ? return undef : chomp $@;
  
    return $@;
  }
  
  sub _decode_array {
    my @array;
    until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {
  
      # Value
      push @array, _decode_value();
  
      # Separator
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if m/\G[\x20\x09\x0a\x0d]*\]/gc;
  
      # Invalid character
      _throw('Expected comma or right square bracket while parsing array');
    }
  
    return \@array;
  }
  
  sub _decode_object {
    my %hash;
    until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {
  
      # Quote
      m/\G[\x20\x09\x0a\x0d]*"/gc
        or _throw('Expected string while parsing object');
  
      # Key
      my $key = _decode_string();
  
      # Colon
      m/\G[\x20\x09\x0a\x0d]*:/gc
        or _throw('Expected colon while parsing object');
  
      # Value
      $hash{$key} = _decode_value();
  
      # Separator
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if m/\G[\x20\x09\x0a\x0d]*\}/gc;
  
      # Invalid character
      _throw('Expected comma or right curly bracket while parsing object');
    }
  
    return \%hash;
  }
  
  sub _decode_string {
    my $pos = pos;
    
    # Extract string with escaped characters
    m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc; # segfault on 5.8.x in t/20-mojo-json.t
    my $str = $1;
  
    # Invalid character
    unless (m/\G"/gc) {
      _throw('Unexpected character or invalid escape while parsing string')
        if m/\G[\x00-\x1f\\]/;
      _throw('Unterminated string');
    }
  
    # Unescape popular characters
    if (index($str, '\\u') < 0) {
      $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
      return $str;
    }
  
    # Unescape everything else
    my $buffer = '';
    while ($str =~ m/\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
      $buffer .= $1;
  
      # Popular character
      if ($2) { $buffer .= $ESCAPE{$2} }
  
      # Escaped
      else {
        my $ord = hex $3;
  
        # Surrogate pair
        if (($ord & 0xf800) == 0xd800) {
  
          # High surrogate
          ($ord & 0xfc00) == 0xd800
            or pos($_) = $pos + pos($str), _throw('Missing high-surrogate');
  
          # Low surrogate
          $str =~ m/\G\\u([Dd][C-Fc-f]..)/gc
            or pos($_) = $pos + pos($str), _throw('Missing low-surrogate');
  
          $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
        }
  
        # Character
        $buffer .= pack 'U', $ord;
      }
    }
  
    # The rest
    return $buffer . substr $str, pos $str, length $str;
  }
  
  sub _decode_value {
  
    # Leading whitespace
    m/\G[\x20\x09\x0a\x0d]*/gc;
  
    # String
    return _decode_string() if m/\G"/gc;
  
    # Object
    return _decode_object() if m/\G\{/gc;
  
    # Array
    return _decode_array() if m/\G\[/gc;
  
    # Number
    my ($i) = /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;
    return 0 + $i if defined $i;
  
    # True
    return $TRUE if m/\Gtrue/gc;
  
    # False
    return $FALSE if m/\Gfalse/gc;
  
    # Null
    return undef if m/\Gnull/gc;  ## no critic (return)
  
    # Invalid character
    _throw('Expected string, array, object, number, boolean or null');
  }
  
  sub _encode_array {
    '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
  }
  
  sub _encode_object {
    my $object = shift;
    my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
      sort keys %$object;
    return '{' . join(',', @pairs) . '}';
  }
  
  sub _encode_string {
    my $str = shift;
    $str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;
    return "\"$str\"";
  }
  
  sub _encode_value {
    my $value = shift;
  
    # Reference
    if (my $ref = ref $value) {
  
      # Object
      return _encode_object($value) if $ref eq 'HASH';
  
      # Array
      return _encode_array($value) if $ref eq 'ARRAY';
  
      # True or false
      return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
      return $value  ? 'true' : 'false' if $ref eq 'JSON::Tiny::_Bool';
  
      # Blessed reference with TO_JSON method
      if (blessed $value && (my $sub = $value->can('TO_JSON'))) {
        return _encode_value($value->$sub);
      }
    }
  
    # Null
    return 'null' unless defined $value;
  
  
    # Number (bitwise operators change behavior based on the internal value type)
  
    # "0" & $x will modify the flags on the "0" on perl < 5.14, so use a copy
    my $zero = "0";
    # "0" & $num -> 0. "0" & "" -> "". "0" & $string -> a character.
    # this maintains the internal type but speeds up the xor below.
    my $check = $zero & $value;
    return $value
      if length $check
      # 0 ^ itself          -> 0    (false)
      # $character ^ itself -> "\0" (true)
      && !($check ^ $check)
      # filter out "upgraded" strings whose numeric form doesn't strictly match
      && 0 + $value eq $value
      # filter out inf and nan
      && $value * 0 == 0;
  
    # String
    return _encode_string($value);
  }
  
  sub _throw {
  
    # Leading whitespace
    m/\G[\x20\x09\x0a\x0d]*/gc;
  
    # Context
    my $context = 'Malformed JSON: ' . shift;
    if (m/\G\z/gc) { $context .= ' before end of data' }
    else {
      my @lines = split "\n", substr($_, 0, pos);
      $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
    }
  
    die "$context\n";
  }
  
  # Emulate boolean type
  package JSON::Tiny::_Bool;
  use overload '""' => sub { ${$_[0]} }, fallback => 1;
  1;
JSON_TINY

$fatpacked{"autodie.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE';
  package autodie;
  use 5.008;
  use strict;
  use warnings;
  
  use parent qw(Fatal);
  our $VERSION;
  
  # ABSTRACT: Replace functions with ones that succeed or die with lexical scope
  
  BEGIN {
      our $VERSION = '2.29'; # VERSION: Generated by DZP::OurPkg::Version
  }
  
  use constant ERROR_WRONG_FATAL => q{
  Incorrect version of Fatal.pm loaded by autodie.
  
  The autodie pragma uses an updated version of Fatal to do its
  heavy lifting.  We seem to have loaded Fatal version %s, which is
  probably the version that came with your version of Perl.  However
  autodie needs version %s, which would have come bundled with
  autodie.
  
  You may be able to solve this problem by adding the following
  line of code to your main program, before any use of Fatal or
  autodie.
  
      use lib "%s";
  
  };
  
  # We have to check we've got the right version of Fatal before we
  # try to compile the rest of our code, lest we use a constant
  # that doesn't exist.
  
  BEGIN {
  
      # If we have the wrong Fatal, then we've probably loaded the system
      # one, not our own.  Complain, and give a useful hint. ;)
  
      if (defined($Fatal::VERSION) and defined($VERSION) and $Fatal::VERSION ne $VERSION) {
          my $autodie_path = $INC{'autodie.pm'};
  
          $autodie_path =~ s/autodie\.pm//;
  
          require Carp;
  
          Carp::croak sprintf(
              ERROR_WRONG_FATAL, $Fatal::VERSION, $VERSION, $autodie_path
          );
      }
  }
  
  # When passing args to Fatal we want to keep the first arg
  # (our package) in place.  Hence the splice.
  
  sub import {
          splice(@_,1,0,Fatal::LEXICAL_TAG);
          goto &Fatal::import;
  }
  
  sub unimport {
          splice(@_,1,0,Fatal::LEXICAL_TAG);
          goto &Fatal::unimport;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie - Replace functions with ones that succeed or die with lexical scope
  
  =head1 SYNOPSIS
  
      use autodie;            # Recommended: implies 'use autodie qw(:default)'
  
      use autodie qw(:all);   # Recommended more: defaults and system/exec.
  
      use autodie qw(open close);   # open/close succeed or die
  
      open(my $fh, "<", $filename); # No need to check!
  
      {
          no autodie qw(open);          # open failures won't die
          open(my $fh, "<", $filename); # Could fail silently!
          no autodie;                   # disable all autodies
      }
      
      print "Hello World" or die $!;    # autodie DOESN'T check print!
  
  =head1 DESCRIPTION
  
          bIlujDI' yIchegh()Qo'; yIHegh()!
  
          It is better to die() than to return() in failure.
  
                  -- Klingon programming proverb.
  
  The C<autodie> pragma provides a convenient way to replace functions
  that normally return false on failure with equivalents that throw
  an exception on failure.
  
  The C<autodie> pragma has I<lexical scope>, meaning that functions
  and subroutines altered with C<autodie> will only change their behaviour
  until the end of the enclosing block, file, or C<eval>.
  
  If C<system> is specified as an argument to C<autodie>, then it
  uses L<IPC::System::Simple> to do the heavy lifting.  See the
  description of that module for more information.
  
  =head1 EXCEPTIONS
  
  Exceptions produced by the C<autodie> pragma are members of the
  L<autodie::exception> class.  The preferred way to work with
  these exceptions under Perl 5.10 is as follows:
  
      use feature qw(switch);
  
      eval {
          use autodie;
  
          open(my $fh, '<', $some_file);
  
          my @records = <$fh>;
  
          # Do things with @records...
  
          close($fh);
  
      };
  
      given ($@) {
          when (undef)   { say "No error";                    }
          when ('open')  { say "Error from open";             }
          when (':io')   { say "Non-open, IO error.";         }
          when (':all')  { say "All other autodie errors."    }
          default        { say "Not an autodie error at all." }
      }
  
  Under Perl 5.8, the C<given/when> structure is not available, so the
  following structure may be used:
  
      eval {
          use autodie;
  
          open(my $fh, '<', $some_file);
  
          my @records = <$fh>;
  
          # Do things with @records...
  
          close($fh);
      };
  
      if ($@ and $@->isa('autodie::exception')) {
          if ($@->matches('open')) { print "Error from open\n";   }
          if ($@->matches(':io' )) { print "Non-open, IO error."; }
      } elsif ($@) {
          # A non-autodie exception.
      }
  
  See L<autodie::exception> for further information on interrogating
  exceptions.
  
  =head1 CATEGORIES
  
  Autodie uses a simple set of categories to group together similar
  built-ins.  Requesting a category type (starting with a colon) will
  enable autodie for all built-ins beneath that category.  For example,
  requesting C<:file> will enable autodie for C<close>, C<fcntl>,
  C<open> and C<sysopen>.
  
  The categories are currently:
  
      :all
          :default
              :io
                  read
                  seek
                  sysread
                  sysseek
                  syswrite
                  :dbm
                      dbmclose
                      dbmopen
                  :file
                      binmode
                      close
                      chmod
                      chown
                      fcntl
                      flock
                      ioctl
                      open
                      sysopen
                      truncate
                  :filesys
                      chdir
                      closedir
                      opendir
                      link
                      mkdir
                      readlink
                      rename
                      rmdir
                      symlink
                      unlink
                  :ipc
                      kill
                      pipe
                      :msg
                          msgctl
                          msgget
                          msgrcv
                          msgsnd
                      :semaphore
                          semctl
                          semget
                          semop
                      :shm
                          shmctl
                          shmget
                          shmread
                  :socket
                      accept
                      bind
                      connect
                      getsockopt
                      listen
                      recv
                      send
                      setsockopt
                      shutdown
                      socketpair
              :threads
                  fork
          :system
              system
              exec
  
  
  Note that while the above category system is presently a strict
  hierarchy, this should not be assumed.
  
  A plain C<use autodie> implies C<use autodie qw(:default)>.  Note that
  C<system> and C<exec> are not enabled by default.  C<system> requires
  the optional L<IPC::System::Simple> module to be installed, and enabling
  C<system> or C<exec> will invalidate their exotic forms.  See L</BUGS>
  below for more details.
  
  The syntax:
  
      use autodie qw(:1.994);
  
  allows the C<:default> list from a particular version to be used.  This
  provides the convenience of using the default methods, but the surety
  that no behavioral changes will occur if the C<autodie> module is
  upgraded.
  
  C<autodie> can be enabled for all of Perl's built-ins, including
  C<system> and C<exec> with:
  
      use autodie qw(:all);
  
  =head1 FUNCTION SPECIFIC NOTES
  
  =head2 print
  
  The autodie pragma B<<does not check calls to C<print>>>.
  
  =head2 flock
  
  It is not considered an error for C<flock> to return false if it fails
  due to an C<EWOULDBLOCK> (or equivalent) condition.  This means one can
  still use the common convention of testing the return value of
  C<flock> when called with the C<LOCK_NB> option:
  
      use autodie;
  
      if ( flock($fh, LOCK_EX | LOCK_NB) ) {
          # We have a lock
      }
  
  Autodying C<flock> will generate an exception if C<flock> returns
  false with any other error.
  
  =head2 system/exec
  
  The C<system> built-in is considered to have failed in the following
  circumstances:
  
  =over 4
  
  =item *
  
  The command does not start.
  
  =item *
  
  The command is killed by a signal.
  
  =item *
  
  The command returns a non-zero exit value (but see below).
  
  =back
  
  On success, the autodying form of C<system> returns the I<exit value>
  rather than the contents of C<$?>.
  
  Additional allowable exit values can be supplied as an optional first
  argument to autodying C<system>:
  
      system( [ 0, 1, 2 ], $cmd, @args);  # 0,1,2 are good exit values
  
  C<autodie> uses the L<IPC::System::Simple> module to change C<system>.
  See its documentation for further information.
  
  Applying C<autodie> to C<system> or C<exec> causes the exotic
  forms C<system { $cmd } @args > or C<exec { $cmd } @args>
  to be considered a syntax error until the end of the lexical scope.
  If you really need to use the exotic form, you can call C<CORE::system>
  or C<CORE::exec> instead, or use C<no autodie qw(system exec)> before
  calling the exotic form.
  
  =head1 GOTCHAS
  
  Functions called in list context are assumed to have failed if they
  return an empty list, or a list consisting only of a single undef
  element.
  
  Some builtins (e.g. C<chdir> or C<truncate>) has a call signature that
  cannot completely be representated with a Perl prototype.  This means
  that some valid Perl code will be invalid under autodie.  As an example:
  
    chdir(BAREWORD);
  
  Without autodie (and assuming BAREWORD is an open
  filehandle/dirhandle) this is a valid call to chdir.  But under
  autodie, C<chdir> will behave like it had the prototype ";$" and thus
  BAREWORD will be a syntax error (under "use strict".  Without strict, it
  will interpreted as a filename).
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item :void cannot be used with lexical scope
  
  The C<:void> option is supported in L<Fatal>, but not
  C<autodie>.  To workaround this, C<autodie> may be explicitly disabled until
  the end of the current block with C<no autodie>.
  To disable autodie for only a single function (eg, open)
  use C<no autodie qw(open)>.
  
  C<autodie> performs no checking of called context to determine whether to throw
  an exception; the explicitness of error handling with C<autodie> is a deliberate
  feature.
  
  =item No user hints defined for %s
  
  You've insisted on hints for user-subroutines, either by pre-pending
  a C<!> to the subroutine name itself, or earlier in the list of arguments
  to C<autodie>.  However the subroutine in question does not have
  any hints available.
  
  =back
  
  See also L<Fatal/DIAGNOSTICS>.
  
  =head1 BUGS
  
  "Used only once" warnings can be generated when C<autodie> or C<Fatal>
  is used with package filehandles (eg, C<FILE>).  Scalar filehandles are
  strongly recommended instead.
  
  When using C<autodie> or C<Fatal> with user subroutines, the
  declaration of those subroutines must appear before the first use of
  C<Fatal> or C<autodie>, or have been exported from a module.
  Attempting to use C<Fatal> or C<autodie> on other user subroutines will
  result in a compile-time error.
  
  Due to a bug in Perl, C<autodie> may "lose" any format which has the
  same name as an autodying built-in or function.
  
  C<autodie> may not work correctly if used inside a file with a
  name that looks like a string eval, such as F<eval (3)>.
  
  =head2 autodie and string eval
  
  Due to the current implementation of C<autodie>, unexpected results
  may be seen when used near or with the string version of eval.
  I<None of these bugs exist when using block eval>.
  
  Under Perl 5.8 only, C<autodie> I<does not> propagate into string C<eval>
  statements, although it can be explicitly enabled inside a string
  C<eval>.
  
  Under Perl 5.10 only, using a string eval when C<autodie> is in
  effect can cause the autodie behaviour to leak into the surrounding
  scope.  This can be worked around by using a C<no autodie> at the
  end of the scope to explicitly remove autodie's effects, or by
  avoiding the use of string eval.
  
  I<None of these bugs exist when using block eval>.  The use of
  C<autodie> with block eval is considered good practice.
  
  =head2 REPORTING BUGS
  
  Please report bugs via the GitHub Issue Tracker at
  L<https://github.com/pjf/autodie/issues> or via the CPAN Request
  Tracker at L<https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie>.
  
  =head1 FEEDBACK
  
  If you find this module useful, please consider rating it on the
  CPAN Ratings service at
  L<http://cpanratings.perl.org/rate?distribution=autodie> .
  
  The module author loves to hear how C<autodie> has made your life
  better (or worse).  Feedback can be sent to
  E<lt>pjf@perltraining.com.auE<gt>.
  
  =head1 AUTHOR
  
  Copyright 2008-2009, Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Fatal>, L<autodie::exception>, L<autodie::hints>, L<IPC::System::Simple>
  
  I<Perl tips, autodie> at
  L<http://perltraining.com.au/tips/2008-08-20.html>
  
  =head1 ACKNOWLEDGEMENTS
  
  Mark Reed and Roland Giersig -- Klingon translators.
  
  See the F<AUTHORS> file for full credits.  The latest version of this
  file can be found at
  L<https://github.com/pjf/autodie/tree/master/AUTHORS> .
  
  =cut
AUTODIE

$fatpacked{"autodie/Scope/Guard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_SCOPE_GUARD';
  package autodie::Scope::Guard;
  
  use strict;
  use warnings;
  
  # ABSTRACT: Wrapper class for calling subs at end of scope
  our $VERSION = '2.29'; # VERSION
  
  # This code schedules the cleanup of subroutines at the end of
  # scope.  It's directly inspired by chocolateboy's excellent
  # Scope::Guard module.
  
  sub new {
      my ($class, $handler) = @_;
      return bless($handler, $class);
  }
  
  sub DESTROY {
      my ($self) = @_;
  
      $self->();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie::Scope::Guard - Wrapper class for calling subs at end of scope
  
  =head1 SYNOPSIS
  
      use autodie::Scope::Guard;
      $^H{'my-key'} = autodie::Scope::Guard->new(sub {
          print "Hallo world\n";
      });
  
  =head1 DESCRIPTION
  
  This class is used to bless perl subs so that they are invoked when
  they are destroyed.  This is mostly useful for ensuring the code is
  invoked at end of scope.  This module is not a part of autodie's
  public API.
  
  This module is directly inspired by chocolateboy's excellent
  Scope::Guard module.
  
  =head2 Methods
  
  =head3 new
  
    my $hook = autodie::Scope::Guard->new(sub {});
  
  Creates a new C<autodie::Scope::Guard>, which will invoke the given
  sub once it goes out of scope (i.e. its DESTROY handler is called).
  
  =head1 AUTHOR
  
  Copyright 2008-2009, Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
AUTODIE_SCOPE_GUARD

$fatpacked{"autodie/Scope/GuardStack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_SCOPE_GUARDSTACK';
  package autodie::Scope::GuardStack;
  
  use strict;
  use warnings;
  
  use autodie::Scope::Guard;
  
  # ABSTRACT: Hook stack for managing scopes via %^H
  our $VERSION = '2.29'; # VERSION
  
  my $H_KEY_STEM = __PACKAGE__ . '/guard';
  my $COUNTER = 0;
  
  # This code schedules the cleanup of subroutines at the end of
  # scope.  It's directly inspired by chocolateboy's excellent
  # Scope::Guard module.
  
  sub new {
      my ($class) = @_;
  
      return bless([], $class);
  }
  
  sub push_hook {
      my ($self, $hook) = @_;
      my $h_key = $H_KEY_STEM . ($COUNTER++);
      my $size = @{$self};
      $^H{$h_key} = autodie::Scope::Guard->new(sub {
          # Pop the stack until we reach the right size
          # - this may seem weird, but it is to avoid relying
          #   on "destruction order" of keys in %^H.
          #
          # Example:
          #  {
          #     use autodie;  # hook 1
          #     no autodie;   # hook 2
          #     use autodie;  # hook 3
          #  }
          #
          #  Here we want call hook 3, then hook 2 and finally hook 1.
          #  Any other order could have undesired consequences.
          #
          #  Suppose hook 2 is destroyed first, it will pop hook 3 and
          #  then hook 2.  hook 3 will then be destroyed, but do nothing
          #  since its "frame" was already popped and finally hook 1
          #  will be popped and take its own frame with it.
          #
          #  We need to check that $self still exists since things can get weird
          #  during global destruction.
          $self->_pop_hook while $self && @{$self} > $size;
      });
      push(@{$self}, [$hook, $h_key]);
      return;
  }
  
  sub _pop_hook {
      my ($self) = @_;
      my ($hook, $key) = @{ pop(@{$self}) };
      my $ref = delete($^H{$key});
      $hook->();
      return;
  }
  
  sub DESTROY {
      my ($self) = @_;
  
      # To be honest, I suspect @{$self} will always be empty here due
      # to the subs in %^H having references to the stack (which would
      # keep the stack alive until those have been destroyed).  Anyhow,
      # it never hurt to be careful.
      $self->_pop_hook while @{$self};
      return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie::Scope::GuardStack -  Hook stack for managing scopes via %^H
  
  =head1 SYNOPSIS
  
      use autodie::Scope::GuardStack;
      my $stack = autodie::Scope::GuardStack->new
      $^H{'my-key'} = $stack;
  
      $stack->push_hook(sub {});
  
  =head1 DESCRIPTION
  
  This class is a stack of hooks to be called in the right order as
  scopes go away.  The stack is only useful when inserted into C<%^H>
  and will pop hooks as their "scope" is popped.  This is useful for
  uninstalling or reinstalling subs in a namespace as a pragma goes
  out of scope.
  
  Due to how C<%^H> works, this class is only useful during the
  compilation phase of a perl module and relies on the internals of how
  perl handles references in C<%^H>.  This module is not a part of
  autodie's public API.
  
  =head2 Methods
  
  =head3 new
  
    my $stack = autodie::Scope::GuardStack->new;
  
  Creates a new C<autodie::Scope::GuardStack>.  The stack is initially
  empty and must be inserted into C<%^H> by the creator.
  
  =head3 push_hook
  
    $stack->push_hook(sub {});
  
  Add a sub to the stack.  The sub will be called once the current
  compile-time "scope" is left.  Multiple hooks can be added per scope
  
  =head1 AUTHOR
  
  Copyright 2013, Niels Thykier E<lt>niels@thykier.netE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
AUTODIE_SCOPE_GUARDSTACK

$fatpacked{"autodie/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_UTIL';
  package autodie::Util;
  
  use strict;
  use warnings;
  
  use Exporter 5.57 qw(import);
  
  use autodie::Scope::GuardStack;
  
  our @EXPORT_OK = qw(
    fill_protos
    install_subs
    make_core_trampoline
    on_end_of_compile_scope
  );
  
  our $VERSION = '2.29'; # VERSION: Generated by DZP::OurPkg:Version
  
  # ABSTRACT: Internal Utility subroutines for autodie and Fatal
  
  # docs says we should pick __PACKAGE__ /<whatever>
  my $H_STACK_KEY = __PACKAGE__ . '/stack';
  
  sub on_end_of_compile_scope {
      my ($hook) = @_;
  
      # Dark magic to have autodie work under 5.8
      # Copied from namespace::clean, that copied it from
      # autobox, that found it on an ancient scroll written
      # in blood.
  
      # This magic bit causes %^H to be lexically scoped.
      $^H |= 0x020000;
  
      my $stack = $^H{$H_STACK_KEY};
      if (not defined($stack)) {
          $stack = autodie::Scope::GuardStack->new;
          $^H{$H_STACK_KEY} = $stack;
      }
  
      $stack->push_hook($hook);
      return;
  }
  
  # This code is based on code from the original Fatal.  The "XXXX"
  # remark is from the original code and its meaning is (sadly) unknown.
  sub fill_protos {
      my ($proto) = @_;
      my ($n, $isref, @out, @out1, $seen_semi) = -1;
      if ($proto =~ m{^\s* (?: [;] \s*)? \@}x) {
          # prototype is entirely slurply - special case that does not
          # require any handling.
          return ([0, '@_']);
      }
  
      while ($proto =~ /\S/) {
          $n++;
          push(@out1,[$n,@out]) if $seen_semi;
          push(@out, $1 . "{\$_[$n]}"), next if $proto =~ s/^\s*\\([\@%\$\&])//;
          push(@out, "\$_[$n]"),        next if $proto =~ s/^\s*([_*\$&])//;
          push(@out, "\@_[$n..\$#_]"),  last if $proto =~ s/^\s*(;\s*)?\@//;
          $seen_semi = 1, $n--,         next if $proto =~ s/^\s*;//; # XXXX ????
          die "Internal error: Unknown prototype letters: \"$proto\"";
      }
      push(@out1,[$n+1,@out]);
      return @out1;
  }
  
  
  sub make_core_trampoline {
      my ($call, $pkg, $proto_str) = @_;
      my $trampoline_code = 'sub {';
      my $trampoline_sub;
      my @protos = fill_protos($proto_str);
  
      foreach my $proto (@protos) {
          local $" = ", ";    # So @args is formatted correctly.
          my ($count, @args) = @$proto;
          if (@args && $args[-1] =~ m/[@#]_/) {
              $trampoline_code .= qq/
                  if (\@_ >= $count) {
                      return $call(@args);
                  }
               /;
          } else {
              $trampoline_code .= qq<
                  if (\@_ == $count) {
                      return $call(@args);
                  }
               >;
          }
      }
  
      $trampoline_code .= qq< require Carp; Carp::croak("Internal error in Fatal/autodie.  Leak-guard failure"); } >;
      my $E;
  
      {
          local $@;
          $trampoline_sub = eval "package $pkg;\n $trampoline_code"; ## no critic
          $E = $@;
      }
      die "Internal error in Fatal/autodie: Leak-guard installation failure: $E"
          if $E;
  
      return $trampoline_sub;
  }
  
  # The code here is originally lifted from namespace::clean,
  # by Robert "phaylon" Sedlacek.
  #
  # It's been redesigned after feedback from ikegami on perlmonks.
  # See http://perlmonks.org/?node_id=693338 .  Ikegami rocks.
  #
  # Given a package, and hash of (subname => subref) pairs,
  # we install the given subroutines into the package.  If
  # a subref is undef, the subroutine is removed.  Otherwise
  # it replaces any existing subs which were already there.
  
  sub install_subs {
      my ($target_pkg, $subs_to_reinstate) = @_;
  
      my $pkg_sym = "${target_pkg}::";
  
      # It does not hurt to do this in a predictable order, and might help debugging.
      foreach my $sub_name (sort keys(%{$subs_to_reinstate})) {
  
          # We will repeatedly mess with stuff that strict "refs" does
          # not like.  So lets just disable it once for this entire
          # scope.
          no strict qw(refs);   ## no critic
  
          my $sub_ref = $subs_to_reinstate->{$sub_name};
  
          my $full_path = ${pkg_sym}.${sub_name};
          my $oldglob = *$full_path;
  
          # Nuke the old glob.
          delete($pkg_sym->{$sub_name});
  
          # For some reason this local *alias = *$full_path triggers an
          # "only used once" warning.  Not entirely sure why, but at
          # least it is easy to silence.
          no warnings qw(once);
          local *alias = *$full_path;
          use warnings qw(once);
  
          # Copy innocent bystanders back.  Note that we lose
          # formats; it seems that Perl versions up to 5.10.0
          # have a bug which causes copying formats to end up in
          # the scalar slot.  Thanks to Ben Morrow for spotting this.
  
          foreach my $slot (qw( SCALAR ARRAY HASH IO ) ) {
              next unless defined(*$oldglob{$slot});
              *alias = *$oldglob{$slot};
          }
  
          if ($sub_ref) {
              *$full_path = $sub_ref;
          }
      }
  
      return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie::Util - Internal Utility subroutines for autodie and Fatal
  
  =head1 SYNOPSIS
  
      # INTERNAL API for autodie and Fatal only!
  
      use autodie::Util qw(on_end_of_compile_scope);
      on_end_of_compile_scope(sub { print "Hallo world\n"; });
  
  =head1 DESCRIPTION
  
  Interal Utilities for autodie and Fatal!  This module is not a part of
  autodie's public API.
  
  This module contains utility subroutines for abstracting away the
  underlying magic of autodie and (ab)uses of C<%^H> to call subs at the
  end of a (compile-time) scopes.
  
  Note that due to how C<%^H> works, some of these utilities are only
  useful during the compilation phase of a perl module and relies on the
  internals of how perl handles references in C<%^H>.
  
  =head2 Methods
  
  =head3 on_end_of_compile_scope
  
    on_end_of_compile_scope(sub { print "Hallo world\n"; });
  
  Will invoke a sub at the end of a (compile-time) scope.  The sub is
  called once with no arguments.  Can be called multiple times (even in
  the same "compile-time" scope) to install multiple subs.  Subs are
  called in a "first-in-last-out"-order (FILO or "stack"-order).
  
  =head3 fill_protos
  
    fill_protos('*$$;$@')
  
  Given a Perl subroutine prototype, return a list of invocation
  specifications.  Each specification is a listref, where the first
  member is the (minimum) number of arguments for this invocation
  specification.  The remaining arguments are a string representation of
  how to pass the arguments correctly to a sub with the given prototype,
  when called with the given number of arguments.
  
  The specifications are returned in increasing order of arguments
  starting at 0 (e.g.  ';$') or 1 (e.g.  '$@').  Note that if the
  prototype is "slurpy" (e.g. ends with a "@"), the number of arguments
  for the last specification is a "minimum" number rather than an exact
  number.  This can be detected by the last member of the last
  specification matching m/[@#]_/.
  
  =head3 make_core_trampoline
  
    make_core_trampoline('CORE::open', 'main', prototype('CORE::open'))
  
  Creates a trampoline for calling a core sub.  Essentially, a tiny sub
  that figures out how we should be calling our core sub, puts in the
  arguments in the right way, and bounces our control over to it.
  
  If we could reliably use `goto &` on core builtins, we wouldn't need
  this subroutine.
  
  =head3 install_subs
  
    install_subs('My::Module', { 'read' => sub { die("Hallo\n"), ... }})
  
  Given a package name and a hashref mapping names to a subroutine
  reference (or C<undef>), this subroutine will install said subroutines
  on their given name in that module.  If a name mapes to C<undef>, any
  subroutine with that name in the target module will be remove
  (possibly "unshadowing" a CORE sub of same name).
  
  =head1 AUTHOR
  
  Copyright 2013-2014, Niels Thykier E<lt>niels@thykier.netE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
AUTODIE_UTIL

$fatpacked{"autodie/exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_EXCEPTION';
  package autodie::exception;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '2.29'; # VERSION: Generated by DZP::OurPkg:Version
  # ABSTRACT: Exceptions from autodying functions.
  
  our $DEBUG = 0;
  
  use overload
      q{""} => "stringify",
      # Overload smart-match only if we're using 5.10 or up
      ($] >= 5.010 ? ('~~'  => "matches") : ()),
      fallback => 1
  ;
  
  my $PACKAGE = __PACKAGE__;  # Useful to have a scalar for hash keys.
  
  =head1 NAME
  
  autodie::exception - Exceptions from autodying functions.
  
  =head1 SYNOPSIS
  
      eval {
          use autodie;
  
          open(my $fh, '<', 'some_file.txt');
  
          ...
      };
  
      if (my $E = $@) {
          say "Ooops!  ",$E->caller," had problems: $@";
      }
  
  
  =head1 DESCRIPTION
  
  When an L<autodie> enabled function fails, it generates an
  C<autodie::exception> object.  This can be interrogated to
  determine further information about the error that occurred.
  
  This document is broken into two sections; those methods that
  are most useful to the end-developer, and those methods for
  anyone wishing to subclass or get very familiar with
  C<autodie::exception>.
  
  =head2 Common Methods
  
  These methods are intended to be used in the everyday dealing
  of exceptions.
  
  The following assume that the error has been copied into
  a separate scalar:
  
      if ($E = $@) {
          ...
      }
  
  This is not required, but is recommended in case any code
  is called which may reset or alter C<$@>.
  
  =cut
  
  =head3 args
  
      my $array_ref = $E->args;
  
  Provides a reference to the arguments passed to the subroutine
  that died.
  
  =cut
  
  sub args        { return $_[0]->{$PACKAGE}{args}; }
  
  =head3 function
  
      my $sub = $E->function;
  
  The subroutine (including package) that threw the exception.
  
  =cut
  
  sub function   { return $_[0]->{$PACKAGE}{function};  }
  
  =head3 file
  
      my $file = $E->file;
  
  The file in which the error occurred (eg, C<myscript.pl> or
  C<MyTest.pm>).
  
  =cut
  
  sub file        { return $_[0]->{$PACKAGE}{file};  }
  
  =head3 package
  
      my $package = $E->package;
  
  The package from which the exceptional subroutine was called.
  
  =cut
  
  sub package     { return $_[0]->{$PACKAGE}{package}; }
  
  =head3 caller
  
      my $caller = $E->caller;
  
  The subroutine that I<called> the exceptional code.
  
  =cut
  
  sub caller      { return $_[0]->{$PACKAGE}{caller};  }
  
  =head3 line
  
      my $line = $E->line;
  
  The line in C<< $E->file >> where the exceptional code was called.
  
  =cut
  
  sub line        { return $_[0]->{$PACKAGE}{line};  }
  
  =head3 context
  
      my $context = $E->context;
  
  The context in which the subroutine was called by autodie; usually
  the same as the context in which you called the autodying subroutine.
  This can be 'list', 'scalar', or undefined (unknown).  It will never
  be 'void', as C<autodie> always captures the return value in one way
  or another.
  
  For some core functions that always return a scalar value regardless
  of their context (eg, C<chown>), this may be 'scalar', even if you
  used a list context.
  
  =cut
  
  # TODO: The comments above say this can be undefined. Is that actually
  # the case? (With 'system', perhaps?)
  
  sub context     { return $_[0]->{$PACKAGE}{context} }
  
  =head3 return
  
      my $return_value = $E->return;
  
  The value(s) returned by the failed subroutine.  When the subroutine
  was called in a list context, this will always be a reference to an
  array containing the results.  When the subroutine was called in
  a scalar context, this will be the actual scalar returned.
  
  =cut
  
  sub return      { return $_[0]->{$PACKAGE}{return} }
  
  =head3 errno
  
      my $errno = $E->errno;
  
  The value of C<$!> at the time when the exception occurred.
  
  B<NOTE>: This method will leave the main C<autodie::exception> class
  and become part of a role in the future.  You should only call
  C<errno> for exceptions where C<$!> would reasonably have been
  set on failure.
  
  =cut
  
  # TODO: Make errno part of a role.  It doesn't make sense for
  # everything.
  
  sub errno       { return $_[0]->{$PACKAGE}{errno}; }
  
  =head3 eval_error
  
      my $old_eval_error = $E->eval_error;
  
  The contents of C<$@> immediately after autodie triggered an
  exception.  This may be useful when dealing with modules such
  as L<Text::Balanced> that set (but do not throw) C<$@> on error.
  
  =cut
  
  sub eval_error { return $_[0]->{$PACKAGE}{eval_error}; }
  
  =head3 matches
  
      if ( $e->matches('open') ) { ... }
  
      if ( $e ~~ 'open' ) { ... }
  
  C<matches> is used to determine whether a
  given exception matches a particular role.  On Perl 5.10,
  using smart-match (C<~~>) with an C<autodie::exception> object
  will use C<matches> underneath.
  
  An exception is considered to match a string if:
  
  =over 4
  
  =item *
  
  For a string not starting with a colon, the string exactly matches the
  package and subroutine that threw the exception.  For example,
  C<MyModule::log>.  If the string does not contain a package name,
  C<CORE::> is assumed.
  
  =item *
  
  For a string that does start with a colon, if the subroutine
  throwing the exception I<does> that behaviour.  For example, the
  C<CORE::open> subroutine does C<:file>, C<:io> and C<:all>.
  
  See L<autodie/CATEGORIES> for further information.
  
  =back
  
  =cut
  
  {
      my (%cache);
  
      sub matches {
          my ($this, $that) = @_;
  
          # TODO - Handle references
          croak "UNIMPLEMENTED" if ref $that;
  
          my $sub = $this->function;
  
          if ($DEBUG) {
              my $sub2 = $this->function;
              warn "Smart-matching $that against $sub / $sub2\n";
          }
  
          # Direct subname match.
          return 1 if $that eq $sub;
          return 1 if $that !~ /:/ and "CORE::$that" eq $sub;
          return 0 if $that !~ /^:/;
  
          # Cached match / check tags.
          require Fatal;
  
          if (exists $cache{$sub}{$that}) {
              return $cache{$sub}{$that};
          }
  
          # This rather awful looking line checks to see if our sub is in the
          # list of expanded tags, caches it, and returns the result.
  
          return $cache{$sub}{$that} = grep { $_ eq $sub } @{ $this->_expand_tag($that) };
      }
  }
  
  # This exists primarily so that child classes can override or
  # augment it if they wish.
  
  sub _expand_tag {
      my ($this, @args) = @_;
  
      return Fatal->_expand_tag(@args);
  }
  
  =head2 Advanced methods
  
  The following methods, while usable from anywhere, are primarily
  intended for developers wishing to subclass C<autodie::exception>,
  write code that registers custom error messages, or otherwise
  work closely with the C<autodie::exception> model.
  
  =cut
  
  # The table below records customer formatters.
  # TODO - Should this be a package var instead?
  # TODO - Should these be in a completely different file, or
  #        perhaps loaded on demand?  Most formatters will never
  #        get used in most programs.
  
  my %formatter_of = (
      'CORE::close'    => \&_format_close,
      'CORE::open'     => \&_format_open,
      'CORE::dbmopen'  => \&_format_dbmopen,
      'CORE::flock'    => \&_format_flock,
      'CORE::read'     => \&_format_readwrite,
      'CORE::sysread'  => \&_format_readwrite,
      'CORE::syswrite' => \&_format_readwrite,
      'CORE::chmod'    => \&_format_chmod,
      'CORE::mkdir'    => \&_format_mkdir,
  );
  
  sub _beautify_arguments {
      shift @_;
  
      # Walk through all our arguments, and...
      #
      #   * Replace undef with the word 'undef'
      #   * Replace globs with the string '$fh'
      #   * Quote all other args.
      foreach my $arg (@_) {
         if    (not defined($arg))   { $arg = 'undef' }
         elsif (ref($arg) eq "GLOB") { $arg = '$fh'   }
         else                        { $arg = qq{'$arg'} }
      }
  
      return @_;
  }
  
  sub _trim_package_name {
      # Info: The following is done since 05/2008 (which is before v1.10)
  
      # TODO: This is probably a good idea for CORE, is it
      # a good idea for other subs?
  
      # Trim package name off dying sub for error messages
      (my $name = $_[1]) =~ s/.*:://;
      return $name;
  }
  
  # Returns the parameter formatted as octal number
  sub _octalize_number {
      my $number = $_[1];
  
      # Only reformat if it looks like a whole number
      if ($number =~ /^\d+$/) {
          $number = sprintf("%#04lo", $number);
      }
  
      return $number;
  }
  
  # TODO: Our tests only check LOCK_EX | LOCK_NB is properly
  # formatted.  Try other combinations and ensure they work
  # correctly.
  
  sub _format_flock {
      my ($this) = @_;
  
      require Fcntl;
  
      my $filehandle = $this->args->[0];
      my $raw_mode   = $this->args->[1];
  
      my $mode_type;
      my $lock_unlock;
  
      if ($raw_mode & Fcntl::LOCK_EX() ) {
          $lock_unlock = "lock";
          $mode_type = "for exclusive access";
      }
      elsif ($raw_mode & Fcntl::LOCK_SH() ) {
          $lock_unlock = "lock";
          $mode_type = "for shared access";
      }
      elsif ($raw_mode & Fcntl::LOCK_UN() ) {
          $lock_unlock = "unlock";
          $mode_type = "";
      }
      else {
          # I've got no idea what they're trying to do.
          $lock_unlock = "lock";
          $mode_type = "with mode $raw_mode";
      }
  
      my $cooked_filehandle;
  
      if ($filehandle and not ref $filehandle) {
  
          # A package filehandle with a name!
  
          $cooked_filehandle = " $filehandle";
      }
      else {
          # Otherwise we have a scalar filehandle.
  
          $cooked_filehandle = '';
  
      }
  
      local $! = $this->errno;
  
      return "Can't $lock_unlock filehandle$cooked_filehandle $mode_type: $!";
  
  }
  
  # Default formatter for CORE::chmod
  sub _format_chmod {
      my ($this) = @_;
      my @args   = @{$this->args};
  
      my $mode   = shift @args;
      local $!   = $this->errno;
  
      $mode = $this->_octalize_number($mode);
  
      @args = $this->_beautify_arguments(@args);
  
      return "Can't chmod($mode, ". join(q{, }, @args) ."): $!";
  }
  
  # Default formatter for CORE::mkdir
  sub _format_mkdir {
      my ($this) = @_;
      my @args   = @{$this->args};
  
      # If no mask is specified use default formatter
      if (@args < 2) {
        return $this->format_default;
      }
  
      my $file = $args[0];
      my $mask = $args[1];
      local $! = $this->errno;
  
      $mask = $this->_octalize_number($mask);
  
      return "Can't mkdir('$file', $mask): '$!'";
  }
  
  # Default formatter for CORE::dbmopen
  sub _format_dbmopen {
      my ($this) = @_;
      my @args   = @{$this->args};
  
      # TODO: Presently, $args flattens out the (usually empty) hash
      # which is passed as the first argument to dbmopen.  This is
      # a bug in our args handling code (taking a reference to it would
      # be better), but for the moment we'll just examine the end of
      # our arguments list for message formatting.
  
      my $mode = $args[-1];
      my $file = $args[-2];
  
      $mode = $this->_octalize_number($mode);
  
      local $! = $this->errno;
  
      return "Can't dbmopen(%hash, '$file', $mode): '$!'";
  }
  
  # Default formatter for CORE::close
  
  sub _format_close {
      my ($this) = @_;
      my $close_arg = $this->args->[0];
  
      local $! = $this->errno;
  
      # If we've got an old-style filehandle, mention it.
      if ($close_arg and not ref $close_arg) {
          return "Can't close filehandle '$close_arg': '$!'";
      }
  
      # TODO - This will probably produce an ugly error.  Test and fix.
      return "Can't close($close_arg) filehandle: '$!'";
  
  }
  
  # Default formatter for CORE::read, CORE::sysread and CORE::syswrite
  #
  # Similar to default formatter with the buffer filtered out as it
  # may contain binary data.
  sub _format_readwrite {
      my ($this) = @_;
      my $call = $this->_trim_package_name($this->function);
      local $! = $this->errno;
  
      # These subs receive the following arguments (in order):
      #
      # * FILEHANDLE
      # * SCALAR (buffer, we do not want to write this)
      # * LENGTH (optional for syswrite)
      # * OFFSET (optional for all)
      my (@args) = @{$this->args};
      my $arg_name = $args[1];
      if (defined($arg_name)) {
          if (ref($arg_name)) {
              my $name = blessed($arg_name) || ref($arg_name);
              $arg_name = "<${name}>";
          } else {
              $arg_name = '<BUFFER>';
          }
      } else {
          $arg_name = '<UNDEF>';
      }
      $args[1] = $arg_name;
  
      return "Can't $call(" . join(q{, }, @args) . "): $!";
  }
  
  # Default formatter for CORE::open
  
  use constant _FORMAT_OPEN => "Can't open '%s' for %s: '%s'";
  
  sub _format_open_with_mode {
      my ($this, $mode, $file, $error) = @_;
  
      my $wordy_mode;
  
      if    ($mode eq '<')  { $wordy_mode = 'reading';   }
      elsif ($mode eq '>')  { $wordy_mode = 'writing';   }
      elsif ($mode eq '>>') { $wordy_mode = 'appending'; }
  
      $file = '<undef>' if not defined $file;
  
      return sprintf _FORMAT_OPEN, $file, $wordy_mode, $error if $wordy_mode;
  
      Carp::confess("Internal autodie::exception error: Don't know how to format mode '$mode'.");
  
  }
  
  sub _format_open {
      my ($this) = @_;
  
      my @open_args = @{$this->args};
  
      # Use the default formatter for single-arg and many-arg open
      if (@open_args <= 1 or @open_args >= 4) {
          return $this->format_default;
      }
  
      # For two arg open, we have to extract the mode
      if (@open_args == 2) {
          my ($fh, $file) = @open_args;
  
          if (ref($fh) eq "GLOB") {
              $fh = '$fh';
          }
  
          my ($mode) = $file =~ m{
              ^\s*                # Spaces before mode
              (
                  (?>             # Non-backtracking subexp.
                      <           # Reading
                      |>>?        # Writing/appending
                  )
              )
              [^&]                # Not an ampersand (which means a dup)
          }x;
  
          if (not $mode) {
              # Maybe it's a 2-arg open without any mode at all?
              # Detect the most simple case for this, where our
              # file consists only of word characters.
  
              if ( $file =~ m{^\s*\w+\s*$} ) {
                  $mode = '<'
              }
              else {
                  # Otherwise, we've got no idea what's going on.
                  # Use the default.
                  return $this->format_default;
              }
          }
  
          # Localising $! means perl makes it a pretty error for us.
          local $! = $this->errno;
  
          return $this->_format_open_with_mode($mode, $file, $!);
      }
  
      # Here we must be using three arg open.
  
      my $file = $open_args[2];
  
      local $! = $this->errno;
  
      my $mode = $open_args[1];
  
      local $@;
  
      my $msg = eval { $this->_format_open_with_mode($mode, $file, $!); };
  
      return $msg if $msg;
  
      # Default message (for pipes and odd things)
  
      return "Can't open '$file' with mode '$open_args[1]': '$!'";
  }
  
  =head3 register
  
      autodie::exception->register( 'CORE::open' => \&mysub );
  
  The C<register> method allows for the registration of a message
  handler for a given subroutine.  The full subroutine name including
  the package should be used.
  
  Registered message handlers will receive the C<autodie::exception>
  object as the first parameter.
  
  =cut
  
  sub register {
      my ($class, $symbol, $handler) = @_;
  
      croak "Incorrect call to autodie::register" if @_ != 3;
  
      $formatter_of{$symbol} = $handler;
  
  }
  
  =head3 add_file_and_line
  
      say "Problem occurred",$@->add_file_and_line;
  
  Returns the string C< at %s line %d>, where C<%s> is replaced with
  the filename, and C<%d> is replaced with the line number.
  
  Primarily intended for use by format handlers.
  
  =cut
  
  # Simply produces the file and line number; intended to be added
  # to the end of error messages.
  
  sub add_file_and_line {
      my ($this) = @_;
  
      return sprintf(" at %s line %d\n", $this->file, $this->line);
  }
  
  =head3 stringify
  
      say "The error was: ",$@->stringify;
  
  Formats the error as a human readable string.  Usually there's no
  reason to call this directly, as it is used automatically if an
  C<autodie::exception> object is ever used as a string.
  
  Child classes can override this method to change how they're
  stringified.
  
  =cut
  
  sub stringify {
      my ($this) = @_;
  
      my $call        =  $this->function;
      my $msg;
  
      if ($DEBUG) {
          my $dying_pkg   = $this->package;
          my $sub   = $this->function;
          my $caller = $this->caller;
          warn "Stringifing exception for $dying_pkg :: $sub / $caller / $call\n";
      }
  
      # TODO - This isn't using inheritance.  Should it?
      if ( my $sub = $formatter_of{$call} ) {
          $msg = $sub->($this) . $this->add_file_and_line;
      } else {
          $msg = $this->format_default . $this->add_file_and_line;
      }
      $msg .=  $this->{$PACKAGE}{_stack_trace}
          if $Carp::Verbose;
  
      return $msg;
  }
  
  =head3 format_default
  
      my $error_string = $E->format_default;
  
  This produces the default error string for the given exception,
  I<without using any registered message handlers>.  It is primarily
  intended to be called from a message handler when they have
  been passed an exception they don't want to format.
  
  Child classes can override this method to change how default
  messages are formatted.
  
  =cut
  
  # TODO: This produces ugly errors.  Is there any way we can
  # dig around to find the actual variable names?  I know perl 5.10
  # does some dark and terrible magicks to find them for undef warnings.
  
  sub format_default {
      my ($this) = @_;
  
      my $call   =  $this->_trim_package_name($this->function);
  
      local $! = $this->errno;
  
      my @args = @{ $this->args() };
      @args = $this->_beautify_arguments(@args);
  
      # Format our beautiful error.
  
      return "Can't $call(".  join(q{, }, @args) . "): $!" ;
  
      # TODO - Handle user-defined errors from hash.
  
      # TODO - Handle default error messages.
  
  }
  
  =head3 new
  
      my $error = autodie::exception->new(
          args => \@_,
          function => "CORE::open",
          errno => $!,
          context => 'scalar',
          return => undef,
      );
  
  
  Creates a new C<autodie::exception> object.  Normally called
  directly from an autodying function.  The C<function> argument
  is required, its the function we were trying to call that
  generated the exception.  The C<args> parameter is optional.
  
  The C<errno> value is optional.  In versions of C<autodie::exception>
  1.99 and earlier the code would try to automatically use the
  current value of C<$!>, but this was unreliable and is no longer
  supported.
  
  Atrributes such as package, file, and caller are determined
  automatically, and cannot be specified.
  
  =cut
  
  sub new {
      my ($class, @args) = @_;
  
      my $this = {};
  
      bless($this,$class);
  
      # I'd love to use EVERY here, but it causes our code to die
      # because it wants to stringify our objects before they're
      # initialised, causing everything to explode.
  
      $this->_init(@args);
  
      return $this;
  }
  
  sub _init {
  
      my ($this, %args) = @_;
  
      # Capturing errno here is not necessarily reliable.
      my $original_errno = $!;
  
      our $init_called = 1;
  
      my $class = ref $this;
  
      # We're going to walk up our call stack, looking for the
      # first thing that doesn't look like our exception
      # code, autodie/Fatal, or some whacky eval.
  
      my ($package, $file, $line, $sub);
  
      my $depth = 0;
  
      while (1) {
          $depth++;
  
          ($package, $file, $line, $sub) = CORE::caller($depth);
  
          # Skip up the call stack until we find something outside
          # of the Fatal/autodie/eval space.
  
          next if $package->isa('Fatal');
          next if $package->isa($class);
          next if $package->isa(__PACKAGE__);
  
          # Anything with the 'autodie::skip' role wants us to skip it.
          # https://github.com/pjf/autodie/issues/15
  
          next if ($package->can('DOES') and $package->DOES('autodie::skip'));
  
          next if $file =~ /^\(eval\s\d+\)$/;
  
          last;
  
      }
  
      # We now have everything correct, *except* for our subroutine
      # name.  If it's __ANON__ or (eval), then we need to keep on
      # digging deeper into our stack to find the real name.  However we
      # don't update our other information, since that will be correct
      # for our current exception.
  
      my $first_guess_subroutine = $sub;
  
      while (defined $sub and $sub =~ /^\(eval\)$|::__ANON__$/) {
          $depth++;
  
          $sub = (CORE::caller($depth))[3];
      }
  
      # If we end up falling out the bottom of our stack, then our
      # __ANON__ guess is the best we can get.  This includes situations
      # where we were called from the top level of a program.
  
      if (not defined $sub) {
          $sub = $first_guess_subroutine;
      }
  
      $this->{$PACKAGE}{package} = $package;
      $this->{$PACKAGE}{file}    = $file;
      $this->{$PACKAGE}{line}    = $line;
      $this->{$PACKAGE}{caller}  = $sub;
  
      # Tranks to %Carp::CarpInternal all Fatal, autodie and
      # autodie::exception stack frames are filtered already, but our
      # nameless wrapper is still present, so strip that.
  
      my $trace = Carp::longmess();
      $trace =~ s/^\s*at \(eval[^\n]+\n//;
  
      # And if we see an __ANON__, then we'll replace that with the actual
      # name of our autodying function.
  
      my $short_func = $args{function};
      $short_func =~ s/^CORE:://;
      $trace =~ s/(\s*[\w:]+)__ANON__/$1$short_func/;
  
      # And now we just fill in all our attributes.
  
      $this->{$PACKAGE}{_stack_trace} = $trace;
  
      $this->{$PACKAGE}{errno}   = $args{errno} || 0;
  
      $this->{$PACKAGE}{context} = $args{context};
      $this->{$PACKAGE}{return}  = $args{return};
      $this->{$PACKAGE}{eval_error}  = $args{eval_error};
  
      $this->{$PACKAGE}{args}    = $args{args} || [];
      $this->{$PACKAGE}{function}= $args{function} or
                croak("$class->new() called without function arg");
  
      return $this;
  
  }
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<autodie>, L<autodie::exception::system>
  
  =head1 LICENSE
  
  Copyright (C)2008 Paul Fenwick
  
  This is free software.  You may modify and/or redistribute this
  code under the same terms as Perl 5.10 itself, or, at your option,
  any later version of Perl 5.
  
  =head1 AUTHOR
  
  Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
AUTODIE_EXCEPTION

$fatpacked{"autodie/exception/system.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_EXCEPTION_SYSTEM';
  package autodie::exception::system;
  use 5.008;
  use strict;
  use warnings;
  use parent 'autodie::exception';
  use Carp qw(croak);
  
  our $VERSION = '2.29'; # VERSION: Generated by DZP::OurPkg:Version
  
  # ABSTRACT: Exceptions from autodying system().
  
  my $PACKAGE = __PACKAGE__;
  
  =head1 NAME
  
  autodie::exception::system - Exceptions from autodying system().
  
  =head1 SYNOPSIS
  
      eval {
          use autodie qw(system);
  
          system($cmd, @args);
  
      };
  
      if (my $E = $@) {
          say "Ooops!  ",$E->caller," had problems: $@";
      }
  
  
  =head1 DESCRIPTION
  
  This is a L<autodie::exception> class for failures from the
  C<system> command.
  
  Presently there is no way to interrogate an C<autodie::exception::system>
  object for the command, exit status, and other information you'd expect
  such an object to hold.  The interface will be expanded to accommodate
  this in the future.
  
  =cut
  
  sub _init {
      my ($this, %args) = @_;
  
      $this->{$PACKAGE}{message} = $args{message}
          || croak "'message' arg not supplied to autodie::exception::system->new";
  
      return $this->SUPER::_init(%args);
  
  }
  
  =head2 stringify
  
  When stringified, C<autodie::exception::system> objects currently
  use the message generated by L<IPC::System::Simple>.
  
  =cut
  
  sub stringify {
  
      my ($this) = @_;
  
      return $this->{$PACKAGE}{message} . $this->add_file_and_line;
  
  }
  
  1;
  
  __END__
  
  =head1 LICENSE
  
  Copyright (C)2008 Paul Fenwick
  
  This is free software.  You may modify and/or redistribute this
  code under the same terms as Perl 5.10 itself, or, at your option,
  any later version of Perl 5.
  
  =head1 AUTHOR
  
  Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
AUTODIE_EXCEPTION_SYSTEM

$fatpacked{"autodie/hints.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_HINTS';
  package autodie::hints;
  
  use strict;
  use warnings;
  
  use constant PERL58 => ( $] < 5.009 );
  
  our $VERSION = '2.29'; # VERSION: Generated by DZP::OurPkg:Version
  
  # ABSTRACT: Provide hints about user subroutines to autodie
  
  =head1 NAME
  
  autodie::hints - Provide hints about user subroutines to autodie
  
  =head1 SYNOPSIS
  
      package Your::Module;
  
      our %DOES = ( 'autodie::hints::provider' => 1 );
  
      sub AUTODIE_HINTS {
          return {
              foo => { scalar => HINTS, list => SOME_HINTS },
              bar => { scalar => HINTS, list => MORE_HINTS },
          }
      }
  
      # Later, in your main program...
  
      use Your::Module qw(foo bar);
      use autodie      qw(:default foo bar);
  
      foo();         # succeeds or dies based on scalar hints
  
      # Alternatively, hints can be set on subroutines we've
      # imported.
  
      use autodie::hints;
      use Some::Module qw(think_positive);
  
      BEGIN {
          autodie::hints->set_hints_for(
              \&think_positive,
              {
                  fail => sub { $_[0] <= 0 }
              }
          )
      }
      use autodie qw(think_positive);
  
      think_positive(...);    # Returns positive or dies.
  
  
  =head1 DESCRIPTION
  
  =head2 Introduction
  
  The L<autodie> pragma is very smart when it comes to working with
  Perl's built-in functions.  The behaviour for these functions are
  fixed, and C<autodie> knows exactly how they try to signal failure.
  
  But what about user-defined subroutines from modules?  If you use
  C<autodie> on a user-defined subroutine then it assumes the following
  behaviour to demonstrate failure:
  
  =over
  
  =item *
  
  A false value, in scalar context
  
  =item * 
  
  An empty list, in list context
  
  =item *
  
  A list containing a single undef, in list context
  
  =back
  
  All other return values (including the list of the single zero, and the
  list containing a single empty string) are considered successful.  However,
  real-world code isn't always that easy.  Perhaps the code you're working
  with returns a string containing the word "FAIL" upon failure, or a
  two element list containing C<(undef, "human error message")>.  To make
  autodie work with these sorts of subroutines, we have
  the I<hinting interface>.
  
  The hinting interface allows I<hints> to be provided to C<autodie>
  on how it should detect failure from user-defined subroutines.  While
  these I<can> be provided by the end-user of C<autodie>, they are ideally
  written into the module itself, or into a helper module or sub-class
  of C<autodie> itself.
  
  =head2 What are hints?
  
  A I<hint> is a subroutine or value that is checked against the
  return value of an autodying subroutine.  If the match returns true,
  C<autodie> considers the subroutine to have failed.
  
  If the hint provided is a subroutine, then C<autodie> will pass
  the complete return value to that subroutine.  If the hint is
  any other value, then C<autodie> will smart-match against the
  value provided.  In Perl 5.8.x there is no smart-match operator, and as such
  only subroutine hints are supported in these versions.
  
  Hints can be provided for both scalar and list contexts.  Note
  that an autodying subroutine will never see a void context, as
  C<autodie> always needs to capture the return value for examination.
  Autodying subroutines called in void context act as if they're called
  in a scalar context, but their return value is discarded after it
  has been checked.
  
  =head2 Example hints
  
  Hints may consist of scalars, array references, regular expressions and
  subroutine references.  You can specify different hints for how
  failure should be identified in scalar and list contexts.
  
  These examples apply for use in the C<AUTODIE_HINTS> subroutine and when
  calling C<autodie::hints->set_hints_for()>.
  
  The most common context-specific hints are:
  
          # Scalar failures always return undef:
              {  scalar => undef  }
  
          # Scalar failures return any false value [default expectation]:
              {  scalar => sub { ! $_[0] }  }
  
          # Scalar failures always return zero explicitly:
              {  scalar => '0'  }
  
          # List failures always return an empty list:
              {  list => []  }
  
          # List failures return () or (undef) [default expectation]:
              {  list => sub { ! @_ || @_ == 1 && !defined $_[0] }  }
  
          # List failures return () or a single false value:
              {  list => sub { ! @_ || @_ == 1 && !$_[0] }  }
  
          # List failures return (undef, "some string")
              {  list => sub { @_ == 2 && !defined $_[0] }  }
  
          # Unsuccessful foo() returns 'FAIL' or '_FAIL' in scalar context,
          #                    returns (-1) in list context...
          autodie::hints->set_hints_for(
              \&foo,
              {
                  scalar => qr/^ _? FAIL $/xms,
                  list   => [-1],
              }
          );
  
          # Unsuccessful foo() returns 0 in all contexts...
          autodie::hints->set_hints_for(
              \&foo,
              {
                  scalar => 0,
                  list   => [0],
              }
          );
  
  This "in all contexts" construction is very common, and can be
  abbreviated, using the 'fail' key.  This sets both the C<scalar>
  and C<list> hints to the same value:
  
          # Unsuccessful foo() returns 0 in all contexts...
          autodie::hints->set_hints_for(
              \&foo,
              {
                  fail => sub { @_ == 1 and defined $_[0] and $_[0] == 0 }
              }
  	);
  
          # Unsuccessful think_positive() returns negative number on failure...
          autodie::hints->set_hints_for(
              \&think_positive,
              {
                  fail => sub { $_[0] < 0 }
              }
  	);
  
          # Unsuccessful my_system() returns non-zero on failure...
          autodie::hints->set_hints_for(
              \&my_system,
              {
                  fail => sub { $_[0] != 0 }
              }
  	);
  
  =head1 Manually setting hints from within your program
  
  If you are using a module which returns something special on failure, then
  you can manually create hints for each of the desired subroutines.  Once
  the hints are specified, they are available for all files and modules loaded
  thereafter, thus you can move this work into a module and it will still
  work.
  
  	use Some::Module qw(foo bar);
  	use autodie::hints;
  
  	autodie::hints->set_hints_for(
  		\&foo,
  		{
  			scalar => SCALAR_HINT,
  			list   => LIST_HINT,
  		}
  	);
  	autodie::hints->set_hints_for(
  		\&bar,
                  { fail => SOME_HINT, }
  	);
  
  It is possible to pass either a subroutine reference (recommended) or a fully
  qualified subroutine name as the first argument.  This means you can set hints
  on modules that I<might> get loaded:
  
  	use autodie::hints;
  	autodie::hints->set_hints_for(
  		'Some::Module:bar', { fail => SCALAR_HINT, }
  	);
  
  This technique is most useful when you have a project that uses a
  lot of third-party modules.  You can define all your possible hints
  in one-place.  This can even be in a sub-class of autodie.  For
  example:
  
          package my::autodie;
  
          use parent qw(autodie);
          use autodie::hints;
  
          autodie::hints->set_hints_for(...);
  
          1;
  
  You can now C<use my::autodie>, which will work just like the standard
  C<autodie>, but is now aware of any hints that you've set.
  
  =head1 Adding hints to your module
  
  C<autodie> provides a passive interface to allow you to declare hints for
  your module.  These hints will be found and used by C<autodie> if it
  is loaded, but otherwise have no effect (or dependencies) without autodie.
  To set these, your module needs to declare that it I<does> the
  C<autodie::hints::provider> role.  This can be done by writing your
  own C<DOES> method, using a system such as C<Class::DOES> to handle
  the heavy-lifting for you, or declaring a C<%DOES> package variable
  with a C<autodie::hints::provider> key and a corresponding true value.
  
  Note that checking for a C<%DOES> hash is an C<autodie>-only
  short-cut.  Other modules do not use this mechanism for checking
  roles, although you can use the C<Class::DOES> module from the
  CPAN to allow it.
  
  In addition, you must define a C<AUTODIE_HINTS> subroutine that returns
  a hash-reference containing the hints for your subroutines:
  
          package Your::Module;
  
          # We can use the Class::DOES from the CPAN to declare adherence
          # to a role.
  
          use Class::DOES 'autodie::hints::provider' => 1;
  
          # Alternatively, we can declare the role in %DOES.  Note that
          # this is an autodie specific optimisation, although Class::DOES
          # can be used to promote this to a true role declaration.
  
          our %DOES = ( 'autodie::hints::provider' => 1 );
  
          # Finally, we must define the hints themselves.
  
  	sub AUTODIE_HINTS {
  	    return {
  	        foo => { scalar => HINTS, list => SOME_HINTS },
  	        bar => { scalar => HINTS, list => MORE_HINTS },
  	        baz => { fail => HINTS },
  	    }
  	}
  
  This allows your code to set hints without relying on C<autodie> and
  C<autodie::hints> being loaded, or even installed.  In this way your
  code can do the right thing when C<autodie> is installed, but does not
  need to depend upon it to function.
  
  =head1 Insisting on hints
  
  When a user-defined subroutine is wrapped by C<autodie>, it will
  use hints if they are available, and otherwise reverts to the
  I<default behaviour> described in the introduction of this document.
  This can be problematic if we expect a hint to exist, but (for
  whatever reason) it has not been loaded.
  
  We can ask autodie to I<insist> that a hint be used by prefixing
  an exclamation mark to the start of the subroutine name.  A lone
  exclamation mark indicates that I<all> subroutines after it must
  have hints declared.
  
  	# foo() and bar() must have their hints defined
  	use autodie qw( !foo !bar baz );
  
  	# Everything must have hints (recommended).
  	use autodie qw( ! foo bar baz );
  
  	# bar() and baz() must have their hints defined
  	use autodie qw( foo ! bar baz );
  
          # Enable autodie for all of Perl's supported built-ins,
          # as well as for foo(), bar() and baz().  Everything must
          # have hints.
          use autodie qw( ! :all foo bar baz );
  
  If hints are not available for the specified subroutines, this will cause a
  compile-time error.  Insisting on hints for Perl's built-in functions
  (eg, C<open> and C<close>) is always successful.
  
  Insisting on hints is I<strongly> recommended.
  
  =cut
  
  # TODO: implement regular expression hints
  
  use constant UNDEF_ONLY       => sub { not defined $_[0] };
  use constant EMPTY_OR_UNDEF   => sub {
      ! @_ or
      @_==1 && !defined $_[0]
  };
  
  use constant EMPTY_ONLY     => sub { @_ == 0 };
  use constant EMPTY_OR_FALSE => sub {
      ! @_ or
      @_==1 && !$_[0]
  };
  
  use constant SINGLE_TRUE => sub { @_ == 1 and not $_[0] };
  
  use constant DEFAULT_HINTS => {
      scalar => UNDEF_ONLY,
      list   => EMPTY_OR_UNDEF,
  };
  
  
  use constant HINTS_PROVIDER => 'autodie::hints::provider';
  
  our $DEBUG = 0;
  
  # Only ( undef ) is a strange but possible situation for very
  # badly written code.  It's not supported yet.
  
  my %Hints = (
      'File::Copy::copy' => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
      'File::Copy::move' => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
      'File::Copy::cp'   => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
      'File::Copy::mv'   => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
  );
  
  # Start by using Sub::Identify if it exists on this system.
  
  eval { require Sub::Identify; Sub::Identify->import('get_code_info'); };
  
  # If it doesn't exist, we'll define our own.  This code is directly
  # taken from Rafael Garcia's Sub::Identify 0.04, used under the same
  # license as Perl itself.
  
  if ($@) {
      require B;
  
      no warnings 'once';
  
      *get_code_info = sub ($) {
  
          my ($coderef) = @_;
          ref $coderef or return;
          my $cv = B::svref_2object($coderef);
          $cv->isa('B::CV') or return;
          # bail out if GV is undefined
          $cv->GV->isa('B::SPECIAL') and return;
  
          return ($cv->GV->STASH->NAME, $cv->GV->NAME);
      };
  
  }
  
  sub sub_fullname {
      return join( '::', get_code_info( $_[1] ) );
  }
  
  my %Hints_loaded = ();
  
  sub load_hints {
      my ($class, $sub) = @_;
  
      my ($package) = ( $sub =~ /(.*)::/ );
  
      if (not defined $package) {
          require Carp;
          Carp::croak(
              "Internal error in autodie::hints::load_hints - no package found.
          ");
      }
  
      # Do nothing if we've already tried to load hints for
      # this package.
      return if $Hints_loaded{$package}++;
  
      my $hints_available = 0;
  
      {
          no strict 'refs';   ## no critic
  
          if ($package->can('DOES') and $package->DOES(HINTS_PROVIDER) ) {
              $hints_available = 1;
          }
          elsif ( PERL58 and $package->isa(HINTS_PROVIDER) ) {
              $hints_available = 1;
          }
          elsif ( ${"${package}::DOES"}{HINTS_PROVIDER.""} ) {
              $hints_available = 1;
          }
      }
  
      return if not $hints_available;
  
      my %package_hints = %{ $package->AUTODIE_HINTS };
  
      foreach my $sub (keys %package_hints) {
  
          my $hint = $package_hints{$sub};
  
          # Ensure we have a package name.
          $sub = "${package}::$sub" if $sub !~ /::/;
  
          # TODO - Currently we don't check for conflicts, should we?
          $Hints{$sub} = $hint;
  
          $class->normalise_hints(\%Hints, $sub);
      }
  
      return;
  
  }
  
  sub normalise_hints {
      my ($class, $hints, $sub) = @_;
  
      if ( exists $hints->{$sub}->{fail} ) {
  
          if ( exists $hints->{$sub}->{scalar} or
               exists $hints->{$sub}->{list}
          ) {
              # TODO: Turn into a proper diagnostic.
              require Carp;
              local $Carp::CarpLevel = 1;
              Carp::croak("fail hints cannot be provided with either scalar or list hints for $sub");
          }
  
          # Set our scalar and list hints.
  
          $hints->{$sub}->{scalar} = 
          $hints->{$sub}->{list} = delete $hints->{$sub}->{fail};
  
          return;
  
      }
  
      # Check to make sure all our hints exist.
  
      foreach my $hint (qw(scalar list)) {
          if ( not exists $hints->{$sub}->{$hint} ) {
              # TODO: Turn into a proper diagnostic.
              require Carp;
              local $Carp::CarpLevel = 1;
              Carp::croak("$hint hint missing for $sub");
          }
      }
  
      return;
  }
  
  sub get_hints_for {
      my ($class, $sub) = @_;
  
      my $subname = $class->sub_fullname( $sub );
  
      # If we have hints loaded for a sub, then return them.
  
      if ( exists $Hints{ $subname } ) {
          return $Hints{ $subname };
      }
  
      # If not, we try to load them...
  
      $class->load_hints( $subname );
  
      # ...and try again!
  
      if ( exists $Hints{ $subname } ) {
          return $Hints{ $subname };
      }
  
      # It's the caller's responsibility to use defaults if desired.
      # This allows on autodie to insist on hints if needed.
  
      return;
  
  }
  
  sub set_hints_for {
      my ($class, $sub, $hints) = @_;
  
      if (ref $sub) {
          $sub = $class->sub_fullname( $sub );
  
          require Carp;
  
          $sub or Carp::croak("Attempts to set_hints_for unidentifiable subroutine");
      }
  
      if ($DEBUG) {
          warn "autodie::hints: Setting $sub to hints: $hints\n";
      }
  
      $Hints{ $sub } = $hints;
  
      $class->normalise_hints(\%Hints, $sub);
  
      return;
  }
  
  1;
  
  __END__
  
  
  =head1 Diagnostics
  
  =over 4
  
  =item Attempts to set_hints_for unidentifiable subroutine
  
  You've called C<< autodie::hints->set_hints_for() >> using a subroutine
  reference, but that reference could not be resolved back to a
  subroutine name.  It may be an anonymous subroutine (which can't
  be made autodying), or may lack a name for other reasons.
  
  If you receive this error with a subroutine that has a real name,
  then you may have found a bug in autodie.  See L<autodie/BUGS>
  for how to report this.
  
  =item fail hints cannot be provided with either scalar or list hints for %s
  
  When defining hints, you can either supply both C<list> and
  C<scalar> keywords, I<or> you can provide a single C<fail> keyword.
  You can't mix and match them.
  
  =item %s hint missing for %s
  
  You've provided either a C<scalar> hint without supplying
  a C<list> hint, or vice-versa.  You I<must> supply both C<scalar>
  and C<list> hints, I<or> a single C<fail> hint.
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 
  
  =item *
  
  Dr Damian Conway for suggesting the hinting interface and providing the
  example usage.
  
  =item *
  
  Jacinta Richardson for translating much of my ideas into this
  documentation.
  
  =back
  
  =head1 AUTHOR
  
  Copyright 2009, Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<autodie>, L<Class::DOES>
  
  =for Pod::Coverage get_hints_for load_hints normalise_hints sub_fullname get_code_info
  
  =cut
AUTODIE_HINTS

$fatpacked{"autodie/skip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_SKIP';
  package autodie::skip;
  use strict;
  use warnings;
  
  our $VERSION = '2.29'; # VERSION
  
  # This package exists purely so people can inherit from it,
  # which isn't at all how roles are supposed to work, but it's
  # how people will use them anyway.
  
  if ($] < 5.010) {
      # Older Perls don't have a native ->DOES.  Let's provide a cheap
      # imitation here.
  
      *DOES = sub { return shift->isa(@_); };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie::skip - Skip a package when throwing autodie exceptions
  
  =head1 SYNPOSIS
  
      use parent qw(autodie::skip);
  
  =head1 DESCRIPTION
  
  This dummy class exists to signal that the class inheriting it should
  be skipped when reporting exceptions from autodie.  This is useful
  for utility classes like L<Path::Tiny> that wish to report the location
  of where they were called on failure.
  
  If your class has a better way of doing roles, then you should not
  load this class and instead simply say that your class I<DOES>
  C<autodie::skip> instead.
  
  =head1 AUTHOR
  
  Copyright 2013, Paul Fenwick <pjf@cpan.org>
  
  =head1 LICENSE
  
  This module is free software. You may distribute it under the same
  terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<autodie>, L<autodie::exception>
  
  =for Pod::Coverage DOES
  
  =cut
AUTODIE_SKIP

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;
  use strict;
  use vars qw($VERSION);
  $VERSION = '0.234';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          push @{"$inheritor\::ISA"}, @_;
      };
  };
  
  "All your base are belong to us"
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  L<base>
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafaël Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007-10 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

$fatpacked{"version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);
  
  $VERSION = 0.9917;
  $CLASS = 'version';
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  {
      local $SIG{'__DIE__'};
      eval "use version::vpp $VERSION"; # don't tempt fate
      die "$@" if ( $@ );
      push @ISA, "version::vpp";
      local $^W;
      *version::qv = \&version::vpp::qv;
      *version::declare = \&version::vpp::declare;
      *version::_VERSION = \&version::vpp::_VERSION;
      *version::vcmp = \&version::vpp::vcmp;
      *version::new = \&version::vpp::new;
      *version::numify = \&version::vpp::numify;
      *version::normal = \&version::vpp::normal;
      if ($] >= 5.009000) {
          no strict 'refs';
          *version::stringify = \&version::vpp::stringify;
          *{'version::(""'} = \&version::vpp::stringify;
          *{'version::(<=>'} = \&version::vpp::vcmp;
          *{'version::(cmp'} = \&version::vpp::vcmp;
          *version::parse = \&version::vpp::parse;
      }
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
          local $^W;
          *{$class.'::declare'} =  \&{$CLASS.'::declare'};
          *{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
          map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
          %args =
          (
              qv => 1,
              'UNIVERSAL::VERSION' => 1,
          );
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
          *{$callpkg.'::declare'} =
          sub {return $class->declare(shift) }
          unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
          *{$callpkg.'::qv'} =
          sub {return $class->qv(shift) }
          unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
          local $^W;
          *UNIVERSAL::VERSION
          = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
          *{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
          *{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
          unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
          *{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
          unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  
  1;
VERSION

$fatpacked{"version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  use vars qw($VERSION $CLASS $STRICT $LAX);
  
  $VERSION = 0.9917;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  my $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  my $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  my $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  my $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
VERSION_REGEX

$fatpacked{"version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_VPP';
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  use vars qw($VERSION $CLASS @ISA $LAX $STRICT $WARN_CATEGORY);
  $VERSION = 0.9917;
  $CLASS = 'version::vpp';
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
VERSION_VPP

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use v5.009;
use strict;
use warnings;

package VC3::Pilot;

use autodie;
use English qw/-mo_match_vars/;
use Getopt::Long qw/GetOptions/;

my $vc3_root       = $ENV{VC3_ROOT}       || "$ENV{PWD}/vc3-root";
my $vc3_distfiles  = $ENV{VC3_DISTFILES}  || "$ENV{PWD}/vc3-distfiles";
my $vc3_user_home  = $ENV{VC3_USER_HOME}  || "vc3-home";
my $vc3_repository = $ENV{VC3_REPOSITORY} || "http://download.virtualclusters.org/repository";

my %vc3_environment;

my @external_dependencies = qw/perl sh tail tar uname patch gcc g++ ld pkconfig make/;

# call main if running interactively
VC3::Pilot::main();

sub usage {
    my ($script_name) = @_;
    return <<EOF;
$script_name [options] [--database catalog] --require package [--require package]* [-- command-and-args]

    catalogs          defaults to ./vc3_catalog.json
    command-and-args  defaults to /bin/sh

    options are:
    --install <root>   Install with base <root>. 
                       Default is ${vc3_root}
    --home    <home>   Set \${HOME} to <root>/<home>.
                       Default is ${vc3_user_home}

    --distfiles  <dir> Directory to cache unbuilt packages locally.
                       Default is ${vc3_distfiles}
    --repository <url> Site to fetch packages if needed.
                       Default is ${vc3_repository}

    --make-jobs <n>    Concurrent make jobs.
                       Default is 2.
    --sh-on-error      On building error, run /bin/sh on the partially-built environment.

Examples:
    ${script_name} --require parrot 'parrot_run -p \$PARROT_HTTP_PROXY ls /cvmfs/atlas.cern.ch' 
    ${script_name} --require maker-example-ecoli-01
EOF

}

sub main {
    my $database     = 'vc3-catalog.json';
    my @requires     = ();

    my $print_help   = 0;
    my $make_jobs    = 2;
    my $sh_on_error  = 0;

    my $debug_modules_used = 0;

    # if the executable name does looks like "perl", we use $0, as it has the
    # name of the script. Otherwise, this is a static run, and we use the given
    # executable name.
    my $script_name = ${EXECUTABLE_NAME} =~ /perl/ ? $0 : ${EXECUTABLE_NAME};

    my $original_command = join(' ', $script_name, @ARGV);

    GetOptions(
        "help"        => \$print_help,

        "database=s"  => \$database,
        "require=s"   => \@requires, 

        "install=s"   => \$vc3_root, 
        "home"        => \$vc3_user_home,

        "distfiles=s"  => \$vc3_distfiles, 
        "repository=s" => \$vc3_repository, 

        "make-jobs=n" => \$make_jobs,
        "sh-on-error" => \$sh_on_error,

        # options for developing, not for runtime:
        "debug-modules-used" => \$debug_modules_used
    );

    if($print_help) {
        print usage($script_name);
        exit 0;
    }

    if($debug_modules_used) {
        print join("\n", sort { $a <=> $b } keys %INC), "\n";
        exit 0;
    }

    unless(@requires) {
        print "At least one --require option should be given.\n\n" . usage($script_name);
        exit 1;
    }

    # set defaults
    my @command_and_args = @ARGV;
    if(!@command_and_args) {
        @command_and_args = ('/bin/sh',);
    }

    # clean this!
    %ENV = ();
    $ENV{VC3_COMMAND_LINE} = File::Spec->rel2abs(join(" ", $original_command));
    $ENV{PATH}             = '/bin:/usr/bin';
    $ENV{MAKEFLAGS}        = "-j${make_jobs}";
    $ENV{TERM}             = 'linux';

    # clean this! set default path more cleanly (see also PATH above)
    # set to '2' so this paths come after the packages path (which are set to
    # 1)
    $vc3_environment{PATH}->{'/bin'}     = 2;
    $vc3_environment{PATH}->{'/usr/bin'} = 2;

    set_vc3_directories();

    # disable stdout buffering
    select(STDOUT); $OUTPUT_AUTOFLUSH = 1;

    my $bag = VC3::Bag->new($database, $sh_on_error, @requires);

    $bag->say("building phase done!");

    chdir "$vc3_root/$vc3_user_home";
    exec qq(@command_and_args);
}

sub set_vc3_directories {
    $vc3_root      = File::Spec->rel2abs("${vc3_root}");
    $vc3_distfiles = File::Spec->rel2abs("${vc3_distfiles}");

    my $home    = "$vc3_root/$vc3_user_home";
    my $tmp_dir = "$vc3_root/tmp";

    File::Path::make_path($vc3_root);
    File::Path::make_path($vc3_distfiles);
    File::Path::make_path("$vc3_distfiles/manual-distribution");
    File::Path::make_path($home);
    File::Path::make_path($tmp_dir);

    $ENV{VC3_ROOT}      = $vc3_root;
    $ENV{VC3_DISTFILES} = $vc3_distfiles;
    $ENV{HOME}          = $home;
    $ENV{TMP}           = $tmp_dir;
}

package VC3::Bag; 

use Carp qw/carp croak/;
use English qw/-mo_match_vars/;
use File::Spec ();
use version ();
use POSIX ();

use JSON::Tiny;

sub new {
    my ($class, $catalog, $sh_on_error, @requires) = @_;

    my $self = bless {}, $class;
    $self->set_machine_vars();

    $self->{sources} = $self->decode_bag($catalog);
    $self->{indent_level} = 0;


    my $order = {};
    for my $req (@requires) {
        my $widget = $self->select_version($req);
        $widget->runtime_dependencies($order);
    }

    # list of all packages needed, from inner to outter.
    my @ordered_names = sort { $order->{$b} <=> $order->{$a} || $a cmp $b } keys %{$order};

    my $restricted_unmet = 0;
    for my $name (@ordered_names) {
        my $widget = $self->select_version($name);

        if($widget->check_manual_requirements()) {
            $restricted_unmet++;
        }
    }

    exit 1 if $restricted_unmet > 0;

    # do the actual bulding
    for my $req (@requires) {
        $self->set_environment($req, $sh_on_error);
    }

    return $self;
}

sub set_machine_vars {
    my ($self) = @_;

    ($self->{osname}, undef, undef, undef, $self->{architecture}) = POSIX::uname();

    $self->{target} = $self->architecture . '/' . $self->distribution;

    my $ldd_version_raw = qx(ldd --version);
    $ldd_version_raw =~ /
    # we are looking for a line starting with 'ldd'
    ^ldd
    # followed by anything
    .*
    # followed by at least one space
    \s+
    # followed by the version number (that we capture)
    ([0-9.]+)
    # followed by any number of spaces at the end of the line
    \s*$
    # options: x allows regexp comments. m treats each line indepedently
    /xm ;

    $self->{glibc_version} = $1
    || 'unknown';

    $ENV{VC3_MACHINE_OS}   = $self->osname;
    $ENV{VC3_MACHINE_ARCH} = $self->architecture;
    $ENV{VC3_MACHINE_GLIBC_VERSION} = $self->glibc_version;
}

sub target {
    my ($self) = @_;
    return $self->{target};
}

sub osname {
    my ($self) = @_;
    return $self->{osname};
}

sub architecture {
    my ($self) = @_;
    return $self->{architecture};
}

sub glibc_version {
    my ($self) = @_;
    return $self->{glibc_version};
}

# reads /etc/readhat-release and transforms something like:
# 'Red Hat Enterprise Linux Server release 6.5 (Santiago)'
# into 'redhat6'.
sub distribution {
    my ($self) = @_;

    my $distribution='generic';
    
    if (-f '/etc/redhat-release') {
        open (my $file_fh, '<', '/etc/redhat-release');
        my $redhat_version_line = <$file_fh>;

        $redhat_version_line =~ /\brelease\b\s+([0-9]+)\b/;
        my $redhat_version = $1;

        die 'Could not find redhat version!' unless $redhat_version;

        $distribution="redhat${redhat_version}"
    }
    
    return $distribution;
}

sub widget {
    my ($self, $widget_name) = @_;

    my $widget = $self->{sources}{$widget_name}
    || die "I do not know anything about '$widget_name' . \n";

    return $widget;
}

sub decode_bag {
    my ($self, $filename) = @_;
    open( my $catbag_f, '<:encoding(UTF-8)', $filename) ||
    die "Could not open '$filename': $!";

    my $contents = do { local($/); <$catbag_f> };
    close($catbag_f);

    my $bag_raw = JSON::Tiny::decode_json($contents);

    my $sources = {};
    
    for my $widget_name (keys %{$bag_raw}) {
        my @versions = map { VC3::Widget->new($self, $widget_name, $_) } @{$bag_raw->{$widget_name}};
        $sources->{$widget_name} = \@versions;
    }

    return $sources;
}

sub set_environment {
    my ($self, $widget_name, $sh_on_error, $min_version, $max_version) = @_;

    my $widget = $self->select_version($widget_name, $min_version, $max_version);

    $self->say("processing for $widget_name-" . $widget->version);

    # set root of this widget, in case dependencies need to refer to its parent.
    $ENV{$widget->var_root_name} = $widget->destination_dir;
    
    $self->set_dependencies($widget, $sh_on_error, $widget->dependencies);
    $widget->set_environment_variables();

    # check here missing, we are not checking anything here, only below at
    # sources!
    $self->say("checking for $widget_name-" . $widget->version);

    my $exit_status = 0;
    if($widget->sources) { 
        for my $source (@{$widget->sources}) {
            # save current environment so that we can rollback in case of error.
            my %old_ENV = %ENV;
            my %old_vc3_environment = %vc3_environment;


            # set dependencies particular to this source
            $self->set_dependencies($widget, $sh_on_error, $source->dependencies);
            eval {$exit_status = -1; $exit_status = $widget->execute_recipe($source);};

            if($exit_status) {
                # on error, reestablish old environment, and show last lines of log
                # file.
                
                $widget->process_error($sh_on_error, $EVAL_ERROR, $exit_status);

                %ENV = %old_ENV;
                my %vc3_environment = %old_vc3_environment;
            } else {
                # on success, we keep break out and do no try more recipes.
                last;
            }
        }
    }

    # last of the tries also failed, so we report failure for this widget.
    if($exit_status) {
        die "Could not set environment for '" . $widget->name . "' succesfully' . \n";
    }
}

sub set_dependencies {
    my ($self, $widget, $sh_on_error, $dependencies) = @_;

    my $namev = $widget->name . '-' . $widget->version; 

    $self->{indent_level}++;

    if($dependencies) {
        for my $dependency (keys %{$dependencies}) {
            my ($min_dep_ver, $max_dep_ver) = @{$dependencies->{$dependency}};

            $self->say("$namev needs $dependency");
            $self->set_environment($dependency, $sh_on_error, $min_dep_ver, $max_dep_ver);
        }
    }

    $self->{indent_level}--;
}

# versions available, min desired version, max desired version
sub select_version {
    my ($self, $widget_name, $min_version, $max_version) = @_;

    if($min_version) {
        $min_version = version->parse($min_version);
    }

    if($max_version) {
        $max_version = version->parse($max_version);
    }

    my $min_found;
    my $max_found;

    my $versions = $self->widget($widget_name);

    for my $widget (@{$versions}) {
        if(!$min_version) {
            return $widget;
        }

        my $version = version->parse($widget->{version});

        $min_found = $version unless $min_found;
        $max_found = $version unless $max_found;

        $min_found = $min_found lt $version ? $version : $min_found;
        $max_found = $max_found gt $version ? $version : $max_found;

        next if $min_version gt $version;

        if(!$max_version) {
            return $widget;
        }

        next if $max_version lt $version;
        return $widget;
    }

    $max_version = $min_version unless $max_version;
    die "I did not find a suitable version for '$widget_name'.\n Found: ["
    . version::normal($min_found)
    . ',' . version::normal($max_found)
    . ']. Wanted ['
    . $min_version->normal
    . ',' . $max_version->normal
    . "]\n";
}

sub expand_env_variable {
    my ($varvalue) = @_;

    $varvalue =~ s/\$\{(\w+)\}/env_variable_value($1)/eg;

    return $varvalue;
}

sub env_variable_value {
    my ($varname) = @_;

    my $value = $ENV{$varname}
    || die "Variable '$varname' has not been defined.";
}

sub say {
    my ($self, @rest) = @_;
    print(('.' x $self->{indent_level}), @rest, "\n");
}


package VC3::Widget;
use Carp;
use POSIX ":sys_wait_h";

# Attributes:
# name, version, sources, dependencies, environment_variables
sub new {
    my ($class, $bag, $name, $json_description) = @_;

    my $self = bless {}, $class;

    $self->bag($bag);
    $self->name($name);
    $self->version($json_description->{version});
    $self->sources($json_description->{sources});
    $self->dependencies($json_description->{dependencies});
    $self->environment_variables($json_description->{environment_variables});

    add_root_variable($self);

    return $self;
}

sub add_root_variable {
    my ($self) = @_;

    my $vars      = $self->environment_variables || [];

    my $root_name = 'VC3_' . uc($self->name) . '_ROOT';

    # replace - with _, as env vars cannot have - in their names.
    $root_name =~ s/-/_/g;

    my $root_var = {
        name     => $root_name,
        value    => $self->destination_dir,
        clobber  => 1,
        absolute => 1
    };

    unshift @{$vars}, $root_var;

    $self->var_root_name($root_name);
    $self->environment_variables($vars);
}

sub var_root_name {
    my ($self, $new_var_root_name) = @_;

    $self->{var_root_name} = $new_var_root_name if($new_var_root_name);

    return $self->{var_root_name};
}

sub bag {
    my ($self, $new_bag) = @_;

    $self->{bag} = $new_bag if($new_bag);

    croak 'No bag given'
    unless($self->{bag}); 

    return $self->{bag};
}

sub name {
    my ($self, $new_name) = @_;

    if($new_name) {
        # names can only contain letters, numbers, - and _.
        my @badchars = ($new_name =~ /([^A-Za-z0-9-_])/g);
        if(@badchars) {
            die "The name '$new_name' containes the following disallowed charactares: " 
            . join ', ', map { "'$_'" } @badchars;
        } else {
            $self->{name} = $new_name if($new_name);
        }
    }

    die 'No name given'
    unless($self->{name}); 

    return $self->{name};
}

sub version {
    my ($self, $new_version) = @_;

    $self->{version} = $new_version if($new_version);

    croak 'No version given'
    unless($self->{version}); 

    return $self->{version};
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    $self->{dependencies} = $new_dependencies if($new_dependencies);

    return $self->{dependencies};
}

sub sources {
    my ($self, $new_sources) = @_;

    if($new_sources) {
        my @sources = map { VC3::Source->new($self, $_) } @{$new_sources};
        $self->{sources} = \@sources;
    }

    return $self->{sources};
}

sub environment_variables {
    my ($self, $new_vars) = @_;

    $self->{environment_variables} = $new_vars if($new_vars);

    return $self->{environment_variables};
}

sub destination_dir {
    my ($self) = @_;
    return File::Spec->rel2abs($vc3_root) . '/' . $self->bag->target . '/' . $self->name . '-' . $self->version;
}

sub build_dir {
    my ($self) = @_;
    return File::Spec->rel2abs($vc3_root) . '/builds/' . $self->name;
}

sub build_log {
    my ($self) = @_;
    my $log_name = $self->destination_dir . '/' . $self->name . '-build-log';

    return $log_name;
}

sub completion_ribbon {
    my ($self) = @_;
    my $ribbon = $self->destination_dir . '/.VC3_DEPENDENCY_BUILD_COMPLETE';

    return $ribbon;
}

sub set_environment_variables {
    my ($self) = @_; 

    my $vars = $self->environment_variables
    || return;

    for my $var (@{$vars}) {

        my $name = $var->{name}
        || carp "Environment variable does not have a name.";

        my $value = $var->{value}
        || carp "Environment variable '$name' did not define a value.";

        my $clobber  = $var->{clobber};
        my $absolute = $var->{absolute};

        # split paths on : if necessary
        my @paths;
        if($clobber) {
            $vc3_environment{$name} = {};
            @paths = ($value);
        } else {
            @paths = split /:/, $value;
        }

        for my $path (@paths) {
            if(!$absolute) {
                $path = $self->destination_dir . '/' . $path;
            }
            $path = VC3::Bag::expand_env_variable($path);
            $vc3_environment{$name}->{$path} = 1;
        }

        my $dirs = $vc3_environment{$name};

        my $dotted = join(':', sort { $dirs->{$a} <=> $dirs->{$b} || $a cmp $b } keys %{$dirs});
        $ENV{$name} = $dotted;
    }
}

# range is: [min_version, max_version];
# max_version is the prefered version. 
# [version] is considered as [min_version]
# sub check_version {
#     my ($self, @range) = @_;
# 
#     return 1 unless $self->versioncmd;
#     return 1 unless $self->version || @range > 0;
# 
#     if(@range == 0) {
#         @range = (version->parse($self->{version}));
#     }
# 
#     my $reg = $self->{versionreg} ? $self->{versionreg} : qr/(.*)/;
# 
#     my $version_output = qx/$self->{versioncmd}/;
# 
#     return 0 unless $version_output =~ $reg;
# 
#     my ($observed_version) = version->parse("$1");
# 
#     print $observed_version . "\n";
# 
#     return 0 if $observed_version < $range[0];
#     return 0 if $observed_version > $range[$#range];
# 
#     return $observed_version;
# }

sub error_debug_info {
    my ($self, $eval_error) = @_;

    print "'", $self->name, "' failed to build for ", $self->bag->target, "\n";

    if($eval_error) {
        print $eval_error, "\n";
    }

    print "Last lines of log file:\n";
    system('tail', $self->build_log);
}


sub process_error {
    my ($self, $sh_on_error, $eval_error, $status) = @_;

    if($eval_error || $status) {
        $self->error_debug_info($eval_error);

        if($sh_on_error) {
            warn $@ if $@;
            my $pid = fork();
            if($pid == 0) {
                exec("/bin/sh -c 'cd " . $self->build_dir . " && exec \${SHELL:-/bin/sh}'");
                exit -1;
            } elsif($pid > 0) {
                waitpid $pid, 0;
            } else {
                croak 'Could not fork for debugging shell.';
            }
        }
    }
}

sub create_ribbon {
    my ($self) = @_;

    open (my $ribbon_fh, '>', $self->completion_ribbon);
    close $ribbon_fh;
}

sub prepare_recipe_sandbox {
    my ($self, $source) = @_;

    # clear build directory, to avoid bugs from uncleaned sources.
    my $build = $self->build_dir;
    if( -d $build ) {
        File::Path::rmtree($build);
    }

    # clear destination directory, to make sure we are running what we believe
    # we are running.
    my $destination = $self->destination_dir;
    if( -d $destination ) {
        File::Path::rmtree($destination);
    }

    # create the dirs we cleared above.
    File::Path::make_path($self->build_dir);
    File::Path::make_path($self->destination_dir);

    # make sure tmp dir exists
    File::Path::make_path($ENV{'TMPDIR'});

    # download to $vc3_distfiles the ingredient (i.e., input files) if missing.
    $source->get_files();

    # if generic, copy all files to build directory.
    # if tarball, expand first file to build directory, and copy the rest of
    # the files to build directory.
    $source->prepare_files($build);
}

sub execute_recipe {
    my ($self, $source) = @_;

    # if nothing to do, so we return no error:
    return 0 if -f $self->completion_ribbon();

    $self->bag->say("preparing '" . $self->name . "' for ", $self->bag->target);

    $self->prepare_recipe_sandbox($source);

    # set the destination directory as an environment variable before
    # setting up the shell, so that the child created inherets it.
    $ENV{'VC3_PREFIX'} = $self->destination_dir;
    $ENV{'VC3_BUILD'}  = $self->build_dir;

    my ($build_in, $pid) = $self->setup_build_shell($source);

    my @steps = @{$source->recipe};

    # add shifting to build directory as the first step.
    unshift @steps, 'cd ' . $self->build_dir;

    # add exiting cleanly from shell as a last step.
    push @steps, 'exit 0';

    $self->bag->say("building '" . $self->name . "' for ", $self->bag->target);
    $self->bag->say("details: " . $self->build_log);

    for my $step (@steps) {
        my $date = gmtime();
        print { $build_in } ": $date\n";
        print { $build_in } "$step\n";
    }

    my $status = -1;
    eval { close $build_in; $status = $? };

    delete $ENV{VC3_PREFIX}; 
    delete $ENV{VC3_BUILD}; 

    if(!$@ && WIFEXITED($status) && (WEXITSTATUS($status) == 0)) {
        $self->create_ribbon();
        File::Path::rmtree($self->build_dir);
        return 0;
    } else {
        return -1;
    }
}

sub setup_build_shell {
    my ($self, $source) = @_;

    my ($build_log, $build_in);

    # log the recipe used. Since we are opening sh with -e, the recipe executes
    # as if all steps were &&-ed together.
    open $build_log,    '>', $self->build_log;
    print { $build_log } join("\n && ", @{$source->recipe}) . "\n";
    close $build_log;

    # open sh with -e. This terminates the shell at the first step that returns
    # a non-zero status.
    my $pid = open($build_in, '|-', '/bin/sh -e');

    croak 'Could not open /bin/sh for building.'
    unless $build_in;

    # redirect all output to our log file.
    print { $build_in } 'exec 1>> ' . $self->build_log . "\n";
    print { $build_in } "exec 2>&1\n";

    # print some debug shell information (e.g., the step about to be executed).
    print { $build_in } "set -ex\n";

    # return the stdin of the shell, and the pid so we can wait for it.
    return ($build_in, $pid);
}

sub check_manual_requirements {
    my ($self) = @_;

    my $sources = $self->sources;

    my $restricted_unmet = 0;
    for my $source (@{$sources}) {
        unless($source->check_manual_requirements()) {
            $restricted_unmet++;
            print "\n", $source->msg_manual_requirement(), "\n\n";
        }
    }

    return $restricted_unmet;
}


sub runtime_dependencies {
    my ($self, $order) = @_;

    # if no parents, then give level one, a root package
    $order->{$self->name} |= 1;

    my $level = $order->{$self->name};

    my $dependencies = $self->dependencies;

    if($dependencies) {
        for my $dependency (keys %{$dependencies}) {
            my ($min_ver, $max_ver) = @{$dependencies->{$dependency}};
            my $next = $self->bag->select_version($dependency, $min_ver, $max_ver);

            my $next_level = $order->{$next->name} || 0;

            if($next_level < $level + 1) {
                $order->{$next->name} = $level + 1;
                $next->runtime_dependencies($order);
            }
        }
    }

    return $level;
}

package VC3::Source;
use Carp;

sub new {
    my ($class, $widget, $source_raw) = @_;

    my $source;

    if($source_raw->{type} eq 'generic') {
        $source = VC3::Source::Generic->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'tarball') {
        $source = VC3::Source::Tarball->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'manual-distribution') {
        $source = VC3::Source::ManualDist->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'service') {
        croak "Not implemented";
    }
    else {
        croak "Do not know about source type '" . $source_raw->{type} . "' for '" . $widget->name . "'";
    }

    return $source;
}

package VC3::Source::Generic;
use Carp;
use File::Copy;
use File::Path;
use File::Spec;
use HTTP::Tiny;

sub new {
    my ($class, $widget, $json_description) = @_;

    my $self = bless {}, $class;

    $self->widget($widget);
    $self->recipe($json_description->{recipe});
    $self->files($json_description->{files});
    $self->msg_manual_requirement($json_description->{msg_manual_requirement});
    $self->dependencies($json_description->{dependencies});

    return $self;
}

sub widget {
    my ($self, $new_widget) = @_;

    $self->{widget} = $new_widget if($new_widget);

    croak 'No environment argument given'
    unless($self->{widget}); 

    return $self->{widget};
}

sub recipe {
    my ($self, $new_recipe) = @_;

    $self->{recipe} = $new_recipe if($new_recipe);

    croak 'No recipe given'
    unless($self->{recipe}); 

    return $self->{recipe};
}

sub files {
    my ($self, $new_files) = @_;

    $self->{files} = $new_files if($new_files);

    if($self->{files}) {
        return $self->{files};
    } else {
        return [];
    }
}

sub msg_manual_requirement {
    my ($self, $new_message) = @_;

    if($new_message) {
        my @expansions = map { VC3::Bag::expand_env_variable($_) } @{$new_message};
        $self->{msg_manual_requirement} = join("\n", @expansions);
        $self->{msg_manual_requirement} = "\n" . ${self}->{msg_manual_requirement};
    }

    return $self->{msg_manual_requirement};
}

sub check_manual_requirements {
    my ($self, $new_message) = @_;

    # by default return true. Usually packages do not have manual requirements.
    return 1;
}

sub file_absolute {
    my ($self, $file) = @_;
    return File::Spec->rel2abs($vc3_distfiles . '/' . $file);
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    $self->{dependencies} = $new_dependencies if($new_dependencies);

    return $self->{dependencies};
}

sub get_file {
    my ($self, $file) = @_;

    unless(-f $self->file_absolute($file)) {
         $self->widget->bag->say("Downloading '" . $file . "' from $vc3_repository");

        #if make sure the destination directory exists
        File::Path::make_path($vc3_distfiles);

        my $ff = HTTP::Tiny->new();

        my $url    = $vc3_repository . '/' . $file;
        my $output = $vc3_distfiles  . '/' . $file;

        my $response = $ff->mirror($url, $output);

        # 304 means 'unchanged'
        unless($response->{success} || $response->{status} eq 304 ) { 
            die "Could not download '" . $file . "':\n"
            . "$response->{status} $response->{reason}"
        }
    }
}

sub get_files {
    my ($self) = @_;

    my $files = $self->files;

    for my $file (@{$files}) {
        $self->get_file($file);
    }
}

sub prepare_files {
    my ($self, $build_dir) = @_;

    for my $file (@{$self->files}) {
        symlink($self->file_absolute($file), $build_dir . '/' . $file)
        || die "Could not link '" . $file . "' to build directory.\n";
    }
}

package VC3::Source::Tarball;
use base 'VC3::Source::Generic';
use Carp;

sub new {
    my ($class, $widget, $json_description) = @_;

    my $self = VC3::Source::Generic->new($widget, $json_description);

    unless($self->files) {
        croak "For type 'tarball', at least one file should be defined in the files list, and the first file in the list should be a tarball.";
    }

    $self = bless $self, $class;

    return $self;
}

sub prepare_files  {
    my ($self, $build_dir) = @_;

    # first file in $self->files is the tarball, by convention.
    my $tarball = @{$self->files}[0];
    $tarball = $self->file_absolute($tarball);

    system(qq/tar -C ${build_dir} --strip-components=1 -xpf ${tarball}/);
    die "Could not expand tarball $tarball.\n" if $?;

    # link in the rest of the input files.
    $self->SUPER::prepare_files($build_dir);
}

package VC3::Source::ManualDist;
use base 'VC3::Source::Generic';
use Carp;

sub get_file {
    my ($self, $file) = @_;

    unless(-f $self->file_absolute($file)) {
        print $self->msg_manual_requirement . "\n";
        die "Missing manual or restricted distribution file.\n";
    }
}

sub file_absolute {
    my ($self, $file) = @_;
    return File::Spec->rel2abs($vc3_distfiles . '/manual-distribution/'  . $file);
}

sub check_manual_requirements {
    my ($self) = @_;

    for my $file (@{$self->files}) {
        unless(-f $self->file_absolute($file)) {
            # check failed, return false
            return 0;
        }
    }

    return 1;
}

