#! /usr/bin/env perl

use v5.009;
use strict;
use warnings;

# load module path, for bare, if needed
eval {use Cwd; use lib getcwd . "/builder-pack/fatlib";};

use VC3::Bag;
use VC3::Source;

package VC3::Builder;

use English qw/-mo_match_vars/;
use File::Path;
use File::Spec::Functions qw/catfile rel2abs/;
use Getopt::Long qw/GetOptions/;
use Tie::RefHash;
use Cwd;

use Carp qw( confess );
$SIG{TERM} = \&cleanup_signal_handler;
$SIG{INT}  = \&cleanup_signal_handler;
$SIG{ALRM} = \&cleanup_signal_handler;

# disable stdout buffering
select(STDOUT); $OUTPUT_AUTOFLUSH = 1;

my $pwd            = getcwd();
my $vc3_root       = catfile(${pwd}, 'vc3-root');
my $vc3_distfiles  = catfile(${pwd}, 'vc3-distfiles');
my $vc3_user_home  = 'vc3-home';
my $vc3_repository = "http://download.virtualclusters.org/builder-files";

my $shell          = '/bin/sh';

my @external_dependencies = qw/perl sh tail tar gcc g++ ld pkconfig make/;
my @cleanups;     # functions to call on exit.

# call main if running interactively
VC3::Builder::main();

END {
    local $?;

    for my $fn (@cleanups) {
        eval { $fn->() };
    }
}

sub usage {
    my ($script_name) = @_;
    return <<EOF;
$script_name [options] --require package[:min_version[:max_version]] --require ... [-- command-and-args]

  command-and-args      defaults to $shell

  options are:

  --database <catalog>  defaults to <internal> if available, otherwise 
                        to ./vc3_catalog.json. May be specified several times,
                        with latter package recipes overwriting previous ones. 

  --install <root>      Install with base <root>. 
                        Default is ${vc3_root}
  --home <home>         Set \${HOME} to <root>/<home> if <home> is a relative
                        path, otherwise to <home> if it is an absolute path.
                        Default is ${vc3_user_home}

  --distfiles <dir>     Directory to cache unbuilt packages locally.
                        Default is ${vc3_distfiles}
  --repository <url>    Site to fetch packages if needed.
                        Default is ${vc3_repository}

  --force               Reinstall the packages named with --require and the
                        packages they depend on.


  --make-jobs <n>       Concurrent make jobs. Default is 4.
  --sh-on-error         On building error, run $shell on the partially-built
                        environment.

  --sys package:version=<dir>
                        Assume <dir> to be the installation location of
                        package:version in the system.
                        (e.g. --sys python:2.7=/opt/local/)
  --no-sys=<package>    Do not use host system version of <package>. If
                        package is 'ALL', do not use system versions at
                        all. (Ignored if package specified with --sys.)

  --var NAME=VALUE      Add environment variable NAME with VALUE. 
                        May be specified several times.

  --revar PATTERN       All environment variables matching the regular
                        expression PATTERN are preserved.
                        (E.g. --revar "SGE_.*", --revar NAME is equivalent
                        to -var NAME=\$NAME)

  --interactive         Treat command-and-args as an interactive terminal.

  --silent              Do not print dependency information.
  --no-run              Set up environment, but do not execute any payload.

  --timeout SECONDS     Terminate after SECONDS have elapased. 
                        If 0, then the timeout is not activated (default).

  --env-to <file>       Write environment script to
                        <file>.{,env,payload}, but do not execute command-and-args.
                        To execute command-and-args, run ./<file>.

  --dot <file>          Write a dependency graph of the requirements to <file>.

  --parallel <dir>      Write specifications for a parallel build to <dir>.
                        (Implies --prestage.)

  --prestage            Download all files to --distfiles <dir> before
                        processing.

  --list                List general packages available.

  --list=section        List general packages available, classified by sections.

  --list=all            List all the packages available, even vc3-internals.

  Developers options:
  --debug               On a builder error, print the full back-trace. 

Examples:
    ${script_name} --require cvmfs 'ls /cvmfs/atlas.cern.ch' 
    ${script_name} --require maker-example-ecoli-01
EOF

}

sub select_sleep {
    my ($seconds) = @_;

    select(undef, undef, undef, $seconds);
}

sub cleanup_signal_handler {
    my ($signal) = @_;

    if($signal) {
        warn("Got signal!: $signal");

        if($signal eq 'ALRM') {
            warn("Timeout!");
        }

        exit 128;
    }
}

sub fix_http_proxy_vars {
    for my $var (qw(http_proxy HTTP_PROXY)) {
        my $val = $ENV{$var};

        if($val) {
            if($val =~ /^:?;?DIRECT$/) {
                delete $ENV{$var};
                next;
            }

            if($val !~ m#^https?://#) { 
                $ENV{$var} = "http://$val";
            }
        }
    }
}

sub remove_vc3_vars() {
    for my $var (keys %ENV) {
        if($var =~ '^VC3_') {
            delete $ENV{$var};
        }
    }
}

sub main {
    my @requires     = ();

    my $print_help   = 0;
    my $make_jobs    = 4;
    my $sh_on_error  = 0;

    my $debug_modules_used = 0;
    my $dry_run            = 0;
    my $no_run             = 0;
    my $debug_run          = 0;
    my $interactive_run    = 0;
    my $silent             = 0;
    my $force_rebuild      = 0;
    my $prestage           = 0;
    my $timeout;

    my $ignore_locks       = 0;

    my $env_to;
    my $dot_output;
    my $parallel_dir;       
    my $to_script;
    my $list_option;

    my @extra_env_vars = ();
    my @databases   = ();
    my @re_vars     = ();
    my @sys_manual  = ();
    my @no_sys      = ();

    # if the executable name does looks like "perl", we use $0, as it has the
    # name of the script. Otherwise, this is a static run, and we use the given
    # executable name.
    my $script_name = ${EXECUTABLE_NAME} =~ /perl/ ? $0 : ${EXECUTABLE_NAME};

    my $original_command = join(' ', $script_name, @ARGV);
    
    VC3::Builder::remove_vc3_vars();
    VC3::Builder::fix_http_proxy_vars();

    my $opt_result = GetOptions(
        "help"        => \$print_help,

        "debug"    => \$debug_run,
        "silent"   => \$silent,

        "database=s"  => \@databases,
        "require=s"   => \@requires, 

        "install=s" => \$vc3_root,
        "home=s"    => \$vc3_user_home,

        "distfiles=s"  => \$vc3_distfiles, 
        "repository=s" => \$vc3_repository, 

        "make-jobs=n" => \$make_jobs,

        "sh-on-error"     => \$sh_on_error,

        "force"           => \$force_rebuild,
        "ignore-locks"    => \$ignore_locks,

        "env-to=s"    => \$env_to,
        "dot=s"       => \$dot_output,
        "to-script=s" => \$to_script,

        "dry-run"  => \$dry_run,
        "no-run"   => \$no_run,
        "prestage" => \$prestage,
        "list:s"   => \$list_option,

        "interactive" => \$interactive_run,

        "timeout=i"   => \$timeout,

        "sys=s"    => \@sys_manual,
        "no-sys=s" => \@no_sys,
        "var=s"    => \@extra_env_vars,
        "revar=s"  => \@re_vars,

        "parallel=s" => \$parallel_dir,

        # options for developing, not for runtime:
        "debug-modules-used" => \$debug_modules_used,
    );

    unless($opt_result) {
        print usage($script_name);
        exit 1;
    }

    if($debug_run) {
        $SIG{__DIE__}  =  \&confess;
    }

    unshift @databases, '<internal>';

    if($print_help) {
        print usage($script_name);
        exit 0;
    }

    if($debug_modules_used) {
        print_modules_used();
        exit 0;
    }

    if(defined $dot_output) {
        push @no_sys, 'ALL';
        $dry_run = 1;
    }

    if(defined $to_script) {
        $dry_run = 1;
    }

    if(defined $list_option) {
        $silent  = 1;
        $dry_run = 1;
    }

    if(defined $timeout) {
        if($timeout < 0) {
            die 'timeout cannot be less than 0';
        } else {
            alarm $timeout;
        }
    }
    
    if(defined $parallel_dir) {
        push @no_sys, 'ALL';
    }

    unless(@requires) {
        push @requires, 'noop';
    }

    # add common builder environment
    unshift @requires, 'vc3-builder-hands';

    # set defaults
    my @command_and_args = @ARGV;
    if(!@command_and_args) {
        @command_and_args = ($shell,);
        $interactive_run = 1;
    }

    push @extra_env_vars, "MAKEFLAGS=-j${make_jobs}";
    push @extra_env_vars, "VC3_COMMAND_LINE=" . rel2abs(join(" ", $original_command));

    # honor paths from enclosing builder, if any.
    unshift @re_vars, 'VC3_.*';

    for my $pat (@re_vars) {
        for my $name (keys %ENV) {
            next unless $name =~ /$pat/;
            push @extra_env_vars, "$name='" . $ENV{$name} . "'";
        }
    }

    my $bag = VC3::Bag->new(
        root       => $vc3_root,
        home       => $vc3_user_home,
        distfiles  => $vc3_distfiles,
        repository => $vc3_repository,
        shell      => $shell,
        dry_run    => $dry_run,
        on_terminal=> $interactive_run,
        silent     => $silent,
        databases  => \@databases,
        sys_manual => \@sys_manual,
        no_sys     => \@no_sys,
        env_vars   => \@extra_env_vars);

    push @cleanups, sub { $bag->cleanup() };

    $bag->set_plan_for(@requires);

    if(defined $dot_output) {
        $bag->dot_graph($dot_output);
    }

    if(defined $to_script) {
        $bag->plan->to_script($to_script);
    }

    if(defined $list_option) {
        $bag->list_packages($list_option);
    }


    if($bag->dry_run) {
        exit 0;
    }

    if(defined $parallel_dir) {
        $bag->to_parallel($parallel_dir, $make_jobs);
        $bag->check_manual_requirements();
 
        $bag->set_plan_for('vc3-builder-hands', 'cctools-statics');
        $ignore_locks = 1;
        $prestage     = 1;
    }

    $bag->check_manual_requirements();

    if($prestage) {
        $bag->plan->prestage();
    }

    $bag->execute_plan($sh_on_error, $force_rebuild, $ignore_locks);

    my $exit_code;
    if($no_run) {
        $exit_code = 0;
    } elsif($env_to) {
        $bag->preserve_profile(1);
        $bag->set_profile($env_to, @command_and_args);
        $exit_code = 0;
    } else {
        $exit_code = $bag->execute(@command_and_args);
    }

    exit $exit_code;
}

sub print_modules_used {
    my $file = "stub-debug-modules.txt";

    unlink catfile($vc3_distfiles, $file);

    File::Path::make_path($vc3_distfiles);

    my $ff       = HTTP::Tiny->new();
    my $url      = $vc3_repository . '/' . $file;
    my $output   = catfile($vc3_distfiles,  $file);

    # dummy calls to trigger the use of the http module.
    my $response_a = $ff->mirror($url, $output);
    my $response_b = $ff->mirror($url, $output);

    my @modules = grep { /\.pm$/ } keys %INC;

    # turn :: into /
    map { s^/^::^g }   @modules;

    # remove .pm extension
    map { s^\.pm$^^g } @modules;

    # add modules that %INC sometimes does not find:
    my @manuals = 
    qw(
        encoding
        strict
        Cwd
        Digest::Perl::MD5
        English 
        Getopt::Long
        LockFile::Simple
        PerlIO
        Tie::RefHash );

    @modules = (@manuals, @modules);


    # remove duplicates
    @modules = uniq_words(@modules);

    @modules = sort { uc($a) cmp uc($b) } @modules;

    print join("\n", @modules), "\n";
}

sub uniq_words {
    my %words;
    for my $word (@_) {
        $words{$word} = 1;
    }

    return keys %words;
}

package VC3::Package;
use Carp;
use File::Temp;
use File::Spec::Functions qw/catfile rel2abs/;

sub new {
    my ($class, $bag, $name, $json_description) = @_;

    my $self = bless {}, $class;

    $self->bag($bag);
    $self->name($name);
    $self->dependencies($json_description->{dependencies});
    $self->wrapper($json_description->{wrapper});
    $self->prologue($json_description->{prologue});
    $self->environment_variables($json_description->{'environment-variables'});
    $self->environment_autovars($json_description->{'environment-autovars'});
    $self->phony($json_description->{phony});
    $self->operating_system($json_description->{operating_system});
    $self->auto_version($json_description->{'auto-version'});

    $self->show_in_list($json_description->{'show-in-list'});
    $self->tags($json_description->{'tags'});

    if($json_description->{versions}) {
        $self->widgets($json_description->{versions});
    } else {
        $self->{widgets} = [];
    }

    return $self;
}

sub widgets {
    my ($self, $new_widgets_spec) = @_;

    if($new_widgets_spec) {
        my @widgets;
        for my $s (@{$new_widgets_spec}) {
            my $w = VC3::Widget->new($self, $s);
            push @widgets, $w if $w;
        }

        $self->{widgets} = \@widgets;
    }

    return $self->{widgets};
}
        

sub bag {
    my ($self, $new_bag) = @_;

    $self->{bag} = $new_bag if($new_bag);

    croak 'No bag given'
    unless($self->{bag}); 

    return $self->{bag};
}

sub name {
    my ($self, $new_name) = @_;

    if($new_name) {
        # names can only contain letters, numbers, - and _.
        my @badchars = ($new_name =~ /([^A-Za-z0-9-_])/g);
        if(@badchars) {
            die "The name '$new_name' containes the following disallowed charactares: " 
            . join ', ', map { "'$_'" } @badchars;
        } else {
            $self->{name} = $new_name if($new_name);
        }
    }

    die 'No name given'
    unless($self->{name}); 

    return $self->{name};
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    $self->{dependencies} = $new_dependencies if($new_dependencies);

    return $self->{dependencies};
}

sub active_source {
    my ($self, $source) = @_;

    if($source) {
        $self->{active_source} = $source;
        $self->checksum($source);
    }

    return $self->{active_source};
}

sub prologue {
    my ($self, $new_prologue) = @_;

    $self->{prologue} = $new_prologue if($new_prologue);

    return $self->{prologue};
}

sub wrapper {
    my ($self, $new_wrapper) = @_;

    $self->{wrapper} = $new_wrapper if($new_wrapper);

    return $self->{wrapper};
}

sub environment_variables {
    my ($self, $new_vars) = @_;

    $self->{environment_variables} = $new_vars if($new_vars);

    return $self->{environment_variables};
}

sub environment_autovars {
    my ($self, $new_autovars) = @_;

    $self->{environment_autovars} = $new_autovars if($new_autovars);

    return $self->{environment_autovars};
}

sub auto_version {
    my ($self, $new_auto_version) = @_;

    $self->{auto_version} = $new_auto_version if($new_auto_version);

    return $self->{auto_version};
}

sub compute_auto_version {
    my ($self, $root) = @_;

    unless($self->auto_version) {
        die "I don't know how to compute the version of '" . $self->name . "'\n";
    }

    if($root) {
        $self->bag->add_builder_variable('VC3_PREFIX', $root);
    }

    my ($pid, $auto_in) = $self->bag->shell();

    if($root) {
        $self->bag->del_builder_variable('VC3_PREFIX');
    }

    croak "Could not open $shell for auto-version."
    unless $auto_in;

    my $template = catfile($self->bag->tmp_dir, $self->name . 'XXXXXX');
    my $fh = File::Temp->new(template => $template, unlink => 1);
    close($fh);
    
    my $fname = $fh->filename;

    # redirect all output to our log file.
    print { $auto_in } 'exec 1> ' . $fname . "\n";
    print { $auto_in } "exec 2>&1\n";
    print { $auto_in } "set -ex\n";

    if($root) {
        print { $auto_in } q(export PATH="${VC3_PREFIX}/bin":"$PATH") . "\n";
    }

    for my $step (@{$self->auto_version}) {
        print { $auto_in } "$step\n";
    }
    print { $auto_in } "exit 0\n";

    my $status = -1;
    eval { close $auto_in; $status = $? };

    if($@) {
        carp $@;
    }

    open(my $f, '<', $fname) || die 'Did not produce auto-version file';
    my @lines;
    my $version;
    while( my $line = <$f>) {
        push @lines, $line;
        if($line =~ m/^VC3_VERSION_SYSTEM:\s*v?(?<version>([0-9]+(\.?[0-9]){0,3}))$/) {
            $version = $+{version};
            chomp($version);
            last;
        }
    }
    close $f;
    if(!$version) {
        die "Did not produce version information:\n" . join("\n", @lines);
    }

    return $version;
}



sub phony {
    my ($self, $new_phony) = @_;

    $self->{phony} = $new_phony if(defined $new_phony);

    return $self->{phony};
}

sub show_in_list {
    my ($self, $new_show) = @_;

    $self->{show_in_list} = $new_show if(defined $new_show);

    return $self->{show_in_list};
}

sub tags {
    my ($self, $new_tags) = @_;

    $self->{tags} = $new_tags if($new_tags);

    return $self->{tags};
}

sub operating_system {
    my ($self, $new_os) = @_;

    $self->{operating_system} = $new_os if($new_os);

    return $self->{operating_system};
}


package VC3::Widget;
use Carp;
use POSIX ":sys_wait_h";
use IO::Handle;
use Digest::Perl::MD5 qw(md5_hex);
use Cwd;
use File::Temp qw/tempdir/;
use File::Spec::Functions qw/catfile rel2abs/;
use JSON::Tiny;

use VC3::Ribbon;

# Attributes:
# name, version, sources, dependencies, wrapper, prologue, environment_variables, environment_autovars, phony
sub new {
    my ($class, $pkg, $json_description) = @_;

    my $self = bless {}, $class;

    $self->package($pkg);
    $self->available(1);

    if($json_description->{version} eq 'auto') {
        $self->from_system(1);
        eval { $self->version($pkg->compute_auto_version()) };
        if($@) {
            $self->available(0);
        }
    } else {
        $self->version($json_description->{version});
        $self->from_system(0);
    }

    $self->sources($json_description->{sources});
    $self->dependencies($json_description->{dependencies});
    $self->wrapper($json_description->{wrapper});
    $self->prologue($json_description->{prologue});
    $self->environment_variables($json_description->{'environment-variables'});
    $self->environment_autovars($json_description->{'environment-autovars'});
    $self->phony($json_description->{phony});
    $self->operating_system($json_description->{operating_system});

    if($self->available) {
        # set root dir
        $self->root_dir();

        my $majminbug = $self->version->normal;
        $majminbug =~ s/^v([0-9]+\.[0-9]+\.[0-9]+)/$1/;

        my $majmin = $self->version->normal;
        $majmin    =~ s/^v([0-9]+\.[0-9]+)\..*/$1/;

        $self->add_widget_variable('VERSION', $majmin);
        $self->add_widget_variable('VERSION_FULL', $majminbug);
    }

    unless($self->sources) {
        my $null_source = {};
        $null_source->{type}   = 'generic';
        $null_source->{phony}  = 1;
        $null_source->{local}  = 1;
        $null_source->{recipe} = ['echo "no explicit recipe given"'];

        $self->sources([$null_source]);
    }

    return $self;
}

sub add_widget_variable {
    my ($self, $varname, $value) = @_;

    my $vars    = $self->environment_variables || [];

    $varname = $self->widget_var($varname);

    my $var = {
        name     => $varname,
        value    => $value,
        clobber  => 1,
        absolute => 1
    };
    unshift @{$vars}, $var;

    $self->environment_variables($vars);
}

sub widget_var {
    my ($self, $varname) = @_;

    my $expanded = "VC3_${varname}_" . uc($self->name);

    # replace - with _, as env vars cannot have - in their names.
    $expanded =~ s/-/_/g;

    return $expanded;
}

sub package {
    my ($self, $new_pkg) = @_;

    $self->{package} = $new_pkg if($new_pkg);

    croak 'No package given'
    unless($self->{package}); 

    return $self->{package};
}

sub bag {
    my ($self) = @_;

    return $self->package->bag;
}

sub name {
    my ($self, $new_name) = @_;

    return $self->package->name;
}

sub ribbon {
    my ($self) = @_;

    unless($self->{ribbon}) {
        $self->{ribbon} = VC3::Ribbon->new($self->name, $self->bookeeping_dir, $self->bag->tmp_dir, $self->checksum);
    }

    return $self->{ribbon};
}

sub version {
    my ($self, $new_version) = @_;

    if($new_version) {
        $self->{version} = version->declare($new_version);
    }

    unless($self->{version}) {
        croak 'No version given';
    }

    return $self->{version};
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    if($new_dependencies) {
        $self->{dependencies} = $new_dependencies;
    }

    my %deps;
    if($self->package->dependencies) {
        %deps = %{$self->package->dependencies};
    }

    for my $d (keys %{$self->{dependencies}}) {
        $deps{$d} = $self->{dependencies}->{$d};
    }

    return \%deps;
}

sub sources {
    my ($self, $new_sources) = @_;

    if($new_sources) {
        my @sources = map { VC3::Source->new($self, $_) } @{$new_sources};
        $self->{sources} = \@sources;
    }

    return $self->{sources};
}

sub active_source {
    my ($self, $source) = @_;

    if($source) {
        $self->{active_source} = $source;
        $self->checksum($source);
    }

    return $self->{active_source};
}

sub prologue {
    my ($self, $new_prologue) = @_;

    $self->{prologue} = $new_prologue if($new_prologue);

    my $prologue = $self->{prologue} || $self->package->prologue;

    return $prologue;
}

sub wrapper {
    my ($self, $new_wrapper) = @_;

    $self->{wrapper} = $new_wrapper if($new_wrapper);

    my $wrapper = $self->{wrapper} || $self->package->wrapper;

    return $wrapper;
}


sub environment_variables {
    my ($self, $new_vars) = @_;

    if($new_vars) {
        my @vars = ();

        if($self->package->environment_variables) {
            push @vars, @{$self->package->environment_variables};
        }

        push @vars, @{$new_vars};
        $self->{environment_variables} = \@vars;
    }

    return $self->{environment_variables};
}

sub environment_autovars {
    my ($self, $new_autovars) = @_;

    my %mappings;
    $mappings{PATH}               = 'bin';
    $mappings{LD_LIBRARY_PATH}    = 'lib';
    $mappings{LIBRARY_PATH}       = 'lib';
    $mappings{C_INCLUDE_PATH}     = 'include';
    $mappings{CPLUS_INCLUDE_PATH} = 'include';
    $mappings{PKG_CONFIG_PATH}    = 'lib/pkgconfig';
    $mappings{PYTHONPATH}         = 'lib/python${VC3_VERSION_PYTHON}/site-packages';
    $mappings{PERL5LIB}           = 'lib/perl5/site_perl';

    if($new_autovars) {
        $self->{environment_autovars} = $new_autovars;
    }

    my @autovars;
    if($self->package->environment_autovars) {
        push @autovars, @{$self->package->environment_autovars};
    }

    if($self->{environment_autovars}) {
        push @autovars, @{$self->{environment_autovars}};
    }

    $self->{environment_variables} ||= [];
    for my $var (@autovars) {
        my $target = $mappings{$var};

        unless($target) {
            die "Unrecognized auto-variable '$var'";
        }

        push @{$self->{environment_variables}}, { 'name' => $var, 'value' => $target };
    }

    return @autovars;
}

sub phony {
    my ($self, $new_phony) = @_;

    $self->{phony} = $new_phony if(defined $new_phony);

    my $phony = $self->{phony} || $self->package->phony;

    return $phony;
}

sub from_system {
    my ($self, $new_from_system) = @_;

    $self->{from_system} = $new_from_system if(defined $new_from_system);

    return $self->{from_system};
}

sub available {
    my ($self, $new_available) = @_;

    $self->{available} = $new_available if(defined $new_available);

    return $self->{available};
}

sub operating_system {
    my ($self, $new_operating_system) = @_;

    $self->{operating_system} = $new_operating_system if($new_operating_system);

    my $operating_system = $self->{operating_system} || $self->package->operating_system;

    return $operating_system;
}

sub root_dir {
    my ($self, $new) = @_;

    my $old = $self->{root_dir};

    my $var_value;

    if($new) {
        $self->{root_dir} = $new;
        $var_value = $new;
    }

    unless($self->{root_dir}) {
        my $rel = catfile($self->bag->target, $self->name, $self->version->normal);
        $self->{root_dir} = catfile(rel2abs($vc3_root), $rel);
        $var_value = catfile('${VC3_ROOT}', '${VC3_MACHINE_TARGET}', $self->name, 'v${' . $self->widget_var('VERSION_FULL') . '}');
    }

    if(!$old || $old ne $self->{root_dir}) {
        $self->add_widget_variable('ROOT', $var_value);
    }

    return $self->{root_dir};
}

sub bookeeping_dir {
    my ($self, $relative) = @_;

    my $rel = catfile($self->bag->target, $self->name, $self->version->normal);

    if($relative) {
        return $rel;
    }

    return catfile(rel2abs($vc3_root), $rel);
}

sub build_dir {
    my ($self) = @_;

    unless($self->{build_dir}) {
        my $root     = catfile(rel2abs($vc3_root), 'builds');

        unless(-d $root) {
            File::Path::make_path($root);
        }

        my $template = catfile($root, $self->name . '.XXXXXX');

        my $tmpdir   = File::Temp::tempdir($template, CLEANUP => 1);
        $self->{build_dir} = $tmpdir;
    }

    return $self->{build_dir};
}

sub build_log {
    my ($self) = @_;
    my $log_name = catfile($self->bookeeping_dir, $self->name . '-build-log');

    return $log_name;
}

sub say {
    my $self = shift @_;

    return $self->bag->say(@_);
}

sub consolidate_environment_variables {
    my ($self, $expansion) = @_; 

    my $vars = $self->environment_variables
    || return;

    for my $var (reverse @{$vars}) {

        my $name = $var->{name}
        || carp "Environment variable does not have a name.";

        my $value = $var->{value}
        || carp "Environment variable '$name' did not define a value.";

        my $clobber  = $var->{clobber};
        my $absolute = $var->{absolute};

        if($expansion->{$name} && $clobber) {
            my @old_value = @{$expansion->{$name}};
            my $n = @old_value;
            if($n > 1) {
                carp("Asked to clobber variable '$name', but it already had a value.\n"
                    . "'$value' <> '" . join(',', @old_value) . "'\n");
            }
        }

        $expansion->{$name} ||= [];

        my @paths;
        if($clobber) {
            # when clobber, we use the value as is, and remove previous expansions.
            @paths = ($value);
            $expansion->{$name} = [];
        } else {
            # otherwise, split paths on :
            @paths = split /:/, $value;
        }

        my @current_expansions;
        for my $path (@paths) {
            if(!$absolute) {
                if($self->root_dir eq $self->bookeeping_dir) {
                    $path = catfile('${' . $self->widget_var('ROOT') . '}', $path);
                } else {
                    $path = catfile($self->root_dir, $path);
                }
            }

            push @current_expansions, $path;
        }

        unshift @{$expansion->{$name}}, @current_expansions;
    }
}

sub error_debug_info {
    my ($self, $eval_error) = @_;

    print "'", $self->name, "' failed to build for ", $self->bag->target, "\n";

    if($eval_error) {
        print $eval_error, "\n";
    }

    if(-f $self->build_log) {
        print "Last lines of log file:\n";
        system('tail', $self->build_log);
    }
}


sub process_error {
    my ($self, $sh_on_error, $eval_error, $status) = @_;

    if($eval_error || $status) {
        $self->error_debug_info($eval_error);

        if($sh_on_error) {
            warn $@ if $@;

            my $cwd = getcwd();

            $self->bag->shell_user();

            chdir $cwd;
        }
    }
}

sub checksum {
    my ($self, $load) = @_;

    if(!$self->{checksum}) {
        $load ||= 'no source';

        my $txt = $self->hash_to_canonical_str($load);
        my $dgt = md5_hex($txt);

        $self->{checksum} = $dgt;
    }

    return $self->{checksum};
}

sub hash_to_canonical_str {
    my ($self, $ref) = @_;

    my $str;

    if(ref($ref) eq 'HASH') {
        my @ks = sort { $a cmp $b } keys %{$ref};

        $str 
        = '{'
        . join(',', map { $_ .  ':' . $self->hash_to_canonical_str($ref->{$_}) } @ks)
        . '}';
    } elsif(ref($ref) eq 'ARRAY') {
        $str 
        = '['
        . join(',', map { $self->hash_to_canonical_str($_) } @{$ref})
        . ']';
    } else {
        $str = $ref;
    }

    return $str;
}


sub msgs_manual_requirements {
    my ($self) = @_;

    my $sources = $self->sources;

    my @restricted_unmet;
    for my $source (@{$sources}) {
        unless($source->check_manual_requirements()) {
            push @restricted_unmet, $source->msg_manual_requirement();
        }
    }

    return @restricted_unmet;
}


sub prepare_recipe_sandbox {
    my ($self, $no_erase) = @_;

    # clear build directory, to avoid bugs from uncleaned sources.
    my $build = $self->build_dir;
    if( -d $build ) {
        File::Path::rmtree($build);
    }

    # clear destination directory, to make sure we are running what we believe
    # we are running.
    unless($no_erase) {
        my $dir = $self->root_dir;
        if( -d $dir ) {
            File::Path::rmtree($dir);
        }

        if($self->root_dir ne $self->bookeeping_dir) {
            my $dir = $self->bookeeping_dir;
            if( -d $dir ) {
                File::Path::rmtree($dir);
            }
        }
    }

    # create the dirs we removed above.
    File::Path::make_path($self->build_dir);
    File::Path::make_path($self->root_dir);
    File::Path::make_path($self->bookeeping_dir);

    # make sure tmp dir exists
    File::Path::make_path($self->bag->tmp_dir);

    # set the destination directory as an environment variable before
    # setting up the shell, so that the child created inherets it.
    $self->bag->add_builder_variable('VC3_PREFIX', $self->root_dir);
    $self->bag->add_builder_variable('VC3_BUILD',  $self->build_dir);
}

sub cleanup_recipe_sandbox {
    my ($self, $result) = @_;

    $self->bag->del_builder_variable('VC3_PREFIX');
    $self->bag->del_builder_variable('VC3_BUILD');

    if($result eq '0') {
        File::Path::rmtree($self->build_dir);
        $self->ribbon->commit('DONE');
    }

    # we do not delete the buildir in case of error, to ease debugging.
}

sub setup_build_shell {
    my ($self, @log_messages) = @_;

    # log the recipe used. Since we are opening sh with -e, the recipe executes
    # as if all steps were &&-ed together.
    open(my $build_log, '>', $self->build_log);
    print { $build_log } join("\n && ", @log_messages . "\n");
    close $build_log;

    # open sh with -e. This terminates the shell at the first step that returns
    # a non-zero status.
    my ($pid, $build_in) = $self->bag->shell();

    croak "Could not open $shell for building."
    unless $build_in;

    # redirect all output to our log file.
    print { $build_in } 'exec 1>> ' . $self->build_log . "\n";
    print { $build_in } "exec 2>&1\n";
    print { $build_in } "set -ex\n";

    # return the stdin of the shell, and the pid so we can wait for it.
    return ($pid, $build_in);
}

sub shell {
    my ($self) = @_;
    return $self->bag->shell();
}

