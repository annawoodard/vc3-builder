#! /usr/bin/env perl

use v5.009;
use strict;
use warnings;

package VC3::Builder;

use English qw/-mo_match_vars/;
use Getopt::Long qw/GetOptions/;
use Tie::RefHash;
use Cwd;

use Carp qw( confess );
$SIG{TERM} = \&cleanup_signal_handler;
$SIG{INT}  = \&cleanup_signal_handler;

# disable stdout buffering
select(STDOUT); $OUTPUT_AUTOFLUSH = 1;

my $pwd            = getcwd();
my $vc3_root       = $ENV{VC3_ROOT}       || "${pwd}/vc3-root";
my $vc3_distfiles  = $ENV{VC3_DISTFILES}  || "${pwd}/vc3-distfiles";
my $vc3_user_home  = $ENV{VC3_USER_HOME}  || "vc3-home";
my $vc3_repository = $ENV{VC3_REPOSITORY} || "http://download.virtualclusters.org/builder-files";

my @external_dependencies = qw/perl sh tail tar gcc g++ ld pkconfig make/;
my @cleanups;     # functions to call on exit.

# call main if running interactively
VC3::Builder::main();


sub usage {
    my ($script_name) = @_;
    return <<EOF;
$script_name [options] --require package[:min_version[:max_version]] --require ... [-- command-and-args]

  command-and-args      defaults to /bin/sh

  options are:

  --database <catalog>  defaults to <internal> if available, otherwise 
                        to ./vc3_catalog.json. May be specified several times,
                        with latter package recipes overwriting previous ones. 

  --install <root>      Install with base <root>. 
                        Default is ${vc3_root}
  --home <home>         Set \${HOME} to <root>/<home> if <home> is a relative
                        path, otherwise to <home> if it is an absolute path.
                        Default is ${vc3_user_home}

  --distfiles <dir>     Directory to cache unbuilt packages locally.
                        Default is ${vc3_distfiles}
  --repository <url>    Site to fetch packages if needed.
                        Default is ${vc3_repository}

  --force               Reinstall the packages named with --require and the
                        packages they depend on.


  --make-jobs <n>       Concurrent make jobs. Default is 4.
  --sh-on-error         On building error, run /bin/sh on the partially-built
                        environment.

  --sys package:version=<dir>
                        Assume <dir> to be the installation location of
                        package:version in the system.
                        (e.g. --sys python:2.7=/opt/local/)
  --no-sys=<package>    Do not use host system version of <package>. If
                        package is 'ALL', do not use system versions at
                        all. (Ignored if package specified with --sys.)

  --var NAME=VALUE      Add environment variable NAME with VALUE. 
                        May be specified several times.

  --interactive         Treat command-and-args as an interactive terminal.

  --silent              Do not print dependency information.
  --no-run              Set up environment, but do not execute any payload.

  --env-to <file>       Write environment scripts to <root>/<home>/<file>{,.cmd},
                        but do not execute the payload.

  --dot <file>          Write a dependency graph of the requirements to <file>.

  --parallel <dir>      Write specifications for a parallel build to <dir>.

  Developers options:
  --debug               On a builder error, print the full back-trace. 

Examples:
    ${script_name} --require cvmfs 'ls /cvmfs/atlas.cern.ch' 
    ${script_name} --require maker-example-ecoli-01
EOF

}

sub cleanup_signal_handler {
    my ($signal) = @_;

    if($signal) {
        warn("Got signal!: $signal");
    }

    for my $fn (@cleanups) {
        eval { $fn->() };
    }

    if($signal) {
        $? = 128;
        exit $?;
    }
}

END {
    cleanup_signal_handler();
}

sub main {
    my @requires     = ();

    my $print_help   = 0;
    my $make_jobs    = 4;
    my $sh_on_error  = 0;
    my $env_to       = 0;

    my $debug_modules_used = 0;
    my $dry_run            = 0;
    my $no_run             = 0;
    my $debug_run          = 0;
    my $interactive_run    = 0;
    my $silent             = 0;
    my $force_rebuild      = 0;

    my $ignore_locks       = 0;

    my $dot_output;
    my $parallel_dir;       

    my @databases   = ();
    my @extra_vars  = ();
    my @sys_locs    = ();
    my @no_sys_locs = ();

    # if the executable name does looks like "perl", we use $0, as it has the
    # name of the script. Otherwise, this is a static run, and we use the given
    # executable name.
    my $script_name = ${EXECUTABLE_NAME} =~ /perl/ ? $0 : ${EXECUTABLE_NAME};

    my $original_command = join(' ', $script_name, @ARGV);


    my $opt_result = GetOptions(
        "help"        => \$print_help,

        "debug"    => \$debug_run,
        "silent"   => \$silent,

        "database=s"  => \@databases,
        "require=s"   => \@requires, 

        "install=s" => \$vc3_root,
        "home=s"    => \$vc3_user_home,

        "distfiles=s"  => \$vc3_distfiles, 
        "repository=s" => \$vc3_repository, 

        "make-jobs=n" => \$make_jobs,

        "sh-on-error"     => \$sh_on_error,

        "force"           => \$force_rebuild,
        "ignore-locks"    => \$ignore_locks,

        "env-to=s" => \$env_to,

        "dot=s"    => \$dot_output,

        "dry-run"  => \$dry_run,
        "no-run"   => \$no_run,

        "interactive" => \$interactive_run,

        "sys=s"    => \@sys_locs,
        "no-sys=s" => \@no_sys_locs,
        "var=s"    => \@extra_vars,

        "parallel=s" => \$parallel_dir,

        # options for developing, not for runtime:
        "debug-modules-used" => \$debug_modules_used,
    );

    unless($opt_result) {
        print usage($script_name);
        exit 1;
    }

    if($debug_run) {
        $SIG{__DIE__}  =  \&confess;
    }

    unshift @databases, '<internal>';

    if($print_help) {
        print usage($script_name);
        exit 0;
    }

    if($debug_modules_used) {
        print_modules_used();
        exit 0;
    }

    if(defined $dot_output) {
        push @no_sys_locs, 'ALL';
        $dry_run = 1;
    }
    
    #disable system deps for now:
    push @no_sys_locs, 'ALL';

    if(defined $parallel_dir) {
        push @no_sys_locs, 'ALL';
    }

    unless(@requires) {
        print "At least one --require option should be given.\n\n" . usage($script_name);
        exit 1;
    }

    # set defaults
    my @command_and_args = @ARGV;
    if(!@command_and_args) {
        @command_and_args = ('/bin/sh',);
        $interactive_run = 1;
    }

    push @extra_vars, "MAKEFLAGS=-j${make_jobs}";
    push @extra_vars, "VC3_COMMAND_LINE=" . File::Spec->rel2abs(join(" ", $original_command));

    my $bag = VC3::Bag->new($dry_run, $interactive_run, $silent, \@databases, \@sys_locs, \@no_sys_locs, \@extra_vars);

    $bag->set_plan_for(@requires);

    if(defined $dot_output) {
        $bag->dot_graph($dot_output);
    }

    if($bag->dry_run) {
        exit 0;
    }

    if(defined $parallel_dir) {
        $bag->to_parallel($parallel_dir);
        $bag->check_manual_requirements();

        $bag->set_plan_for('cctools-statics');
        $ignore_locks = 1;
    }

    $bag->execute_plan($sh_on_error, $force_rebuild, $ignore_locks);

    my $exit_code;
    if($no_run) {
        $exit_code = 0;
    } elsif($env_to) {
        $bag->set_environment($env_to, @command_and_args);
        $exit_code = 0;
    } else {
        $exit_code = $bag->execute(@command_and_args);
    }

    exit $exit_code;
}

sub print_modules_used {
    my $file = "stub-debug-modules.txt";

    unlink "$vc3_distfiles/$file";

    File::Path::make_path($vc3_distfiles);

    my $ff       = HTTP::Tiny->new();
    my $url      = $vc3_repository . '/' . $file;
    my $output   = $vc3_distfiles  . '/' . $file;

    # dummy calls to trigger the use of the http module.
    my $response_a = $ff->mirror($url, $output);
    my $response_b = $ff->mirror($url, $output);

    my @modules = grep { /\.pm$/ } keys %INC;

    # add modules that %INC sometimes does not find:
    @modules = (@modules, qw/strict PerlIO encoding Digest::Perl::MD5/);

    # turn :: into /
    map { s^/^::^g }   @modules;

    # remove .pm extension
    map { s^\.pm$^^g } @modules;

    # remove duplicates
    @modules = uniq_words(@modules);

    @modules = sort { uc($a) cmp uc($b) } @modules;

    print join("\n", @modules), "\n";
}

sub uniq_words {
    my %words;
    for my $word (@_) {
        $words{$word} = 1;
    }

    return keys %words;
}

package VC3::Bag; 

use Carp qw/carp croak/;
use English qw/-mo_match_vars/;
use File::Copy;
use File::Spec ();
use File::Temp qw/tempfile/;
use FindBin  qw/$RealBin $RealScript/;
use JSON::Tiny;
use List::Util qw/max/;
use POSIX ();
use version ();

sub new {
    my ($class, $dry_run, $interactive_run, $silent, $databases, $sys_locs, $no_sys_locs, $extra_vars) = @_;

    my $self = bless {}, $class;

    $self->{dry_run}         = $dry_run;
    $self->{interactive_run} = $interactive_run;
    $self->{silent_run}      = $silent;

    $self->set_builder_variables();

    $self->{sources} = $self->decode_bags($databases);

    $self->{no_system} = { map { ( $_ => 1 ), } @{$no_sys_locs} };

    $self->add_manual_variables($extra_vars);
    $self->add_manual_packages($sys_locs);

    return $self;
}

sub check_manual_requirements() {
    my ($self) = @_;

    my @restricted_unmet;
    for my $w (@{$self->{order}}) {
        my $msg = $w->msgs_manual_requirements();
        if($msg) {
            $self->activate_widget($w);
            push @restricted_unmet, $w->msgs_manual_requirements();
        }
    }

    if(@restricted_unmet > 0) {
        my ($pid, $build_in) = $self->shell();

        print { $build_in } "cat <<EOF\n";

        for my $msg (@restricted_unmet) {
            for my $line (@{$msg}) {
                print { $build_in } "$line\n";
            }
            print { $build_in } "\n";
        }

        print { $build_in } "EOF\n";
        print { $build_in } "exit 0\n";

        die;
    }

    return 1;
}


sub active_widgets {
    my ($self) = @_;

    unless($self->{active_widgets}) {
        my %new;
        tie %new, 'Tie::RefHash';

        $self->{active_widgets} = \%new;
    }

    return $self->{active_widgets};
}

sub activate_widget {
    my ($self, $widget) = @_;
    $self->active_widgets->{$widget} = 1;
}

sub set_builder_variables {
    my ($self) = @_;

    $self->{environment_variables} = [];

    $self->set_machine_vars();

    # expand ~
    $vc3_root      = glob $vc3_root;
    $vc3_distfiles = glob $vc3_distfiles;
    $vc3_user_home = glob $vc3_user_home;

    # to absolute paths
    $vc3_root      = File::Spec->rel2abs(${vc3_root});
    $vc3_distfiles = File::Spec->rel2abs(${vc3_distfiles});
    unless(File::Spec->file_name_is_absolute($vc3_user_home)) {
        $vc3_user_home = File::Spec->join($vc3_root, $vc3_user_home);
    }

    my $tmp_dir = "$vc3_root/tmp";

    $self->root_dir($vc3_root);

    $self->home_dir($vc3_user_home);
    $self->tmp_dir($tmp_dir);

    $self->builder_path("$RealBin/$RealScript");

    File::Path::make_path($self->root_dir);
    File::Path::make_path($vc3_distfiles);
    File::Path::make_path(File::Spec->join($vc3_distfiles, 'manual-distribution'));
    File::Path::make_path($self->home_dir);
    File::Path::make_path($self->tmp_dir);

    my ($profile_f, $profile_name) = tempfile(File::Spec->join($self->home_dir, '.vc3_sh-XXXXXX'));
    close $profile_f;
    $self->sh_profile($profile_name);
    push @cleanups, sub { $self->cleanup() };

    $self->add_builder_variable('VC3_ROOT',         $vc3_root);
    $self->add_builder_variable('VC3_DISTFILES',    $vc3_distfiles);
    $self->add_builder_variable('VC3_BUILDER_PATH', $self->builder_path);
    $self->add_builder_variable('HOME',             $self->home_dir);
    $self->add_builder_variable('TMP',              $self->tmp_dir);
    $self->add_builder_variable('TERM',             'linux');
    $self->add_builder_variable('USER',             getlogin() || $ENV{'USER'} || 'vc3-user');
}

sub DESTROY {
    my ($self) = @_;
    $self->cleanup();
}

sub root_dir {
    my ($self, $root) = @_;

    $self->{root_dir} = $root if($root);

    return $self->{root_dir};
}

sub home_dir {
    my ($self, $home) = @_;

    $self->{home_dir} = $home if($home);

    return $self->{home_dir};
}

sub tmp_dir {
    my ($self, $tmp) = @_;

    $self->{tmp_dir} = $tmp if($tmp);

    return $self->{tmp_dir};
}

sub plan {
    my ($self, $new) = @_;

    $self->{plan} = $new if($new);

    return $self->{plan};
}

sub builder_path {
    my ($self, $new) = @_;

    $self->{builder} = $new if($new);

    return $self->{builder};
}


sub sh_profile {
    my ($self, $init) = @_;

    $self->{sh_profile} = $init if($init);

    return $self->{sh_profile};
}

sub dry_run {
    my ($self) = @_;
    return $self->{dry_run};
}

sub environment_variables {
    my ($self, $new_vars) = @_;

    $self->{environment_variables} = $new_vars if($new_vars);

    return $self->{environment_variables};
}

sub add_builder_variable {
    my ($self, $name, $value) = @_;

    my $var = {
        name     => $name,
        value    => $value,
        clobber  => 1,
        absolute => 1
    };

    my $vars = $self->environment_variables;
    push @{$vars}, $var;

    return $var;
}

sub add_manual_variables {
    my ($self, $extra_vars) = @_;

    for my $var (@{$extra_vars}) {
        $var =~ m/
        ^
        (?<name>[A-Za-z_][A-Z-a-z_0-9]*)
        =
        (?<value>.*)
        $
        /x or die "Malformed variable specification: '$var'";

        $self->add_builder_variable($+{name}, $+{value});
    }
}

sub add_manual_packages {
    my ($self, $specs) = @_;

    for my $spec (@{$specs}) {
        $spec =~ m/
        ^
        (?<name>[A-Za-z_][A-Z-a-z_0-9]*)
        :
        (?<version>([0-9]+(\.?[0-9]){0,2}))
        =
        (?<dir>.*)
        $
        /x or die "Malformed manual specification: '$spec'\n";

        my ($name, $version, $dir) = @+{qw(name version dir)};

        my $s = {};
        $s->{version} = $version;
        $s->{sources} = [
            {
                type => 'system',
                'recipe' => [
                    "echo VC3_ROOT_SYSTEM: $dir"
                ]
            }
        ];

        my $widgets;
        eval { $widgets = $self->widgets_of($name) };
        if($@) {
            die "Could not find specification to overwrite for '$name'\n";
        }

        unshift @{$widgets}, VC3::Widget->new($self, $name, $s);
    }
}

sub del_builder_variable {
    my ($self, $name) = @_;

    my @vars = @{$self->environment_variables};
    @vars = grep { $name ne $_->{name} } @vars;

    $self->environment_variables(\@vars);
}

sub set_plan_for {
    my ($self, @requires) = @_;

    $self->{indent_level} = 0;

    my $plan = VC3::Plan->new($self);
    $self->plan($plan);

    if(!$plan->add_main_targets(@requires)) {
        die("Could not find an installation plan.\n");
    }

    $self->{ords} = $plan->order();
    my @ordered = sort { ($self->{ords}{$a} <=> $self->{ords}{$b}) || ($a cmp $b) } keys %{$self->{ords}};
    $self->{order} = [ map { $plan->elements->{$_}{widget} } @ordered ];

    return $plan;
}

sub execute_plan {
    my ($self, $sh_on_error, $force_rebuild, $ignore_locks) = @_;

    $self->check_manual_requirements();

    for my $w (@{$self->{order}}) {
        $self->build_widget($w, $sh_on_error, $force_rebuild, $ignore_locks);
        $self->activate_widget($w);
    }
}

sub cleanup {
    my ($self) = @_;

    if($self->{child_pid}) {
        $self->say('Cleaning payload with pid: ' . $self->{child_pid});
        kill 'TERM', -$self->{child_pid};
    }

    if(-f $self->sh_profile) {
        unlink $self->sh_profile;
    }

    my $cmd_file = $self->sh_profile . '.cmd';
    if(-f $cmd_file) {
        unlink $cmd_file;
    }

    if($self->{child_pid}) {
        # give 10 seconds for child to cleanup TERM, then REDRUM
        for my $i (1..5) {
            my $n = kill 0, -$self->{child_pid};
            if($n) {
                $self->say('Waiting for payload with pid: ' . $self->{child_pid} . "  $n");
                sleep(2);
            } else {
                $self->{child_pid} = undef;
                return;
            }
        }
        $self->say('Hard terminating for payload with pid: ' . $self->{child_pid});
        kill 'KILL', -$self->{child_pid};
        $self->{child_pid} = undef;
    }
}

sub set_machine_vars {
    my ($self) = @_;

    ($self->{osname}, undef, undef, undef, $self->{architecture}) = POSIX::uname();

    $self->{target} = $self->architecture . '/' . $self->distribution;

    my $ldd_version_raw = qx(ldd --version);
    $ldd_version_raw =~ /
    # we are looking for a line starting with 'ldd'
    ^ldd
    # followed by anything
    .*
    # followed by at least one space
    \s+
    # followed by the version number (that we capture)
    ([0-9.]+)
    # followed by any number of spaces at the end of the line
    \s*$
    # options: x allows regexp comments. m treats each line indepedently
    /xm ;

    $self->{glibc_version} = $1
    || 'unknown';

    $self->add_builder_variable('VC3_MACHINE_OS',            $self->osname);
    $self->add_builder_variable('VC3_MACHINE_ARCH',          $self->architecture);
    $self->add_builder_variable('VC3_MACHINE_GLIBC_VERSION', $self->glibc_version);
    $self->add_builder_variable('VC3_MACHINE_TARGET',        $self->{target});
}

sub target {
    my ($self) = @_;
    return $self->{target};
}

sub osname {
    my ($self) = @_;
    return $self->{osname};
}

sub architecture {
    my ($self) = @_;
    return $self->{architecture};
}

sub glibc_version {
    my ($self) = @_;
    return $self->{glibc_version};
}

# reads /etc/readhat-release and transforms something like:
# 'Red Hat Enterprise Linux Server release 6.5 (Santiago)'
# into 'redhat6'.
sub distribution {
    my ($self) = @_;

    my $distribution='generic';
    
    if (-f '/etc/redhat-release') {
        open (my $file_fh, '<', '/etc/redhat-release');
        my $redhat_version_line = <$file_fh>;

        $redhat_version_line =~ /\brelease\b\s+([0-9]+)\b/;
        my $redhat_version = $1;

        die 'Could not find redhat version!' unless $redhat_version;

        $distribution="redhat${redhat_version}"
    }
    
    return $distribution;
}

sub widgets_of {
    my ($self, $name) = @_;

    my $widgets = $self->{sources}{$name}
    || die "I do not know anything about '$name' . \n";

    return $widgets;
}

sub decode_bags {
    my ($self, $databases) = @_;

    my $sources = {};

    for my $filename (@{$databases}) {
        $self->decode_bag($sources, $filename);
    }

    return $sources;
}

sub decode_bag {
    my ($self, $sources, $filename) = @_;

    {
        no warnings;
        if($filename eq '<internal>' && tell(VC3::Builder::DATA) == -1) {
            $filename = './vc3-catalog.json';
            return $sources unless -f $filename; 
        }
    }

    my $catbag_f;
    if($filename eq '<internal>') {
        $catbag_f = *VC3::Builder::DATA;
    } else {
        open($catbag_f, '<:encoding(UTF-8)', $filename) ||
        die "Could not open '$filename': $!";
    }

    my $contents = do { local($/); <$catbag_f> };
    close($catbag_f);

    my $bag_raw = JSON::Tiny::decode_json($contents);

    for my $widget_name (keys %{$bag_raw}) {
        my @versions = map { VC3::Widget->new($self, $widget_name, $_) } @{$bag_raw->{$widget_name}};
        $sources->{$widget_name} = \@versions;
    }

    return $sources;
} 

sub build_widget {
    my ($self, $widget, $sh_on_error, $force_rebuild, $ignore_locks) = @_;

    $self->say("processing for @{[$widget->name]}-" . $widget->version->normal);

    my $s = $widget->active_source;

    my $exit_status = 0;
    if($s) {
        eval { $exit_status = -1; $exit_status = $s->execute_recipe($force_rebuild, $ignore_locks) };

        if($exit_status) {
            $widget->process_error($sh_on_error, $EVAL_ERROR, $exit_status);
            exit 1;
        }
    }

    return $exit_status;
}

sub dot_graph {
    my ($self, $dotname) = @_;
    return $self->plan->dot_graph($dotname);
}

sub to_parallel {
    my ($self, $dir) = @_;

    my $abs_dir;
    if(File::Spec->file_name_is_absolute($dir)) {
        $abs_dir = $dir;
    } else {
        $abs_dir = File::Spec->join($self->home_dir, $dir);
    }

    my $dag_name       = 'dag';
    my $builder_name   = 'builder';
    my $local_database = 'recipes';

    File::Path::make_path($abs_dir);

    open my $script_f, '>', "$abs_dir/build" || die "Could not open '$abs_dir/build' for writing: $!";
    print { $script_f } <<EOFF;
#! /bin/sh
set -e

makeflow --shared-fs @{[$self->root_dir]} -r 5 $dag_name "\$@"

cat <<EOF
To run, from the current directory type:

./$builder_name --database $local_database --install @{[$self->root_dir]} @{[map { "--require $_" } @{$self->plan->requirements}]}

EOF
EOFF

    close $script_f;
    chmod 0755, "$abs_dir/build";

    copy($self->builder_path, "$abs_dir/$builder_name");
    chmod 0755, "$abs_dir/$builder_name";

    $self->plan->to_makeflow($abs_dir, $dag_name, $builder_name, $local_database);
}

sub set_environment_variables {
    my ($self, $sh_f) = @_;

    my $env = $self->active_widgets();

    my $expansion = {};

    for my $var (@{$self->environment_variables}) {
        $expansion->{$var->{name}} = [$var->{value}];
    }

    for my $wid (@{$self->{order}}) {
        next unless $env->{$wid};
        $wid->consolidate_environment_variables($expansion);
    }

    $expansion->{'PATH'} ||= [];

    # use default PATH:
    push @{$expansion->{'PATH'}}, $ENV{'PATH'} || '/bin:/usr/bin';

    for my $var_name (keys %{$expansion}) {
        eval { $expansion->{$var_name} = join(':', @{$expansion->{$var_name}}) };
        if($@) {
            carp("Environment variable '$var_name' is not defined.");
        }
    }

    my @ordered = $self->order_variables($expansion);

    for my $var_name (@ordered) {
        my $value = $expansion->{$var_name};
        print { $sh_f } "export $var_name=\"$value\"\n";
    }
}

sub order_variables {
    my ($self, $expansion) = @_;

    my @alpha = sort { $a cmp $b } keys %{$expansion};

    my $order = {};

    my $index = 1;
    for my $var (@alpha) {
        $order->{$var} = $index;
        $index++;
    }

    my $total_passes = 0;
    my $swap       = 1;

    while($swap) {
        $swap = 0;

        my @ordered = sort { ($order->{$a} <=> $order->{$b}) || ($a cmp $b) } keys %{$expansion};

        for my $var (@ordered) {
            my $value = $expansion->{$var};
            my @deps  = ($value =~ m/\$\{(\w+)\}/g);

            next unless @deps;

            my $org   = $order->{$var};
            my $nxt   = 1 + max(map { $order->{$_} || carp "Variable '$_' is not defined." } @deps);

            if($nxt > $org) {
                $swap++;
                $order->{$var} = $nxt;
            }
        }

        $total_passes++;
        carp "Cyclic dependency in environment variables." if $total_passes > @alpha;
    }

    my @ordered = sort { ($order->{$a} <=> $order->{$b}) || ($a cmp $b) } keys %{$expansion};
    return @ordered;
}


sub set_wrapper {
    my ($self, $wrapper_file, $profile_file) = @_;

    my $env = $self->active_widgets();

    my $payload = "/bin/sh -c '. $profile_file'";
    for my $w (@{$self->{order}}) {
        next unless $env->{$w};

        my $wrap = $w->wrapper;

        next unless $wrap;

        if( $wrap =~ /\{\}/ ) {
            $wrap =~ s/\{\}/$payload/;
            $payload = $wrap;
        } else {
            $payload = $wrap . ' ' . $payload;
        }
    }


    # write to $env_file
    open(my $sh_f, '>', "$wrapper_file")
    || die "Could not open file $wrapper_file: $!";

    print { $sh_f } "#!/usr/bin/env -i /bin/sh\n\n";

    $self->set_environment_variables($sh_f);

    print { $sh_f } "\ncd '" . $self->home_dir . "'\n";
    print { $sh_f } "exec $payload\n\n";
    return $payload;
}

sub consolidate_prologue {
    my ($self) = @_;

    my $env = $self->active_widgets();

    my @progs = ("cd '" . $self->home_dir . "'");

    for my $w (@{$self->{order}}) {
        next unless $env->{$w};

        if($w->prologue) {
            push @progs, @{$w->prologue};
        }
    }

    return \@progs;
}

sub set_profile {
    my ($self, $profile_file, @command_and_args) = @_;

    # write to $profile
    open(my $profile_f, '>', $profile_file)
    || die "Could not open file '$profile_file': $!";

    print { $profile_f } "#!/bin/sh\n\n";

    my $prologue = $self->consolidate_prologue();
    for my $line (@{$prologue}) {
        print { $profile_f } "$line\n";
    }

    if(@command_and_args) {
        print { $profile_f } join(' ', 'exec', @command_and_args, "\n");
    }
    close $profile_f;
}

sub set_environment {
    my ($self, $wrapper_file, @command_and_args) = @_;

    $wrapper_file = $self->sh_profile;
    my $profile_file = "$wrapper_file.cmd";

    $self->set_profile($profile_file, @command_and_args);
    $self->set_wrapper($wrapper_file, $profile_file);
}


sub execute {
    my ($self, @command_and_args) = @_;

    $self->set_environment($self->sh_profile, @command_and_args);

    my $pid = fork();

    if($pid == 0) {
        my @args = (
            '/usr/bin/env',
            '-i',
            '/bin/sh',
            '-c',
            ". " . $self->sh_profile);

        POSIX::setpgid(0, 0);

        exec { $args[0] } @args;
        die 'Could not exec payload';
    } elsif($pid > 0) {

        close(STDIN);
        close(STDOUT);
        POSIX::setpgid($pid, $pid);

        if($self->{interactive_run}) {
            $self->bring_to_foreground($pid);
        }

        $self->{child_pid} = $pid;
        waitpid $pid, 0;
        my $status = $?;
        $self->{child_pid} = undef;

        return POSIX::WEXITSTATUS($status);
    } else {
        die 'Could not fork to exec payload: ' . $!;
    }
}

sub bring_to_foreground {
    my ($self, $groupid) = @_;

    $SIG{TTOU} = 'IGNORE';

    open my $term, '+<', '/dev/tty';
    return unless $term;

    POSIX::tcsetpgrp(fileno($term), $groupid) or die "Could not bring child to foreground: $!";

    close $term;
}

sub shell {
    my ($self, $payload) = @_;

    $payload |= '/bin/sh';
    $self->set_environment($self->sh_profile, $payload);

    my $pid = open(my $input, '|-');
    if($pid == 0) {
        my @args = (
            '/usr/bin/env',
            '-i',
            '/bin/sh',
            '-c',
            ". " . $self->sh_profile);
        exec { $args[0] } @args;
        die 'Could not exec shell';
    } elsif($pid > 0) {
        $self->{child_pid} = $pid;
        # wait for this shell later.
    } else {
        die 'Could not fork to exec payload: ' . $!;
    }

    return ($pid, $input);
}

sub shell_user {
    my ($self) = @_;
    return $self->execute('/bin/sh');
}

sub say {
    my ($self, @rest) = @_;

    return if($self->{silent_run});

    print( ('.' x (2*$self->{indent_level})), join(' ', @rest), "\n");
}


package VC3::Widget;
use Carp;
use POSIX ":sys_wait_h";
use IO::Handle;
use Digest::Perl::MD5 qw(md5_hex);
use Cwd;
use File::Temp qw/tempdir/;
use Data::Dumper;


use JSON::Tiny;

# Attributes:
# name, version, sources, dependencies, environment_variables
sub new {
    my ($class, $bag, $name, $json_description) = @_;

    my $self = bless {}, $class;

    $self->bag($bag);
    $self->name($name);
    $self->version($json_description->{version});
    $self->sources($json_description->{sources});
    $self->dependencies($json_description->{dependencies});
    $self->wrapper($json_description->{wrapper});
    $self->prologue($json_description->{prologue});
    $self->environment_variables($json_description->{environment_variables});
    $self->phony($json_description->{phony});

    $self->add_widget_variable('ROOT',    $self->root_dir);

    my $majmin = $self->version->normal;
    $majmin =~ s/^v([0-9]+\.[0-9]+)\..*/$1/;

    $self->add_widget_variable('VERSION', $majmin);

    return $self;
}

sub add_widget_variable {
    my ($self, $varname, $value) = @_;

    my $vars    = $self->environment_variables || [];

    $varname = $self->widget_var($varname);

    my $var = {
        name     => $varname,
        value    => $value,
        clobber  => 1,
        absolute => 1
    };
    unshift @{$vars}, $var;

    $self->environment_variables($vars);
}

sub widget_var {
    my ($self, $varname) = @_;

    my $expanded = "VC3_${varname}_" . uc($self->name);

    # replace - with _, as env vars cannot have - in their names.
    $expanded =~ s/-/_/g;

    return $expanded;
}

sub bag {
    my ($self, $new_bag) = @_;

    $self->{bag} = $new_bag if($new_bag);

    croak 'No bag given'
    unless($self->{bag}); 

    return $self->{bag};
}

sub ribbon {
    my ($self) = @_;

    unless($self->{ribbon}) {
        $self->{ribbon} = VC3::Ribbon->new($self->name, $self->bookeeping_dir, $self->bag->tmp_dir, $self->checksum);
    }

    return $self->{ribbon};
}

sub name {
    my ($self, $new_name) = @_;

    if($new_name) {
        # names can only contain letters, numbers, - and _.
        my @badchars = ($new_name =~ /([^A-Za-z0-9-_])/g);
        if(@badchars) {
            die "The name '$new_name' containes the following disallowed charactares: " 
            . join ', ', map { "'$_'" } @badchars;
        } else {
            $self->{name} = $new_name if($new_name);
        }
    }

    die 'No name given'
    unless($self->{name}); 

    return $self->{name};
}

sub version {
    my ($self, $new_version) = @_;

    if($new_version) {
        $self->{version} = version->declare($new_version);
    }

    unless($self->{version}) {
        croak 'No version given';
    }

    return $self->{version};
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    $self->{dependencies} = $new_dependencies if($new_dependencies);

    return $self->{dependencies};
}

sub sources {
    my ($self, $new_sources) = @_;

    if($new_sources) {
        my @sources = map { VC3::Source->new($self, $_) } @{$new_sources};
        $self->{sources} = \@sources;
    }

    return $self->{sources};
}

sub active_source {
    my ($self, $source) = @_;

    if($source) {
        $self->{active_source} = $source;
        $self->checksum($source);
    }

    return $self->{active_source};
}

sub prologue {
    my ($self, $new_prologue) = @_;

    $self->{prologue} = $new_prologue if($new_prologue);

    return $self->{prologue};
}

sub wrapper {
    my ($self, $new_wrapper) = @_;

    $self->{wrapper} = $new_wrapper if($new_wrapper);

    return $self->{wrapper};
}


sub environment_variables {
    my ($self, $new_vars) = @_;

    $self->{environment_variables} = $new_vars if($new_vars);

    return $self->{environment_variables};
}

sub phony {
    my ($self, $new_phony) = @_;

    $self->{phony} = $new_phony if($new_phony);

    return $self->{phony};
}

sub root_dir {
    my ($self, $new) = @_;

    my $old = $self->{root_dir};

    if($new) {
        $self->{root_dir} = $new;
    }

    unless($self->{root_dir}) {
        my $rel = join('/', map { "$_" } ($self->bag->target, $self->name, $self->version->normal));

        $self->{root_dir} = File::Spec->rel2abs($vc3_root) . '/' . $rel;
    }

    if(!$old || $old ne $self->{root_dir}) {
        $self->add_widget_variable('ROOT', $self->{root_dir});
    }

    return $self->{root_dir};
}

sub bookeeping_dir {
    my ($self, $relative) = @_;

    my $rel = join('/', map { "$_" } ($self->bag->target, $self->name, $self->version->normal));

    if($relative) {
        return $rel;
    }

    return File::Spec->rel2abs($vc3_root) . '/' . $rel;
}

sub build_dir {
    my ($self) = @_;

    unless($self->{build_dir}) {
        my $root     = File::Spec->rel2abs($vc3_root) . '/builds';

        unless(-d $root) {
            File::Path::make_path($root);
        }

        my $template = $root . '/' . $self->name . '.XXXXXX';

        my $tmpdir   = File::Temp::tempdir($template, CLEANUP => 1);
        $self->{build_dir} = $tmpdir;
    }

    return $self->{build_dir};
}

sub build_log {
    my ($self) = @_;
    my $log_name = $self->bookeeping_dir . '/' . $self->name . '-build-log';

    return $log_name;
}

sub say {
    my $self = shift @_;

    return $self->bag->say(@_);
}

sub consolidate_environment_variables {
    my ($self, $expansion) = @_; 

    my $vars = $self->environment_variables
    || return;

    for my $var (reverse @{$vars}) {

        my $name = $var->{name}
        || carp "Environment variable does not have a name.";

        my $value = $var->{value}
        || carp "Environment variable '$name' did not define a value.";

        my $clobber  = $var->{clobber};
        my $absolute = $var->{absolute};

        if($expansion->{$name} && $clobber) {
            my @old_value = @{$expansion->{$name}};
            my $n = @old_value;
            if($n > 1) {
                carp("Asked to clobber variable '$name', but it already had a value.\n"
                    . "'$value' <> '" . join(',', @old_value) . "'\n");
            }
        }

        $expansion->{$name} ||= [];

        my @paths;
        if($clobber) {
            # when clobber, we use the value as is, and remove previous expansions.
            @paths = ($value);
            $expansion->{$name} = [];
        } else {
            # otherwise, split paths on :
            @paths = split /:/, $value;
        }

        my @current_expansions;
        for my $path (@paths) {
            if(!$absolute) {
                if($self->root_dir eq $self->bookeeping_dir) {
                    $path = '${' . $self->widget_var('ROOT') . '}/' . $path;
                } else {
                    $path = $self->root_dir . '/' . $path;
                }
            }

            push @current_expansions, $path;
        }

        unshift @{$expansion->{$name}}, @current_expansions;
    }
}

sub error_debug_info {
    my ($self, $eval_error) = @_;

    print "'", $self->name, "' failed to build for ", $self->bag->target, "\n";

    if($eval_error) {
        print $eval_error, "\n";
    }

    if(-f $self->build_log) {
        print "Last lines of log file:\n";
        system('tail', $self->build_log);
    }
}


sub process_error {
    my ($self, $sh_on_error, $eval_error, $status) = @_;

    if($eval_error || $status) {
        $self->error_debug_info($eval_error);

        if($sh_on_error) {
            warn $@ if $@;

            my $cwd = getcwd();

            $self->bag->shell_user();

            chdir $cwd;
        }
    }
}

sub checksum {
    my ($self, $load) = @_;

    if(!$self->{checksum}) {
        $load ||= 'no source';

        my $txt = $self->hash_to_canonical_str($load);
        my $dgt = md5_hex($txt);

        $self->{checksum} = $dgt;
    }

    return $self->{checksum};
}

sub hash_to_canonical_str {
    my ($self, $ref) = @_;

    my $str;

    if(ref($ref) eq 'HASH') {
        my @ks = sort { $a cmp $b } keys %{$ref};

        $str 
        = '{'
        . join(',', map { $_ .  ':' . $self->hash_to_canonical_str($ref->{$_}) } @ks)
        . '}';
    } elsif(ref($ref) eq 'ARRAY') {
        $str 
        = '['
        . join(',', map { $self->hash_to_canonical_str($_) } @{$ref})
        . ']';
    } else {
        $str = $ref;
    }

    return $str;
}


sub msgs_manual_requirements {
    my ($self) = @_;

    my $sources = $self->sources;

    my @restricted_unmet;
    for my $source (@{$sources}) {
        unless($source->check_manual_requirements()) {
            push @restricted_unmet, $source->msg_manual_requirement();
        }
    }

    return @restricted_unmet;
}


sub prepare_recipe_sandbox {
    my ($self, $no_erase) = @_;

    # clear build directory, to avoid bugs from uncleaned sources.
    my $build = $self->build_dir;
    if( -d $build ) {
        File::Path::rmtree($build);
    }

    # clear destination directory, to make sure we are running what we believe
    # we are running.
    unless($no_erase) {
        my $dir = $self->root_dir;
        if( -d $dir ) {
            File::Path::rmtree($dir);
        }

        if($self->root_dir ne $self->bookeeping_dir) {
            my $dir = $self->bookeeping_dir;
            if( -d $dir ) {
                File::Path::rmtree($dir);
            }
        }
    }

    # create the dirs we removed above.
    File::Path::make_path($self->build_dir);
    File::Path::make_path($self->root_dir);
    File::Path::make_path($self->bookeeping_dir);

    # make sure tmp dir exists
    File::Path::make_path($self->bag->tmp_dir);

    # set the destination directory as an environment variable before
    # setting up the shell, so that the child created inherets it.
    $self->bag->add_builder_variable('VC3_PREFIX', $self->root_dir);
    $self->bag->add_builder_variable('VC3_BUILD',  $self->build_dir);
}

sub cleanup_recipe_sandbox {
    my ($self, $result) = @_;

    $self->bag->del_builder_variable('VC3_PREFIX');
    $self->bag->del_builder_variable('VC3_BUILD');

    if($result eq '0') {
        File::Path::rmtree($self->build_dir);
        $self->ribbon->commit('DONE');
    }

    # we do not delete the buildir in case of error, to ease debugging.
}

sub setup_build_shell {
    my ($self, @log_messages) = @_;

    # log the recipe used. Since we are opening sh with -e, the recipe executes
    # as if all steps were &&-ed together.
    open(my $build_log, '>', $self->build_log);
    print { $build_log } join("\n && ", @log_messages . "\n");
    close $build_log;

    # open sh with -e. This terminates the shell at the first step that returns
    # a non-zero status.
    my ($pid, $build_in) = $self->bag->shell();

    croak 'Could not open /bin/sh for building.'
    unless $build_in;

    # redirect all output to our log file.
    print { $build_in } 'exec 1>> ' . $self->build_log . "\n";
    print { $build_in } "exec 2>&1\n";
    print { $build_in } "set -ex\n";

    # return the stdin of the shell, and the pid so we can wait for it.
    return ($pid, $build_in);
}

sub shell {
    my ($self) = @_;
    return $self->bag->shell();
}

package VC3::Ribbon;

use File::Basename; 
use LockFile::Simple qw(lock unlock);

sub new {
    my ($class, $name, $install_dir, $tmpdir, $checksum) = @_;

    my $self = bless {}, $class;

    $self->{filename} = $install_dir . '/.VC3_DEPENDENCY_BUILD';
    $self->{lockname} = $tmpdir . '/' . $name . '.lock';
    $self->{checksum} = $checksum;

    $self->{lockmgr} = LockFile::Simple->make(-hold => 3600, -autoclean => 1, -max => 99999, -delay => 5, -stale => 1, -wmin => 2,
        -wfunc => sub { LockFile::Simple::core_warn("Waiting for a lock for '$name'. If you think this lock is stale, please remove the file:\n'" . $self->{lockname} . "'\n") }
    );

    return $self;
}

sub commit {
    my ($self, $state) = @_;

    my $ribbon_fh = IO::Handle->new();
    open ($ribbon_fh, '>', $self->{filename});

    my $report = {};
    $report->{state}    = $state;
    $report->{checksum} = $self->{checksum};
    $report->{time}     = time();

    printf { $ribbon_fh } JSON::Tiny::encode_json($report);

    $ribbon_fh->flush();
    $ribbon_fh->sync();

    $ribbon_fh->close();
}

sub set_lock {
    my ($self) = @_;

    # make sure parent directory exists
    File::Path::make_path( dirname($self->{filename}) );

    $self->{lockobj} = $self->{lockmgr}->lock($self->{filename}, $self->{lockname});
}

sub release_lock {
    my ($self) = @_;
    $self->{lockobj}->release();
}

sub state {
    my ($self) = @_;

    my $name = $self->{filename};
    my $state = 'MISSING';

    if(-f $name) {
        open my $ribbon_fh, '<', $name || warn $!;

        if($ribbon_fh) {
            my $contents = do { local($/); <$ribbon_fh> };
            close($ribbon_fh);

            my $report;
            eval { $report = JSON::Tiny::decode_json($contents) };
            if($@) {
                $state = 'MISSING';
            }

            if(!$report->{state}) {
                $state = 'MISSING';
            #} elsif(!$report->{checksum}) {
            #     $state = 'MISSING';
            # } elsif($report->{checksum} ne $self->{checksum}) {
            # $state = 'OUT_OF_DATE';
            } elsif($report->{state} eq 'PROCESSING') {
                $state = 'PROCESSING';
            } else {
                $state = $report->{state};
            }
        }
    }

    return $state;
}

package VC3::Source;
use Carp;

sub new {
    my ($class, $widget, $source_raw) = @_;

    my $source;

    if($source_raw->{type} eq 'generic') {
        $source = VC3::Source::Generic->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'tarball') {
        $source = VC3::Source::Tarball->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'manual-distribution') {
        $source = VC3::Source::ManualDist->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'binary') {
        $source = VC3::Source::Binary->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'system') {
        $source = VC3::Source::System->new($widget, $source_raw);
    }
    else {
        croak "Do not know about source type '" . $source_raw->{type} . "' for '" . $widget->name . "'";
    }

    return $source;
}

package VC3::Source::Generic;
use Carp;
use File::Copy;
use File::Path;
use File::Spec;
use HTTP::Tiny;
use POSIX ":sys_wait_h";
use parent;

sub new {
    my ($class, $widget, $json_description) = @_;

    my $self = bless {}, $class;

    $self->widget($widget);
    $self->recipe($json_description->{recipe});
    $self->files($json_description->{files});
    $self->msg_manual_requirement($json_description->{msg_manual_requirement});
    $self->dependencies($json_description->{dependencies});
    $self->prerequisites($json_description->{prerequisites});

    $self->{type} = $json_description->{type};

    return $self;
}

sub phony {
    my ($self) = @_;

    return 0;
}

sub widget {
    my ($self, $new_widget) = @_;

    $self->{widget} = $new_widget if($new_widget);

    croak 'No argument given'
    unless($self->{widget}); 

    return $self->{widget};
}

sub recipe {
    my ($self, $new_recipe) = @_;

    $self->{recipe} = $new_recipe if($new_recipe);

    croak 'No recipe given'
    unless($self->{recipe}); 

    return $self->{recipe};
}

sub files {
    my ($self, $new_files) = @_;

    $self->{files} = $new_files if($new_files);

    if($self->{files}) {
        return $self->{files};
    } else {
        return [];
    }
}

sub msg_manual_requirement {
    my ($self, $new_message) = @_;

    if($new_message) {
        $self->{msg_manual_requirement} = $new_message;
    }

    return $self->{msg_manual_requirement};
}

sub check_manual_requirements {
    my ($self, $new_message) = @_;

    # by default return true. Usually packages do not have manual requirements.
    return 1;
}

sub file_absolute {
    my ($self, $file) = @_;
    return File::Spec->rel2abs($vc3_distfiles . '/' . $file);
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    if($new_dependencies) {
        $self->{dependencies} = {};

        for my $name (keys %{$new_dependencies}) {
            my $versions = $new_dependencies->{$name};
            my ($min_version, $max_version) = @{$versions};

            if($min_version) {
                $min_version = version->declare($min_version);
            }

            if($max_version) {
                $max_version = version->declare($max_version);

                unless($min_version) {
                    $min_version = version->declare('v0.0.0');
                }
            }

            $self->{dependencies}{$name} = [];

            if($min_version) {
                push @{$self->{dependencies}{$name}}, $min_version;
            }

            if($max_version) {
                push @{$self->{dependencies}{$name}}, $max_version;
            }
        }
    }

    return $self->{dependencies};
}

sub prerequisites {
    my ($self, $new_prerequisites) = @_;

    $self->{prerequisites} = $new_prerequisites if($new_prerequisites);

    # by default return true. Usually packages do not have prerequisites.
    return $self->{prerequisites};
}

sub check_prerequisites {
    my ($self) = @_;

    # by default return true. Usually packages do not have prerequisites.
    unless($self->prerequisites()) {
        return 0;
    }

    my @steps = @{$self->prerequisites};

    my ($pid, $pre_in) = $self->widget->bag->shell();

    print { $pre_in } "exec 1>> /dev/null\n";
    print { $pre_in } "exec 2>&1\n";
    print { $pre_in } "set -ex\n";

    # add shifting to tmp directory as the first step.
    unshift @steps, 'cd ' . $self->widget->bag->tmp_dir;

    # add exiting cleanly from shell as a last step.
    push @steps, 'exit 0';

    for my $step (@steps) {
        print { $pre_in } "$step\n";
    }

    my $exit_status = -1;
    eval { close $pre_in; $exit_status = $? };

    if(!$@ && WIFEXITED($exit_status) && (WEXITSTATUS($exit_status) == 0)) {
        return 0;
    } else {
        return -1;
    }
}

sub say {
    my $self = shift @_;

    return $self->widget->say(@_);
}

sub get_file {
    my ($self, $file) = @_;

    unless(-f $self->file_absolute($file)) {
        $self->say("Downloading '" . $file . "' from $vc3_repository");

        #if make sure the destination directory exists
        File::Path::make_path($vc3_distfiles);

        my $ff = HTTP::Tiny->new();

        my $url    = $vc3_repository . '/' . $file;
        my $output = $vc3_distfiles  . '/' . $file;

        my $retries = 5;
        my $sleep_before_retry = 5; # seconds
        my $response;

        for my $i (1..$retries) {
            $response = $ff->mirror($url, $output);

            return if $response->{success};

            # 304 means file did not change from the last time we downloaded it
            return if $response->{status} == 304;

            # retries:
            # 408 is request timeout
            # 503 is service unavailable
            # 504 is a gatewat timeout
            # 524 is a cloudflare timeout
            # 599 is an internal exception of HTTP::Tiny, which may be a timeout too.

            if( grep { $response->{status} == $_ } (408,503,504,524,599) ) {
                print "Could not download '" . $file . "':\n" . "$response->{status}: $response->{reason}\n";
                print "$response->{content}\n" if $response->{content};
                print "Retrying @{[$retries - $i]} more time(s)\n"; 

                sleep $sleep_before_retry;

                next;
            }

            die "Could not download '" . $file . "':\n" . "$response->{status} $response->{reason}";
        }
    }
}

sub get_files {
    my ($self) = @_;

    my $files = $self->files;

    for my $file (@{$files}) {
        $self->get_file($file);
    }
}

sub prepare_files {
    my ($self, $build_dir) = @_;

    for my $file (@{$self->files}) {
        symlink($self->file_absolute($file), $build_dir . '/' . $file)
        || die "Could not link '" . $file . "' to build directory.\n";
    }
}


sub prepare_recipe_sandbox {
    my ($self) = @_;


    my $no_erase = $self->isa('VC3::Source::System');

    my $result = $self->widget->prepare_recipe_sandbox($no_erase);

    if($result == 0) {
        return 0;
    }

    # download to $vc3_distfiles the ingredient (i.e., input files) if missing.
    $self->get_files();

    # if generic, copy all files to build directory.
    # if tarball, expand first file to build directory, and copy the rest of
    # the files to build directory.
    $self->prepare_files($self->widget->build_dir);

    return 1;
}

sub cleanup_recipe_sandbox {
    my ($self, $result) = @_;
    return $self->widget->cleanup_recipe_sandbox($result);
}


sub execute_recipe {
    my ($self, $force_rebuild, $ignore_locks) = @_;

    my $result = 1;

    unless($ignore_locks) {
        $self->widget->ribbon->set_lock();
    }

    eval {
        my $state = $self->widget->ribbon->state;
        if($state eq 'DONE' && !$force_rebuild && !$self->widget->phony && !$self->phony) {
            $result = 0;
        } else {
            $self->say("preparing '" . $self->widget->name . "' for " . $self->widget->bag->target);
            if($self->widget->bag->dry_run) {
                $result = 0;
            } else {
                $self->prepare_recipe_sandbox();
                $result = $self->execute_recipe_unlocked();
                $self->cleanup_recipe_sandbox($result);
            }
        }
    };

    my $error_msg = $@;

    unless($ignore_locks) {
        $self->widget->ribbon->release_lock();
    }

    if($error_msg) {
        die $error_msg;
    }

    return $result;
}

sub execute_recipe_unlocked {
    my ($self) = @_;

    unless($self->isa('VC3::Source::System')) {
        $self->widget->ribbon->commit('PROCESSING');
    }

    my $result = -1;
    my ($pid, $build_in) = $self->setup_build_shell();

    my @steps = @{$self->recipe};

    # add shifting to build directory as the first step.
    unshift @steps, 'cd ' . $self->widget->build_dir;

    # add exiting cleanly from shell as a last step.
    push @steps, 'exit 0';

    $self->say("details: " .  $self->widget->build_log);

    for my $step (@steps) {
        my $date = gmtime();
        print { $build_in } ": $date\n";
        print { $build_in } "$step\n";
    }

    my $status = -1;
    eval { close $build_in; $status = $? };
    if($@) {
        carp $@;
    }

    $self->widget->{child_pid} = undef;

    if(!$@ && WIFEXITED($status) && (WEXITSTATUS($status) == 0)) {
        $result = 0;
    }

    return $result;
}

sub setup_build_shell {
    my ($self) = @_;
    return $self->widget->setup_build_shell(@{$self->recipe});
}

package VC3::Source::Tarball;
use base 'VC3::Source::Generic';
use Carp;

sub new {
    my ($class, $widget, $json_description) = @_;

    my $self = VC3::Source::Generic->new($widget, $json_description);

    unless($self->files) {
        croak "For type 'tarball', at least one file should be defined in the files list, and the first file in the list should be a tarball.";
    }

    $self = bless $self, $class;

    return $self;
}

sub prepare_files  {
    my ($self, $build_dir) = @_;

    # first file in $self->files is the tarball, by convention.
    my $tarball = @{$self->files}[0];
    $tarball = $self->file_absolute($tarball);

    system(qq/tar -C ${build_dir} --strip-components=1 -xpf ${tarball}/);
    die "Could not expand tarball $tarball.\n" if $?;

    # link in the rest of the input files.
    $self->SUPER::prepare_files($build_dir);
}

package VC3::Source::ManualDist;
use base 'VC3::Source::Generic';
use Carp;

sub get_file {
    my ($self, $file) = @_;

    unless(-f $self->file_absolute($file)) {
        die "Missing manual or restricted distribution file '$file'.\n";
    }
}

sub file_absolute {
    my ($self, $file) = @_;
    return File::Spec->rel2abs($vc3_distfiles . '/manual-distribution/'  . $file);
}

sub check_manual_requirements {
    my ($self) = @_;

    for my $file (@{$self->files}) {
        unless(-f $self->file_absolute($file)) {
            # check failed, return false
            return 0;
        }
    }

    return 1;
}

package VC3::Source::System;
use base 'VC3::Source::Generic';
use Carp;

sub phony {
    my ($self) = @_;

    return 1;
}

sub execute_recipe_unlocked {
    my ($self) = @_;

    my $output_filename = $self->widget->build_log;

    my $result;
    eval { $result = $self->SUPER::execute_recipe_unlocked(); };

    if($@) {
        die $@;
    } else {
        open(my $f, '<', $output_filename) || die 'Did not produce root directory file';
        my $root;
        while( my $line = <$f>) {
            if($line =~ m/^VC3_ROOT_SYSTEM:\s+(?<root>.*)$/) {
                $root = $+{root};
                chomp($root);
                # update root from widget with the new information:
                $self->widget->root_dir($root);
                last;
            }
        }
        close $f;
        if(!$root) {
            die 'Did not produce root directory information.';
        }
        $root = '' if $root eq '/';
    }

    return $result;
}

package VC3::Source::Binary;
use base 'VC3::Source::Generic';
use Carp;

# Right now, do the same as generic.

package VC3::Plan;
use JSON::Tiny;

sub new {
    my ($class, $bag, $parent) = @_;

    my $self = bless {}, $class;

    $self->bag($bag);

    $self->elements($parent && $parent->elements || {});

    return $self;
}

sub bag {
    my ($self, $new) = @_;

    if($new) {
        $self->{bag} = $new;
    }

    return $self->{bag};
}

sub say {
    my ($self, @rest) = @_;

    return $self->bag->say(@rest);
}

sub elements {
    my ($self, $new) = @_;

    if($new) {
        $self->{elements} = \%{ $new };
    }

    return $self->{elements};
}

sub element_of {
    my ($self, $name) = @_;

    return $self->elements->{$name};
}

sub requirements {
    my ($self) = @_;

    unless($self->{requirements}) {
        $self->{requirements} = [];
    }

    return $self->{requirements};
}

sub add_target {
    my ($self, $name, $min, $max) = @_;

    $self->bag->{indent_level}++;

    $self->say("Plan:    $name => [@{[$min || '']}, @{[$max || '']}]");

    my $available = $self->bag->widgets_of($name);
    for my $widget (@{$available}) {

        if($self->add_widget($widget, $min, $max)) {
            $self->bag->{indent_level}--;
            return 1;
        }
    }

    $self->say("Failure: $name => [@{[$min || '']}, @{[$max || '']}]");
    $self->bag->{indent_level}--;

    return 0;
}

sub add_main_targets {
    my ($self, @requires) = @_;

    my $root_entry = { version => 'v0.0.1', phony => 1, dependencies => {} };

    for my $req (@requires) {
        my ($name, $min, $max) = $self->parse_requirement($req);

        my $versions = [];
        push @{$versions}, $min if($min);
        push @{$versions}, $max if($max);

        $root_entry->{dependencies}{$name} = $versions;
        
        unless($self->add_target($name)) {
            die "Could not find plan for $req.\n";
        }

        push @{$self->requirements}, $name;
    }

    return 1;
}

sub parse_requirement {
    my ($self, $req) = @_;

    $req =~ m/
    ^
    (?<name> [A-z0-9_-]+)
    (:                      # start of min version
    (?<min> [^:]*)
    (:                      # start of max version
    (?<max> [^:]*)
    )?)?
    $
    /x;

    my ($name, $min, $max) = ($+{name}, $+{min}, $+{max});

    if(!$min && $max) {
        $min = 'v0.0.0';
    }

    # turn into version strings
    $min = version->declare($min) if($min);
    $max = version->declare($max) if($max);

    return ($name, $min, $max);
}

sub version_str {
    my ($self, $v) = @_;

    return ''         unless $v;
    return $v->normal if $v->isa('version');
    return version->parse($v)->normal;
}

sub add_widget {
    my ($self, $widget, $min, $max) = @_;

    my $version = $widget->version;

    $self->say("Try:     " . $widget->name . " => @{[$version->normal]}");

    if($min && $min gt $version || $max && $max lt $version) {
        $self->say("Incorrect version: @{[$version->normal]} => [@{[$self->version_str($min)]},@{[$self->version_str($max)]}]");
        return 0;
    }

    my $saved_state = $self->elements();

    my $p = $self->elements->{$widget->name};
    my $e = $self->refine($widget, $p, $min, $max);

    my $success;
    if($p && !$e) {
        $self->say("conflicting versions: @{[$widget->name]} [@{[$p->{min}->normal || '']}, @{[$p->{max}->normal || '']}] <=> [@{[$min->normal || '']}, @{[$max->normal || '']}]");
        $success = 0;
    } elsif($p && $e) {
        # already in plan, simple refinenment of versions
        $success = 1;
    } elsif(!$e) {
        $success = 0;
        die('bug, this should not happen.');
    } else {

        if($self->add_dependencies($widget->dependencies)) {
            if($widget->sources) {
                my $s = $self->add_sources($widget->sources);
                if($s) {
                    $widget->active_source($s);
                    $success = 1;
                } else {
                    $self->say("could not add any source for: @{[$widget->name, $version]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
                    $success = 0;
                }
            } else {
                $success = 1;
            }
        } else {
            $self->say("could not set dependencies for: @{[$widget->name]} $version->normal => [@{[$min->normal || '']}, @{[$max->normal || '']}]");
            $success = 0;
        }
    }

    if($success) {
        # add new step to plan
        $self->elements->{$widget->name} = $e;
        $self->say("Success: @{[$widget->name]} @{[$e->widget->version->normal]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
    } else {
        # restore old plan on error
        $self->elements($saved_state);
    }

    return $success;
}

sub add_dependencies {
    my ($self, $dependencies) = @_;

    my $saved_state = $self->elements();

    my $success = 1;
    for my $name (keys %{$dependencies}) {

        my ($min, $max) = @{$dependencies->{$name}};
        unless($self->add_target($name, $min, $max)) {
            $success = 0;
            last;
        }
    }

    unless($success) {
        $self->elements($saved_state);
    }

    return $success;
}

sub add_sources {
    my ($self, $sources) = @_;

    my $saved_state = $self->elements();
    for my $s (@{$sources}) {

        if($self->bag->{no_system} && $s->isa('VC3::Source::System')) {
            next if $self->bag->{no_system}{ALL};
            next if $self->bag->{no_system}{$s->widget->name};
        }

        if($self->add_source($s)) {
            return $s;
        }
        $self->elements($saved_state);
    }

    return undef;
}


sub add_source {
    my ($self, $source) = @_;

    my $exit_status = -1;
    eval { $exit_status = $source->check_prerequisites() };
    if($exit_status) {
        $self->say("Fail-prereq: " . $source->widget->name . '-' . $source->widget->version->normal);
        return 0;
    }

    return $self->add_dependencies($source->dependencies);
}

sub refine {
    my ($self, $widget, $p, $min, $max) = @_;

    if($p) {
        return $p->refine($min, $max);
    } else {
        VC3::Plan::Element->new($widget, $min, $max, undef);
    }
}

sub order {
    my ($self) = @_;

    my $ordinal_of = {};

    my @names = keys %{$self->elements};

    for my $name (@names) {
        $ordinal_of->{$name} = 1;
    }

    my $to_go = @names;

    while($to_go >= 0) {
        my $change = 0;

        $to_go--;

        for my $name (@names) {
            my $e = $self->elements->{$name};
            my $o = $ordinal_of->{$name};

            my @deps;

            my $w = $e->{widget};

            if($w->dependencies) {
                push @deps, keys %{$w->dependencies};
            }

            if($w->active_source && $w->active_source->dependencies) {
                push @deps, keys %{$w->active_source->dependencies};
            }

            my $max = $o;
            if(@deps) {
                $max = 1 + List::Util::max( @{$ordinal_of}{@deps} );
            }

            if($max != $o) {
                $change = 1;
                $ordinal_of->{$w->name} = $max;
            }
        }

        if(!$change) {
            return $ordinal_of;
        }
    }

    die 'Circular dependency found';
}

sub dot_graph {
    my ($self, $dotname) = @_;
    my @names = keys %{$self->elements};

    open(my $dot_f, '>', $dotname) 
    || die "Could not open '$dotname': $!";

    print { $dot_f } "digraph {\n";

    for my $name (@names) {
        my @deps;

        my $e = $self->elements->{$name};
        my $w = $e->{widget};

        if($w->dependencies) {
            push @deps, keys %{$w->dependencies};
        }

        if($w->active_source && $w->active_source->dependencies) {
            push @deps, keys %{$w->active_source->dependencies};
        }

        if(@deps) {
            for my $dep (@deps) {
                print { $dot_f } qq(\t"$dep"->"$name";\n);
            }
        } else {
            print { $dot_f } qq(\t"$name";\n);
        }
    }

    print { $dot_f } "}\n";
    close $dot_f;
}

sub to_makeflow {
    my ($self, $dir, $dag_name, $builder_exec, $local_database) = @_;

    $self->to_file("$dir/$local_database");

    my $makeflow_name = 'dag';

    open(my $mflow_f, '>', "$dir/$makeflow_name") 
    || die "Could not open '$dir/$makeflow_name': $!";

    print { $mflow_f } ".MAKEFLOW CATEGORY builds\n";
    print { $mflow_f } ".MAKEFLOW CORES    4\n";
    print { $mflow_f } ".MAKEFLOW MEMORY   2048\n";     #  2 GB of RAM
    print { $mflow_f } ".MAKEFLOW DISK     20000\n";    # 20 GB of disk
    print { $mflow_f } "\n\n";

    my $bag    = $self->bag;
    my $root   = $bag->root_dir;
    my $target = $bag->root_dir . '/' . $bag->target;

    my $home   = $bag->home_dir;
    $home      =~ s/^\Q$root/\$(ROOT_DIR)/;

    print { $mflow_f } "RECIPES  = $local_database\n";
    print { $mflow_f } "ROOT_DIR = $root\n";
    print { $mflow_f } "TRGT_DIR = \$(ROOT_DIR)/@{[$bag->target]}\n";
    print { $mflow_f } "HOME_DIR = $home\n";
    print { $mflow_f } "DIST_DIR = $vc3_distfiles\n";
    print { $mflow_f } "REPO     = $vc3_repository\n";
    print { $mflow_f } "OPTIONS  = --make-jobs \$(CORES) --no-sys=ALL --no-run\n\n";

    print { $mflow_f } "RIBBON   = .VC3_DEPENDENCY_BUILD\n\n";

    print { $mflow_f } "\n";
    print { $mflow_f } "BUILD_COMMAND  = ./$builder_exec --database \$(RECIPES) --install \$(ROOT_DIR) --home \$(HOME_DIR) --distfiles \$(DIST_DIR) --repository \$(REPO) \$(OPTIONS) --ignore-locks\n";

    print { $mflow_f } "\n\n";
    
    my @names = keys %{$self->elements};
    for my $name (@names) {
        my @deps;

        my $e = $self->elements->{$name};
        my $w = $e->{widget};

        if($w->dependencies) {
            push @deps, keys %{$w->dependencies};
        }

        if($w->active_source && $w->active_source->dependencies) {
            push @deps, keys %{$w->active_source->dependencies};
        }

        my @inputs;
        for my $d (@deps) {
            my $rname = $self->elements->{$d}->{widget}->ribbon->{filename};

            $rname =~ s/.VC3_DEPENDENCY_BUILD$/\$(RIBBON)/;
            $rname =~ s/^\Q$target/\$(TRGT_DIR)/;

            push @inputs, $rname;
        }

        my $output = $w->ribbon->{filename};
        $output =~ s/.VC3_DEPENDENCY_BUILD$/\$(RIBBON)/;
        $output =~ s/^\Q$target/\$(TRGT_DIR)/;

        print { $mflow_f } "$output: $builder_exec $local_database @inputs\n";
        print { $mflow_f } "\t\$(BUILD_COMMAND) --require $name\n\n";
    }

    close $mflow_f;
}

sub to_file {
    my ($self, $filename) = @_;

    my $output = {};

    for my $e (values %{$self->elements}) {
        my $n = {};
        my $w = $e->widget;
        $n->{version} = $w->version->normal;

        if($w->dependencies) {
            $n->{dependencies} = $w->dependencies;
        }

        if($w->wrapper) {
            $n->{wrapper} = $w->wrapper;
        }

        if($w->prologue) {
            $n->{prologue} = $w->prologue;
        }

        if($w->environment_variables) {
            $n->{environment_variables} = $w->environment_variables;
        }

        if($w->phony) {
            $n->{phony} = $w->phony;
        }

        if($w->active_source) {
            my $s = $w->active_source;
            my $m = {};

            $m->{type} = $s->{type};

            if($s->recipe) {
                $m->{recipe} = $s->recipe;
            }

            if($s->files) {
                $m->{files} = $s->files;
            }

            if($s->msg_manual_requirement) {
                $m->{msg_manual_requirement} = $s->msg_manual_requirement;
            }

            if($s->dependencies) {
                $m->{dependencies} = $s->dependencies;
            }

            if($s->prerequisites) {
                $m->{prerequisites} = $s->prerequisites;
            }

            $n->{sources} = [ $m ];
        }

        $output->{$w->name} = [ $n ];
    }

    open my $f_h, '>', $filename || die "Could not open $filename for writting: $!\n";

    my $json = JSON::Tiny::encode_json($output);

    print { $f_h } $json, "\n";

    close $f_h;
}

package VC3::Plan::Element;

sub new {
    my ($class, $widget, $min, $max, $source) = @_;

    my $self = bless {}, $class;

    if($min && $max && $min gt $max) {
        die 'Incompatible versions';
    }

    $self->{widget} = $widget;
    $self->{min}    = $min;
    $self->{max}    = $max;

    return $self;
}

sub widget {
    my ($self, $new) = @_;

    if($new) {
        $self->{widget} = $new;;
    }

    return $self->{widget};
}

sub min {
    my ($self, $new) = @_;

    if($new) {
        $self->{min} = $new;
    }

    return $self->{min};
}

sub max {
    my ($self, $new) = @_;

    if($new) {
        $self->{max} = $new;
    }

    return $self->{max};
}

sub refine {
    my ($self, $new_min, $new_max) = @_;

    if($new_min && $self->{max} && $new_min gt $self->{max}) {
        return undef;
    }

    if($new_max && $self->{min} && $new_max lt $self->{min}) {
        return undef;
    }

    my $min = $new_min || $self->{min};
    if($new_min && $self->{min}) {
        $min = $new_min lt $self->{min} ? $new_min : $self->{min};
    }

    my $max = $new_max || $self->{max};
    if($new_max && $self->{max}) {
        $max = $new_max lt $self->{max} ? $new_max : $self->{max};
    }

    if($min && $min gt $self->{widget}->version) { 
        return undef;
    }

    if($max) {
        my $v   = version->declare($max);
        my $num = $v->numify();
        my $fix = ($num * 1000000) % 1000;
        $num   += 0.000999 unless($fix);
        $v      = version->parse($num);
        
        if($v lt $self->{widget}->version) { 
            return undef;
        }
    }

    return VC3::Plan::Element->new($self->{widget}, $min, $max);
}

package version;
sub TO_JSON {
    my ($self) = @_;
    return $self->normal;
}

