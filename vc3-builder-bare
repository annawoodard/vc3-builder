#! /usr/bin/env perl

use v5.009;
use strict;
use warnings;

# load module path, for bare, if needed
eval {use Cwd; use lib getcwd . "/builder-pack/fatlib";};

use VC3::Bag;
use VC3::Source;

package VC3::Builder;

use English qw/-mo_match_vars/;
use File::Path;
use File::Spec::Functions qw/catfile rel2abs/;
use Getopt::Long qw/GetOptions/;
use Tie::RefHash;
use Cwd;

use Carp qw( confess );
$SIG{TERM} = \&cleanup_signal_handler;
$SIG{INT}  = \&cleanup_signal_handler;
$SIG{ALRM} = \&cleanup_signal_handler;

# disable stdout buffering
select(STDOUT); $OUTPUT_AUTOFLUSH = 1;

my $pwd            = getcwd();
my $vc3_root       = catfile(${pwd}, 'vc3-root');
my $vc3_distfiles  = catfile(${pwd}, 'vc3-distfiles');
my $vc3_user_home  = 'vc3-home';
my $vc3_repository = "http://download.virtualclusters.org/builder-files";

my $shell          = '/bin/sh';

my @external_dependencies = qw/perl sh tail tar gcc g++ ld pkconfig make/;
my @cleanups;     # functions to call on exit.

# call main if running interactively
VC3::Builder::main();

END {
    local $?;

    for my $fn (@cleanups) {
        eval { $fn->() };
    }
}

sub usage {
    my ($script_name) = @_;
    return <<EOF;
$script_name [options] --require package[:min_version[:max_version]] --require ... [-- command-and-args]

  command-and-args      defaults to $shell

  options are:

  --database <catalog>  defaults to <internal> if available, otherwise 
                        to ./vc3_catalog.json. May be specified several times,
                        with latter package recipes overwriting previous ones. 

  --install <root>      Install with base <root>. 
                        Default is ${vc3_root}
  --home <home>         Set \${HOME} to <root>/<home> if <home> is a relative
                        path, otherwise to <home> if it is an absolute path.
                        Default is ${vc3_user_home}

  --distfiles <dir>     Directory to cache unbuilt packages locally.
                        Default is ${vc3_distfiles}
  --repository <url>    Site to fetch packages if needed.
                        Default is ${vc3_repository}

  --force               Reinstall the packages named with --require and the
                        packages they depend on.


  --make-jobs <n>       Concurrent make jobs. Default is 4.
  --sh-on-error         On building error, run $shell on the partially-built
                        environment.

  --sys package:version=<dir>
                        Assume <dir> to be the installation location of
                        package:version in the system.
                        (e.g. --sys python:2.7=/opt/local/)
  --no-sys=<package>    Do not use host system version of <package>. If
                        package is 'ALL', do not use system versions at
                        all. (Ignored if package specified with --sys.)

  --var NAME=VALUE      Add environment variable NAME with VALUE. 
                        May be specified several times.

  --revar PATTERN       All environment variables matching the regular
                        expression PATTERN are preserved.
                        (E.g. --revar "SGE_.*", --revar NAME is equivalent
                        to -var NAME=\$NAME)

  --interactive         Treat command-and-args as an interactive terminal.

  --silent              Do not print dependency information.
  --no-run              Set up environment, but do not execute any payload.

  --timeout SECONDS     Terminate after SECONDS have elapased. 
                        If 0, then the timeout is not activated (default).

  --env-to <file>       Write environment script to
                        <file>.{,env,payload}, but do not execute command-and-args.
                        To execute command-and-args, run ./<file>.

  --dot <file>          Write a dependency graph of the requirements to <file>.

  --parallel <dir>      Write specifications for a parallel build to <dir>.
                        (Implies --prestage.)

  --prestage            Download all files to --distfiles <dir> before
                        processing.

  --list                List general packages available.

  --list=section        List general packages available, classified by sections.

  --list=all            List all the packages available, even vc3-internals.

  Developers options:
  --debug               On a builder error, print the full back-trace. 

Examples:
    ${script_name} --require cvmfs 'ls /cvmfs/atlas.cern.ch' 
    ${script_name} --require maker-example-ecoli-01
EOF

}

sub select_sleep {
    my ($seconds) = @_;

    select(undef, undef, undef, $seconds);
}

sub cleanup_signal_handler {
    my ($signal) = @_;

    if($signal) {
        warn("Got signal!: $signal");

        if($signal eq 'ALRM') {
            warn("Timeout!");
        }

        exit 128;
    }
}

sub fix_http_proxy_vars {
    for my $var (qw(http_proxy HTTP_PROXY)) {
        my $val = $ENV{$var};

        if($val) {
            if($val =~ /^:?;?DIRECT$/) {
                delete $ENV{$var};
                next;
            }

            if($val !~ m#^https?://#) { 
                $ENV{$var} = "http://$val";
            }
        }
    }
}

sub remove_vc3_vars() {
    for my $var (keys %ENV) {
        if($var =~ '^VC3_') {
            delete $ENV{$var};
        }
    }
}

sub main {
    my @requires     = ();

    my $print_help   = 0;
    my $make_jobs    = 4;
    my $sh_on_error  = 0;

    my $debug_modules_used = 0;
    my $dry_run            = 0;
    my $no_run             = 0;
    my $debug_run          = 0;
    my $interactive_run    = 0;
    my $silent             = 0;
    my $force_rebuild      = 0;
    my $prestage           = 0;
    my $timeout;

    my $ignore_locks       = 0;

    my $env_to;
    my $dot_output;
    my $parallel_dir;       
    my $to_script;
    my $list_option;

    my @extra_env_vars = ();
    my @databases   = ();
    my @re_vars     = ();
    my @sys_manual  = ();
    my @no_sys      = ();

    # if the executable name does looks like "perl", we use $0, as it has the
    # name of the script. Otherwise, this is a static run, and we use the given
    # executable name.
    my $script_name = ${EXECUTABLE_NAME} =~ /perl/ ? $0 : ${EXECUTABLE_NAME};

    my $original_command = join(' ', $script_name, @ARGV);
    
    VC3::Builder::remove_vc3_vars();
    VC3::Builder::fix_http_proxy_vars();

    my $opt_result = GetOptions(
        "help"        => \$print_help,

        "debug"    => \$debug_run,
        "silent"   => \$silent,

        "database=s"  => \@databases,
        "require=s"   => \@requires, 

        "install=s" => \$vc3_root,
        "home=s"    => \$vc3_user_home,

        "distfiles=s"  => \$vc3_distfiles, 
        "repository=s" => \$vc3_repository, 

        "make-jobs=n" => \$make_jobs,

        "sh-on-error"     => \$sh_on_error,

        "force"           => \$force_rebuild,
        "ignore-locks"    => \$ignore_locks,

        "env-to=s"    => \$env_to,
        "dot=s"       => \$dot_output,
        "to-script=s" => \$to_script,

        "dry-run"  => \$dry_run,
        "no-run"   => \$no_run,
        "prestage" => \$prestage,
        "list:s"   => \$list_option,

        "interactive" => \$interactive_run,

        "timeout=i"   => \$timeout,

        "sys=s"    => \@sys_manual,
        "no-sys=s" => \@no_sys,
        "var=s"    => \@extra_env_vars,
        "revar=s"  => \@re_vars,

        "parallel=s" => \$parallel_dir,

        # options for developing, not for runtime:
        "debug-modules-used" => \$debug_modules_used,
    );

    unless($opt_result) {
        print usage($script_name);
        exit 1;
    }

    if($debug_run) {
        $SIG{__DIE__}  =  \&confess;
    }

    unshift @databases, '<internal>';

    if($print_help) {
        print usage($script_name);
        exit 0;
    }

    if($debug_modules_used) {
        print_modules_used();
        exit 0;
    }

    if(defined $dot_output) {
        push @no_sys, 'ALL';
        $dry_run = 1;
    }

    if(defined $to_script) {
        $dry_run = 1;
    }

    if(defined $list_option) {
        $silent  = 1;
        $dry_run = 1;
    }

    if(defined $timeout) {
        if($timeout < 0) {
            die 'timeout cannot be less than 0';
        } else {
            alarm $timeout;
        }
    }
    
    if(defined $parallel_dir) {
        push @no_sys, 'ALL';
    }

    unless(@requires) {
        push @requires, 'noop';
    }

    # add common builder environment
    unshift @requires, 'vc3-builder-hands';

    # set defaults
    my @command_and_args = @ARGV;
    if(!@command_and_args) {
        @command_and_args = ($shell,);
        $interactive_run = 1;
    }

    push @extra_env_vars, "MAKEFLAGS=-j${make_jobs}";
    push @extra_env_vars, "VC3_COMMAND_LINE=" . rel2abs(join(" ", $original_command));

    # honor paths from enclosing builder, if any.
    unshift @re_vars, 'VC3_.*';

    for my $pat (@re_vars) {
        for my $name (keys %ENV) {
            next unless $name =~ /$pat/;
            push @extra_env_vars, "$name='" . $ENV{$name} . "'";
        }
    }

    my $bag = VC3::Bag->new(
        root       => $vc3_root,
        home       => $vc3_user_home,
        distfiles  => $vc3_distfiles,
        repository => $vc3_repository,
        shell      => $shell,
        dry_run    => $dry_run,
        on_terminal=> $interactive_run,
        silent     => $silent,
        databases  => \@databases,
        sys_manual => \@sys_manual,
        no_sys     => \@no_sys,
        env_vars   => \@extra_env_vars);

    push @cleanups, sub { $bag->cleanup() };

    $bag->set_plan_for(@requires);

    if(defined $dot_output) {
        $bag->dot_graph($dot_output);
    }

    if(defined $to_script) {
        $bag->plan->to_script($to_script);
    }

    if(defined $list_option) {
        $bag->list_packages($list_option);
    }


    if($bag->dry_run) {
        exit 0;
    }

    if(defined $parallel_dir) {
        $bag->to_parallel($parallel_dir, $make_jobs);
        $bag->check_manual_requirements();
 
        $bag->set_plan_for('vc3-builder-hands', 'cctools-statics');
        $ignore_locks = 1;
        $prestage     = 1;
    }

    $bag->check_manual_requirements();

    if($prestage) {
        $bag->plan->prestage();
    }

    $bag->execute_plan($sh_on_error, $force_rebuild, $ignore_locks);

    my $exit_code;
    if($no_run) {
        $exit_code = 0;
    } elsif($env_to) {
        $bag->preserve_profile(1);
        $bag->set_profile($env_to, @command_and_args);
        $exit_code = 0;
    } else {
        $exit_code = $bag->execute(@command_and_args);
    }

    exit $exit_code;
}

sub print_modules_used {
    my $file = "stub-debug-modules.txt";

    unlink catfile($vc3_distfiles, $file);

    File::Path::make_path($vc3_distfiles);

    my $ff       = HTTP::Tiny->new();
    my $url      = $vc3_repository . '/' . $file;
    my $output   = catfile($vc3_distfiles,  $file);

    # dummy calls to trigger the use of the http module.
    my $response_a = $ff->mirror($url, $output);
    my $response_b = $ff->mirror($url, $output);

    my @modules = grep { /\.pm$/ } keys %INC;

    # turn :: into /
    map { s^/^::^g }   @modules;

    # remove .pm extension
    map { s^\.pm$^^g } @modules;

    # add modules that %INC sometimes does not find:
    my @manuals = 
    qw(
        encoding
        strict
        Cwd
        Digest::Perl::MD5
        English 
        Getopt::Long
        LockFile::Simple
        PerlIO
        Tie::RefHash );

    @modules = (@manuals, @modules);


    # remove duplicates
    @modules = uniq_words(@modules);

    @modules = sort { uc($a) cmp uc($b) } @modules;

    print join("\n", @modules), "\n";
}

sub uniq_words {
    my %words;
    for my $word (@_) {
        $words{$word} = 1;
    }

    return keys %words;
}

package VC3::Package;
use Carp;
use File::Temp;
use File::Spec::Functions qw/catfile rel2abs/;

sub new {
    my ($class, $bag, $name, $json_description) = @_;

    my $self = bless {}, $class;

    $self->bag($bag);
    $self->name($name);
    $self->dependencies($json_description->{dependencies});
    $self->wrapper($json_description->{wrapper});
    $self->prologue($json_description->{prologue});
    $self->environment_variables($json_description->{'environment-variables'});
    $self->environment_autovars($json_description->{'environment-autovars'});
    $self->phony($json_description->{phony});
    $self->operating_system($json_description->{operating_system});
    $self->auto_version($json_description->{'auto-version'});

    $self->show_in_list($json_description->{'show-in-list'});
    $self->tags($json_description->{'tags'});

    if($json_description->{versions}) {
        $self->widgets($json_description->{versions});
    } else {
        $self->{widgets} = [];
    }

    return $self;
}

sub widgets {
    my ($self, $new_widgets_spec) = @_;

    if($new_widgets_spec) {
        my @widgets;
        for my $s (@{$new_widgets_spec}) {
            my $w = VC3::Widget->new($self, $s);
            push @widgets, $w if $w;
        }

        $self->{widgets} = \@widgets;
    }

    return $self->{widgets};
}
        

sub bag {
    my ($self, $new_bag) = @_;

    $self->{bag} = $new_bag if($new_bag);

    croak 'No bag given'
    unless($self->{bag}); 

    return $self->{bag};
}

sub name {
    my ($self, $new_name) = @_;

    if($new_name) {
        # names can only contain letters, numbers, - and _.
        my @badchars = ($new_name =~ /([^A-Za-z0-9-_])/g);
        if(@badchars) {
            die "The name '$new_name' containes the following disallowed charactares: " 
            . join ', ', map { "'$_'" } @badchars;
        } else {
            $self->{name} = $new_name if($new_name);
        }
    }

    die 'No name given'
    unless($self->{name}); 

    return $self->{name};
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    $self->{dependencies} = $new_dependencies if($new_dependencies);

    return $self->{dependencies};
}

sub active_source {
    my ($self, $source) = @_;

    if($source) {
        $self->{active_source} = $source;
        $self->checksum($source);
    }

    return $self->{active_source};
}

sub prologue {
    my ($self, $new_prologue) = @_;

    $self->{prologue} = $new_prologue if($new_prologue);

    return $self->{prologue};
}

sub wrapper {
    my ($self, $new_wrapper) = @_;

    $self->{wrapper} = $new_wrapper if($new_wrapper);

    return $self->{wrapper};
}

sub environment_variables {
    my ($self, $new_vars) = @_;

    $self->{environment_variables} = $new_vars if($new_vars);

    return $self->{environment_variables};
}

sub environment_autovars {
    my ($self, $new_autovars) = @_;

    $self->{environment_autovars} = $new_autovars if($new_autovars);

    return $self->{environment_autovars};
}

sub auto_version {
    my ($self, $new_auto_version) = @_;

    $self->{auto_version} = $new_auto_version if($new_auto_version);

    return $self->{auto_version};
}

sub compute_auto_version {
    my ($self, $root) = @_;

    unless($self->auto_version) {
        die "I don't know how to compute the version of '" . $self->name . "'\n";
    }

    if($root) {
        $self->bag->add_builder_variable('VC3_PREFIX', $root);
    }

    my ($pid, $auto_in) = $self->bag->shell();

    if($root) {
        $self->bag->del_builder_variable('VC3_PREFIX');
    }

    croak "Could not open $shell for auto-version."
    unless $auto_in;

    my $template = catfile($self->bag->tmp_dir, $self->name . 'XXXXXX');
    my $fh = File::Temp->new(template => $template, unlink => 1);
    close($fh);
    
    my $fname = $fh->filename;

    # redirect all output to our log file.
    print { $auto_in } 'exec 1> ' . $fname . "\n";
    print { $auto_in } "exec 2>&1\n";
    print { $auto_in } "set -ex\n";

    if($root) {
        print { $auto_in } q(export PATH="${VC3_PREFIX}/bin":"$PATH") . "\n";
    }

    for my $step (@{$self->auto_version}) {
        print { $auto_in } "$step\n";
    }
    print { $auto_in } "exit 0\n";

    my $status = -1;
    eval { close $auto_in; $status = $? };

    if($@) {
        carp $@;
    }

    open(my $f, '<', $fname) || die 'Did not produce auto-version file';
    my @lines;
    my $version;
    while( my $line = <$f>) {
        push @lines, $line;
        if($line =~ m/^VC3_VERSION_SYSTEM:\s*v?(?<version>([0-9]+(\.?[0-9]){0,3}))$/) {
            $version = $+{version};
            chomp($version);
            last;
        }
    }
    close $f;
    if(!$version) {
        die "Did not produce version information:\n" . join("\n", @lines);
    }

    return $version;
}



sub phony {
    my ($self, $new_phony) = @_;

    $self->{phony} = $new_phony if(defined $new_phony);

    return $self->{phony};
}

sub show_in_list {
    my ($self, $new_show) = @_;

    $self->{show_in_list} = $new_show if(defined $new_show);

    return $self->{show_in_list};
}

sub tags {
    my ($self, $new_tags) = @_;

    $self->{tags} = $new_tags if($new_tags);

    return $self->{tags};
}

sub operating_system {
    my ($self, $new_os) = @_;

    $self->{operating_system} = $new_os if($new_os);

    return $self->{operating_system};
}


package VC3::Widget;
use Carp;
use POSIX ":sys_wait_h";
use IO::Handle;
use Digest::Perl::MD5 qw(md5_hex);
use Cwd;
use File::Temp qw/tempdir/;
use File::Spec::Functions qw/catfile rel2abs/;

use JSON::Tiny;

# Attributes:
# name, version, sources, dependencies, wrapper, prologue, environment_variables, environment_autovars, phony
sub new {
    my ($class, $pkg, $json_description) = @_;

    my $self = bless {}, $class;

    $self->package($pkg);
    $self->available(1);

    if($json_description->{version} eq 'auto') {
        $self->from_system(1);
        eval { $self->version($pkg->compute_auto_version()) };
        if($@) {
            $self->available(0);
        }
    } else {
        $self->version($json_description->{version});
        $self->from_system(0);
    }

    $self->sources($json_description->{sources});
    $self->dependencies($json_description->{dependencies});
    $self->wrapper($json_description->{wrapper});
    $self->prologue($json_description->{prologue});
    $self->environment_variables($json_description->{'environment-variables'});
    $self->environment_autovars($json_description->{'environment-autovars'});
    $self->phony($json_description->{phony});
    $self->operating_system($json_description->{operating_system});

    if($self->available) {
        # set root dir
        $self->root_dir();

        my $majminbug = $self->version->normal;
        $majminbug =~ s/^v([0-9]+\.[0-9]+\.[0-9]+)/$1/;

        my $majmin = $self->version->normal;
        $majmin    =~ s/^v([0-9]+\.[0-9]+)\..*/$1/;

        $self->add_widget_variable('VERSION', $majmin);
        $self->add_widget_variable('VERSION_FULL', $majminbug);
    }

    unless($self->sources) {
        my $null_source = {};
        $null_source->{type}   = 'generic';
        $null_source->{phony}  = 1;
        $null_source->{local}  = 1;
        $null_source->{recipe} = ['echo "no explicit recipe given"'];

        $self->sources([$null_source]);
    }

    return $self;
}

sub add_widget_variable {
    my ($self, $varname, $value) = @_;

    my $vars    = $self->environment_variables || [];

    $varname = $self->widget_var($varname);

    my $var = {
        name     => $varname,
        value    => $value,
        clobber  => 1,
        absolute => 1
    };
    unshift @{$vars}, $var;

    $self->environment_variables($vars);
}

sub widget_var {
    my ($self, $varname) = @_;

    my $expanded = "VC3_${varname}_" . uc($self->name);

    # replace - with _, as env vars cannot have - in their names.
    $expanded =~ s/-/_/g;

    return $expanded;
}

sub package {
    my ($self, $new_pkg) = @_;

    $self->{package} = $new_pkg if($new_pkg);

    croak 'No package given'
    unless($self->{package}); 

    return $self->{package};
}

sub bag {
    my ($self) = @_;

    return $self->package->bag;
}

sub name {
    my ($self, $new_name) = @_;

    return $self->package->name;
}

sub ribbon {
    my ($self) = @_;

    unless($self->{ribbon}) {
        $self->{ribbon} = VC3::Ribbon->new($self->name, $self->bookeeping_dir, $self->bag->tmp_dir, $self->checksum);
    }

    return $self->{ribbon};
}

sub version {
    my ($self, $new_version) = @_;

    if($new_version) {
        $self->{version} = version->declare($new_version);
    }

    unless($self->{version}) {
        croak 'No version given';
    }

    return $self->{version};
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    if($new_dependencies) {
        $self->{dependencies} = $new_dependencies;
    }

    my %deps;
    if($self->package->dependencies) {
        %deps = %{$self->package->dependencies};
    }

    for my $d (keys %{$self->{dependencies}}) {
        $deps{$d} = $self->{dependencies}->{$d};
    }

    return \%deps;
}

sub sources {
    my ($self, $new_sources) = @_;

    if($new_sources) {
        my @sources = map { VC3::Source->new($self, $_) } @{$new_sources};
        $self->{sources} = \@sources;
    }

    return $self->{sources};
}

sub active_source {
    my ($self, $source) = @_;

    if($source) {
        $self->{active_source} = $source;
        $self->checksum($source);
    }

    return $self->{active_source};
}

sub prologue {
    my ($self, $new_prologue) = @_;

    $self->{prologue} = $new_prologue if($new_prologue);

    my $prologue = $self->{prologue} || $self->package->prologue;

    return $prologue;
}

sub wrapper {
    my ($self, $new_wrapper) = @_;

    $self->{wrapper} = $new_wrapper if($new_wrapper);

    my $wrapper = $self->{wrapper} || $self->package->wrapper;

    return $wrapper;
}


sub environment_variables {
    my ($self, $new_vars) = @_;

    if($new_vars) {
        my @vars = ();

        if($self->package->environment_variables) {
            push @vars, @{$self->package->environment_variables};
        }

        push @vars, @{$new_vars};
        $self->{environment_variables} = \@vars;
    }

    return $self->{environment_variables};
}

sub environment_autovars {
    my ($self, $new_autovars) = @_;

    my %mappings;
    $mappings{PATH}               = 'bin';
    $mappings{LD_LIBRARY_PATH}    = 'lib';
    $mappings{LIBRARY_PATH}       = 'lib';
    $mappings{C_INCLUDE_PATH}     = 'include';
    $mappings{CPLUS_INCLUDE_PATH} = 'include';
    $mappings{PKG_CONFIG_PATH}    = 'lib/pkgconfig';
    $mappings{PYTHONPATH}         = 'lib/python${VC3_VERSION_PYTHON}/site-packages';
    $mappings{PERL5LIB}           = 'lib/perl5/site_perl';

    if($new_autovars) {
        $self->{environment_autovars} = $new_autovars;
    }

    my @autovars;
    if($self->package->environment_autovars) {
        push @autovars, @{$self->package->environment_autovars};
    }

    if($self->{environment_autovars}) {
        push @autovars, @{$self->{environment_autovars}};
    }

    $self->{environment_variables} ||= [];
    for my $var (@autovars) {
        my $target = $mappings{$var};

        unless($target) {
            die "Unrecognized auto-variable '$var'";
        }

        push @{$self->{environment_variables}}, { 'name' => $var, 'value' => $target };
    }

    return @autovars;
}

sub phony {
    my ($self, $new_phony) = @_;

    $self->{phony} = $new_phony if(defined $new_phony);

    my $phony = $self->{phony} || $self->package->phony;

    return $phony;
}

sub from_system {
    my ($self, $new_from_system) = @_;

    $self->{from_system} = $new_from_system if(defined $new_from_system);

    return $self->{from_system};
}

sub available {
    my ($self, $new_available) = @_;

    $self->{available} = $new_available if(defined $new_available);

    return $self->{available};
}

sub operating_system {
    my ($self, $new_operating_system) = @_;

    $self->{operating_system} = $new_operating_system if($new_operating_system);

    my $operating_system = $self->{operating_system} || $self->package->operating_system;

    return $operating_system;
}

sub root_dir {
    my ($self, $new) = @_;

    my $old = $self->{root_dir};

    my $var_value;

    if($new) {
        $self->{root_dir} = $new;
        $var_value = $new;
    }

    unless($self->{root_dir}) {
        my $rel = catfile($self->bag->target, $self->name, $self->version->normal);
        $self->{root_dir} = catfile(rel2abs($vc3_root), $rel);
        $var_value = catfile('${VC3_ROOT}', '${VC3_MACHINE_TARGET}', $self->name, 'v${' . $self->widget_var('VERSION_FULL') . '}');
    }

    if(!$old || $old ne $self->{root_dir}) {
        $self->add_widget_variable('ROOT', $var_value);
    }

    return $self->{root_dir};
}

sub bookeeping_dir {
    my ($self, $relative) = @_;

    my $rel = catfile($self->bag->target, $self->name, $self->version->normal);

    if($relative) {
        return $rel;
    }

    return catfile(rel2abs($vc3_root), $rel);
}

sub build_dir {
    my ($self) = @_;

    unless($self->{build_dir}) {
        my $root     = catfile(rel2abs($vc3_root), 'builds');

        unless(-d $root) {
            File::Path::make_path($root);
        }

        my $template = catfile($root, $self->name . '.XXXXXX');

        my $tmpdir   = File::Temp::tempdir($template, CLEANUP => 1);
        $self->{build_dir} = $tmpdir;
    }

    return $self->{build_dir};
}

sub build_log {
    my ($self) = @_;
    my $log_name = catfile($self->bookeeping_dir, $self->name . '-build-log');

    return $log_name;
}

sub say {
    my $self = shift @_;

    return $self->bag->say(@_);
}

sub consolidate_environment_variables {
    my ($self, $expansion) = @_; 

    my $vars = $self->environment_variables
    || return;

    for my $var (reverse @{$vars}) {

        my $name = $var->{name}
        || carp "Environment variable does not have a name.";

        my $value = $var->{value}
        || carp "Environment variable '$name' did not define a value.";

        my $clobber  = $var->{clobber};
        my $absolute = $var->{absolute};

        if($expansion->{$name} && $clobber) {
            my @old_value = @{$expansion->{$name}};
            my $n = @old_value;
            if($n > 1) {
                carp("Asked to clobber variable '$name', but it already had a value.\n"
                    . "'$value' <> '" . join(',', @old_value) . "'\n");
            }
        }

        $expansion->{$name} ||= [];

        my @paths;
        if($clobber) {
            # when clobber, we use the value as is, and remove previous expansions.
            @paths = ($value);
            $expansion->{$name} = [];
        } else {
            # otherwise, split paths on :
            @paths = split /:/, $value;
        }

        my @current_expansions;
        for my $path (@paths) {
            if(!$absolute) {
                if($self->root_dir eq $self->bookeeping_dir) {
                    $path = catfile('${' . $self->widget_var('ROOT') . '}', $path);
                } else {
                    $path = catfile($self->root_dir, $path);
                }
            }

            push @current_expansions, $path;
        }

        unshift @{$expansion->{$name}}, @current_expansions;
    }
}

sub error_debug_info {
    my ($self, $eval_error) = @_;

    print "'", $self->name, "' failed to build for ", $self->bag->target, "\n";

    if($eval_error) {
        print $eval_error, "\n";
    }

    if(-f $self->build_log) {
        print "Last lines of log file:\n";
        system('tail', $self->build_log);
    }
}


sub process_error {
    my ($self, $sh_on_error, $eval_error, $status) = @_;

    if($eval_error || $status) {
        $self->error_debug_info($eval_error);

        if($sh_on_error) {
            warn $@ if $@;

            my $cwd = getcwd();

            $self->bag->shell_user();

            chdir $cwd;
        }
    }
}

sub checksum {
    my ($self, $load) = @_;

    if(!$self->{checksum}) {
        $load ||= 'no source';

        my $txt = $self->hash_to_canonical_str($load);
        my $dgt = md5_hex($txt);

        $self->{checksum} = $dgt;
    }

    return $self->{checksum};
}

sub hash_to_canonical_str {
    my ($self, $ref) = @_;

    my $str;

    if(ref($ref) eq 'HASH') {
        my @ks = sort { $a cmp $b } keys %{$ref};

        $str 
        = '{'
        . join(',', map { $_ .  ':' . $self->hash_to_canonical_str($ref->{$_}) } @ks)
        . '}';
    } elsif(ref($ref) eq 'ARRAY') {
        $str 
        = '['
        . join(',', map { $self->hash_to_canonical_str($_) } @{$ref})
        . ']';
    } else {
        $str = $ref;
    }

    return $str;
}


sub msgs_manual_requirements {
    my ($self) = @_;

    my $sources = $self->sources;

    my @restricted_unmet;
    for my $source (@{$sources}) {
        unless($source->check_manual_requirements()) {
            push @restricted_unmet, $source->msg_manual_requirement();
        }
    }

    return @restricted_unmet;
}


sub prepare_recipe_sandbox {
    my ($self, $no_erase) = @_;

    # clear build directory, to avoid bugs from uncleaned sources.
    my $build = $self->build_dir;
    if( -d $build ) {
        File::Path::rmtree($build);
    }

    # clear destination directory, to make sure we are running what we believe
    # we are running.
    unless($no_erase) {
        my $dir = $self->root_dir;
        if( -d $dir ) {
            File::Path::rmtree($dir);
        }

        if($self->root_dir ne $self->bookeeping_dir) {
            my $dir = $self->bookeeping_dir;
            if( -d $dir ) {
                File::Path::rmtree($dir);
            }
        }
    }

    # create the dirs we removed above.
    File::Path::make_path($self->build_dir);
    File::Path::make_path($self->root_dir);
    File::Path::make_path($self->bookeeping_dir);

    # make sure tmp dir exists
    File::Path::make_path($self->bag->tmp_dir);

    # set the destination directory as an environment variable before
    # setting up the shell, so that the child created inherets it.
    $self->bag->add_builder_variable('VC3_PREFIX', $self->root_dir);
    $self->bag->add_builder_variable('VC3_BUILD',  $self->build_dir);
}

sub cleanup_recipe_sandbox {
    my ($self, $result) = @_;

    $self->bag->del_builder_variable('VC3_PREFIX');
    $self->bag->del_builder_variable('VC3_BUILD');

    if($result eq '0') {
        File::Path::rmtree($self->build_dir);
        $self->ribbon->commit('DONE');
    }

    # we do not delete the buildir in case of error, to ease debugging.
}

sub setup_build_shell {
    my ($self, @log_messages) = @_;

    # log the recipe used. Since we are opening sh with -e, the recipe executes
    # as if all steps were &&-ed together.
    open(my $build_log, '>', $self->build_log);
    print { $build_log } join("\n && ", @log_messages . "\n");
    close $build_log;

    # open sh with -e. This terminates the shell at the first step that returns
    # a non-zero status.
    my ($pid, $build_in) = $self->bag->shell();

    croak "Could not open $shell for building."
    unless $build_in;

    # redirect all output to our log file.
    print { $build_in } 'exec 1>> ' . $self->build_log . "\n";
    print { $build_in } "exec 2>&1\n";
    print { $build_in } "set -ex\n";

    # return the stdin of the shell, and the pid so we can wait for it.
    return ($pid, $build_in);
}

sub shell {
    my ($self) = @_;
    return $self->bag->shell();
}

package VC3::Ribbon;

use File::Basename; 
use LockFile::Simple qw(lock unlock);
use File::Spec::Functions qw/catfile rel2abs/;

sub new {
    my ($class, $name, $install_dir, $tmpdir, $checksum) = @_;

    my $self = bless {}, $class;

    $self->{filename} = catfile($install_dir, '.VC3_DEPENDENCY_BUILD');
    $self->{lockname} = catfile($tmpdir, $name . '.lock');
    $self->{checksum} = $checksum;

    $self->{lockmgr} = LockFile::Simple->make(-hold => 3600, -autoclean => 1, -max => 99999, -delay => 5, -stale => 1, -wmin => 2,
        -wfunc => sub { LockFile::Simple::core_warn("Waiting for a lock for '$name'. If you think this lock is stale, please remove the file:\n'" . $self->{lockname} . "'\n") }
    );

    return $self;
}

sub commit {
    my ($self, $state) = @_;

    my $ribbon_fh = IO::Handle->new();
    open ($ribbon_fh, '>', $self->{filename});

    my $report = {};
    $report->{state}    = $state;
    $report->{checksum} = $self->{checksum};
    $report->{time}     = time();

    printf { $ribbon_fh } JSON::Tiny::encode_json($report);

    $ribbon_fh->flush();
    $ribbon_fh->sync();

    $ribbon_fh->close();
}

sub set_lock {
    my ($self) = @_;

    # make sure parent directory exists
    File::Path::make_path( dirname($self->{filename}) );

    $self->{lockobj} = $self->{lockmgr}->lock($self->{filename}, $self->{lockname});
}

sub release_lock {
    my ($self) = @_;
    $self->{lockobj}->release();
}

sub state {
    my ($self) = @_;

    my $name = $self->{filename};
    my $state = 'MISSING';

    if(-f $name) {
        open my $ribbon_fh, '<', $name || warn $!;

        if($ribbon_fh) {
            my $contents = do { local($/); <$ribbon_fh> };
            close($ribbon_fh);

            my $report;
            eval { $report = JSON::Tiny::decode_json($contents) };
            if($@) {
                $state = 'MISSING';
            }

            if(!$report->{state}) {
                $state = 'MISSING';
            #} elsif(!$report->{checksum}) {
            #     $state = 'MISSING';
            # } elsif($report->{checksum} ne $self->{checksum}) {
            # $state = 'OUT_OF_DATE';
            } elsif($report->{state} eq 'PROCESSING') {
                $state = 'PROCESSING';
            } else {
                $state = $report->{state};
            }
        }
    }

    return $state;
}


package VC3::Plan;
use JSON::Tiny;

sub new {
    my ($class, $bag, $parent) = @_;

    my $self = bless {}, $class;

    $self->bag($bag);

    $self->elements($parent && $parent->elements || {});

    return $self;
}

sub bag {
    my ($self, $new) = @_;

    if($new) {
        $self->{bag} = $new;
    }

    return $self->{bag};
}

sub say {
    my ($self, @rest) = @_;

    return $self->bag->say(@rest);
}

sub elements {
    my ($self, $new) = @_;

    if($new) {
        $self->{elements} = \%{ $new };
    }

    return $self->{elements};
}

sub element_of {
    my ($self, $name) = @_;

    return $self->elements->{$name};
}

sub requirements {
    my ($self) = @_;

    unless($self->{requirements}) {
        $self->{requirements} = [];
    }

    return $self->{requirements};
}

sub add_target {
    my ($self, $name, $min, $max) = @_;

    $self->bag->{indent_level}++;

    $self->say("Plan:    $name => [@{[$min || '']}, @{[$max || '']}]");

    my $available = $self->bag->widgets_of($name);
    for my $widget (@{$available}) {

        unless($widget->available) {
            next;
        }

        if($self->add_widget($widget, $min, $max)) {
            $self->bag->{indent_level}--;
            return 1;
        }
    }

    $self->say("Failure: $name => [@{[$min || '']}, @{[$max || '']}]");
    $self->bag->{indent_level}--;

    return 0;
}

sub add_main_targets {
    my ($self, @requires) = @_;

    my $root_entry = { version => version->declare('v0.0.1'), phony => 1, dependencies => {} };

    for my $req (@requires) {
        my ($name, $min, $max) = $self->parse_requirement($req);

        my $versions = [];
        push @{$versions}, $min if($min);
        push @{$versions}, $max if($max);

        $root_entry->{dependencies}{$name} = $versions;
        
        unless($self->add_target($name, $min, $max)) {
            die "Could not find plan for $req.\n";
        }

        push @{$self->requirements}, $name;
    }

    return 1;
}

sub parse_requirement {
    my ($self, $req) = @_;

    $req =~ m/
    ^
    (?<name> [A-z0-9_-]+)
    (:                      # start of min version
    (?<min> [^:]*)
    (:                      # start of max version
    (?<max> [^:]*)
    )?)?
    $
    /x;

    my ($name, $min, $max) = ($+{name}, $+{min}, $+{max});

    if(!$min && $max) {
        $min = 'v0.0.0';
    }

    # turn into version strings
    $min = version->declare($min) if($min);
    $max = version->declare($max) if($max);

    return ($name, $min, $max);
}

sub version_str {
    my ($self, $v) = @_;

    return ''         unless $v;
    return $v->normal if $v->isa('version');
    return version->parse($v)->normal;
}

sub add_widget {
    my ($self, $widget, $min, $max) = @_;

    my $version = $widget->version;

    $self->say("Try:     " . $widget->name . " => @{[$version->normal]}");

    if($min && $min gt $version || $max && $max lt $version) {
        $self->say("Incorrect version: @{[$version->normal]} => [@{[$self->version_str($min)]},@{[$self->version_str($max)]}]");
        return 0;
    }

    my $saved_state = $self->elements();

    my $p = $self->elements->{$widget->name};
    my $e = $self->refine($widget, $p, $min, $max);

    my $success;
    if($p && !$e) {
        $self->say("conflicting versions: @{[$widget->name]} [@{[ $self->version_str($p->{min}) ]}, @{[ $self->version_str($p->{max})]} <=> [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
        $success = 0;
    } elsif($p && $e) {
        # already in plan, simple refinenment of versions
        $success = 1;
    } elsif(!$e) {
        $success = 0;
        die('bug, this should not happen.');
    } else {

        if($self->add_dependencies($widget->dependencies)) {
            if($widget->sources) {
                my $s = $self->add_sources($widget->sources);
                if($s) {
                    $widget->active_source($s);
                    $success = 1;
                } else {
                    $self->say("could not add any source for: @{[$widget->name, $version]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
                    $success = 0;
                }
            } else {
                $success = 1;
            }
        } else {
            $self->say("could not set dependencies for: @{[$widget->name]} @{[$version->normal]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
            $success = 0;
        }
    }

    if($success) {
        # add new step to plan
        $self->elements->{$widget->name} = $e;
        $self->say("Success: @{[$widget->name]} @{[$e->widget->version->normal]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
    } else {
        # restore old plan on error
        $self->elements($saved_state);
    }

    return $success;
}

sub add_dependencies {
    my ($self, $dependencies) = @_;

    my $saved_state = $self->elements();

    my $success = 1;
    for my $name (keys %{$dependencies}) {

        my ($min, $max) = @{$dependencies->{$name}};
        unless($self->add_target($name, $min, $max)) {
            $success = 0;
            last;
        }
    }

    unless($success) {
        $self->elements($saved_state);
    }

    return $success;
}

sub add_sources {
    my ($self, $sources) = @_;

    my $saved_state = $self->elements();
    for my $s (@{$sources}) {

        if($s->isa('VC3::Source::System')) {
            unless($self->bag->{system}{$s->widget->name}) {
                    next if $self->bag->{no_system}{ALL};
                    next if $self->bag->{no_system}{$s->widget->name};
                }
            }

        if($self->add_source($s)) {
            return $s;
        }
        $self->elements($saved_state);
    }

    return undef;
}


sub add_source {
    my ($self, $source) = @_;

    my $exit_status = -1;
    eval { $exit_status = $source->check_prerequisites() };

    if($exit_status) {
        $self->say("Fail-prereq: " . $source->widget->name . '-' . $source->widget->version->normal);
        return 0;
    }

    return $self->add_dependencies($source->dependencies);
}

sub refine {
    my ($self, $widget, $p, $min, $max) = @_;

    if($p) {
        return $p->refine($min, $max);
    } else {
        VC3::Plan::Element->new($widget, $min, $max, undef);
    }
}

sub order {
    my ($self, $set) = @_;

    if($set) {
        my $ordinals = $self->order_aux();
        my @ordered = sort { ($ordinals->{$a} <=> $ordinals->{$b}) || ($a cmp $b) } keys %{$ordinals};
        $self->{order} = [ map { $self->elements->{$_}{widget} } @ordered ];
    }

    return $self->{order};
}

sub order_aux {
    my ($self) = @_;

    my $ordinal_of = {};

    my @names = keys %{$self->elements};

    for my $name (@names) {
        $ordinal_of->{$name} = 1;
    }

    my $to_go = @names;

    while($to_go >= 0) {
        my $change = 0;

        $to_go--;

        for my $name (@names) {
            my $e = $self->elements->{$name};
            my $o = $ordinal_of->{$name};

            my @deps;

            my $w = $e->{widget};

            if($w->dependencies) {
                push @deps, keys %{$w->dependencies};
            }

            if($w->active_source && $w->active_source->dependencies) {
                push @deps, keys %{$w->active_source->dependencies};
            }

            my $max = $o;
            if(@deps) {
                $max = 1 + List::Util::max( @{$ordinal_of}{@deps} );
            }

            if($max != $o) {
                $change = 1;
                $ordinal_of->{$w->name} = $max;
            }
        }

        if(!$change) {
            return $ordinal_of;
        }
    }

    die 'Circular dependency found';
}

sub dot_graph {
    my ($self, $dotname) = @_;
    my @names = keys %{$self->elements};

    open(my $dot_f, '>', $dotname) 
    || die "Could not open '$dotname': $!";

    print { $dot_f } "digraph {\n";

    print { $dot_f } "node [shape=record];\n";

    for my $name (@names) {
        my $e = $self->elements->{$name};
        my $w = $e->{widget};
        my $v = $w->version->normal;

        my $n = $name;
        $n =~ s/[^A-z0-9]//g;

        print { $dot_f } qq($n [label="$name&#92;n$v"];\n);
    }

    for my $name (@names) {
        my @deps;

        my $e = $self->elements->{$name};
        my $w = $e->{widget};

        if($w->dependencies) {
            push @deps, keys %{$w->dependencies};
        }

        if($w->active_source && $w->active_source->dependencies) {
            push @deps, keys %{$w->active_source->dependencies};
        }

        my $n = $name;
        $n =~ s/[^A-z0-9]//g;

        if(@deps) {
            for my $dep (@deps) {
                my $d = $dep;
                $d =~ s/[^A-z0-9]//g;

                print { $dot_f } qq(\t"$d"->"$n";\n);
            }
        }
    }

    print { $dot_f } "}\n";
    close $dot_f;
}

sub to_makeflow {
    my ($self, $dir, $dag_name, $builder_exec, $local_database, $cores) = @_;

    $self->trimmed_database(catfile($dir,$local_database));

    my $makeflow_name = 'dag';

    open(my $mflow_f, '>', catfile($dir,$makeflow_name)) 
    || die "Could not open '$dir/$makeflow_name': $!";

    print { $mflow_f } ".MAKEFLOW CATEGORY builds\n";
    print { $mflow_f } ".MAKEFLOW CORES    $cores\n";
    print { $mflow_f } ".MAKEFLOW MEMORY   @{[$cores * 512]}\n";
    print { $mflow_f } ".MAKEFLOW DISK     20000\n";    # 20 GB of disk
    print { $mflow_f } "\n\n";

    my $bag    = $self->bag;
    my $root   = $bag->root_dir;
    my $target = catfile($bag->root_dir, $bag->target);

    my $home   = $bag->home_dir;
    $home      =~ s/^\Q$root/\$(ROOT_DIR)/;

    print { $mflow_f } "RECIPES  = $local_database\n";
    print { $mflow_f } "ROOT_DIR = $root\n";
    print { $mflow_f } "TRGT_DIR = \$(ROOT_DIR)/@{[$bag->target]}\n";
    print { $mflow_f } "HOME_DIR = $home\n";
    print { $mflow_f } "DIST_DIR = $vc3_distfiles\n";
    print { $mflow_f } "REPO     = $vc3_repository\n";
    print { $mflow_f } "OPTIONS  = --make-jobs \$(CORES) --no-run\n\n";

    print { $mflow_f } "RIBBON   = .VC3_DEPENDENCY_BUILD\n\n";

    print { $mflow_f } "\n";
    print { $mflow_f } "BUILD_COMMAND  = ./$builder_exec --database \$(RECIPES) --install \$(ROOT_DIR) --home \$(HOME_DIR) --distfiles \$(DIST_DIR) --repository \$(REPO) \$(OPTIONS) --ignore-locks\n";

    print { $mflow_f } "\n\n";
    
    my @names = keys %{$self->elements};
    for my $name (@names) {
        my @deps;

        my $e = $self->elements->{$name};
        my $w = $e->{widget};

        if($w->dependencies) {
            push @deps, keys %{$w->dependencies};
        }

        if($w->active_source && $w->active_source->dependencies) {
            push @deps, keys %{$w->active_source->dependencies};
        }

        my @inputs;
        for my $d (@deps) {
            my $rname = $self->elements->{$d}->{widget}->ribbon->{filename};

            $rname =~ s/.VC3_DEPENDENCY_BUILD$/\$(RIBBON)/;
            $rname =~ s/^\Q$target/\$(TRGT_DIR)/;

            push @inputs, $rname;
        }

        my $output = $w->ribbon->{filename};
        $output =~ s/.VC3_DEPENDENCY_BUILD$/\$(RIBBON)/;
        $output =~ s/^\Q$target/\$(TRGT_DIR)/;

        print { $mflow_f } "$output: $builder_exec $local_database @inputs\n";

        print { $mflow_f } "\t";

        if(!$w->active_source || $w->active_source->local) {
            print { $mflow_f } "LOCAL "
        }

        print { $mflow_f } "\t\$(BUILD_COMMAND) --require $name\n\n";
    }

    close $mflow_f;
}

sub prestage {
    my ($self) = @_;

    for my $e (values %{$self->elements}) {
        my $s = $e->widget->active_source;
        next unless $s;

        $s->get_files();
    }
}

sub trimmed_database {
    my ($self, $filename) = @_;

    my $output = {};

    for my $e (values %{$self->elements}) {
        my $n = {};
        my $w = $e->widget;
        $n->{version} = $w->version->normal;

        if($w->dependencies) {
            $n->{dependencies} = $w->dependencies;
        }

        if($w->wrapper) {
            $n->{wrapper} = $w->wrapper;
        }

        if($w->prologue) {
            $n->{prologue} = $w->prologue;
        }

        if($w->environment_variables) {
            $n->{'environment-variables'} = $w->environment_variables;
        }

        if($w->phony) {
            $n->{phony} = $w->phony;
        }

        if($w->active_source) {
            my $s = $w->active_source;
            my $m = {};

            $m->{type} = $s->{type};

            if($s->isa('VC3::Source::AutoRecipe')) {
                if($s->preface) {
                    $m->{preface} = $s->preface;
                }

                if($s->epilogue) {
                    $m->{epilogue} = $s->epilogue;
                }

                if($s->options) {
                    $m->{options} = $s->options;
                }
            } elsif($s->recipe) {
                $m->{recipe} = $s->recipe;
            }

            if($s->files) {
                $m->{files} = $s->files;
            }

            if($s->msg_manual_requirement) {
                $m->{msg_manual_requirement} = $s->msg_manual_requirement;
            }

            if($s->dependencies) {
                $m->{dependencies} = $s->dependencies;
            }

            if($s->prerequisites) {
                $m->{prerequisites} = $s->prerequisites;
            }

            if($s->local) {
                $m->{local} = $s->local;
            }


            $n->{sources} = [ $m ];
        }

        $output->{$w->name} = [ $n ];
    }

    open my $f_h, '>', $filename || die "Could not open $filename for writting: $!\n";

    my $json = JSON::Tiny::encode_json($output);

    print { $f_h } $json, "\n";

    close $f_h;
}

sub to_script {
    my ($self, $filename) = @_;

    open my $f_h, '>', $filename || die "Could not open $filename for writting: $!\n";

    for my $w (@{$self->order}) {
        $self->bag->activate_widget($w);
        $self->bag->set_environment_variables($f_h);
    }

    close $f_h;
}


package VC3::Plan::Element;

sub new {
    my ($class, $widget, $min, $max, $source) = @_;

    my $self = bless {}, $class;

    if($min && $max && $min gt $max) {
        die 'Incompatible versions';
    }

    $self->{widget} = $widget;
    $self->{min}    = $min;
    $self->{max}    = $max;

    return $self;
}

sub widget {
    my ($self, $new) = @_;

    if($new) {
        $self->{widget} = $new;;
    }

    return $self->{widget};
}

sub min {
    my ($self, $new) = @_;

    if($new) {
        $self->{min} = $new;
    }

    return $self->{min};
}

sub max {
    my ($self, $new) = @_;

    if($new) {
        $self->{max} = $new;
    }

    return $self->{max};
}

sub refine {
    my ($self, $new_min, $new_max) = @_;

    if($new_min && $self->{max} && $new_min gt $self->{max}) {
        return undef;
    }

    if($new_max && $self->{min} && $new_max lt $self->{min}) {
        return undef;
    }

    my $min = $new_min || $self->{min};
    if($new_min && $self->{min}) {
        $min = $new_min lt $self->{min} ? $new_min : $self->{min};
    }

    my $max = $new_max || $self->{max};
    if($new_max && $self->{max}) {
        $max = $new_max lt $self->{max} ? $new_max : $self->{max};
    }

    if($min && $min gt $self->{widget}->version) { 
        return undef;
    }


    if($max && $max lt $self->{widget}->version) {
        return undef;
    }
        
    return VC3::Plan::Element->new($self->{widget}, $min, $max);
}

package version;
sub TO_JSON {
    my ($self) = @_;
    return $self->normal;
}

