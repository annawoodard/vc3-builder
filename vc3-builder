#! /usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CWD';
  package Cwd;
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.62';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  if(! defined &getcwd && defined &DynaLoader::boot_DynaLoader) {
    eval {#eval is questionable since we are handling potential errors like
          #"Cwd object version 3.48 does not match bootstrap parameter 3.50
          #at lib/DynaLoader.pm line 216." by having this eval
      if ( $] >= 5.006 ) {
        require XSLoader;
        XSLoader::load( __PACKAGE__, $xs_version);
      } else {
        require DynaLoader;
        push @ISA, 'DynaLoader';
        __PACKAGE__->bootstrap( $xs_version );
      }
    };
  }
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     amigaos =>
     {
      getcwd              => '_backtick_pwd',
      fastgetcwd          => '_backtick_pwd',
      fastcwd             => '_backtick_pwd',
      abs_path            => 'fast_abs_path',
     }
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  if($^O ne 'MSWin32') {
      foreach my $try ('/bin/pwd',
  		     '/usr/bin/pwd',
  		     '/QOpenSys/bin/pwd', # OS/400 PASE.
  		    ) {
  	if( -x $try ) {
  	    $pwd_cmd = $try;
  	    last;
  	}
      }
  }
  
  # Android has a built-in pwd. Using $pwd_cmd will DTRT if
  # this perl was compiled with -Dd_useshellcmds, which is the
  # default for Android, but the block below is needed for the
  # miniperl running on the host when cross-compiling, and
  # potentially for native builds with -Ud_useshellcmds.
  if ($^O =~ /android/) {
      # If targetsh is executable, then we're either a full
      # perl, or a miniperl for a native build.
      if (-x $Config::Config{targetsh}) {
          $pwd_cmd = "$Config::Config{targetsh} -c pwd"
      }
      else {
          my $sh = $Config::Config{sh} || (-x '/system/bin/sh' ? '/system/bin/sh' : 'sh');
          $pwd_cmd = "$sh -c pwd"
      }
  }
  
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if someone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
  
      # Localize %ENV entries in a way that won't create new hash keys.
      # Under AmigaOS we don't want to localize as it stops perl from
      # finding 'sh' in the PATH.
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV) if $^O ne "amigaos";
      local @ENV{@localize} if @localize;
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      if ($^O eq "cygwin") {
        $newdir =~ s|\A///+|//|;
        $newdir =~ s|(?<=[^/])//+|/|g;
      }
      elsif ($^O ne 'MSWin32') {
        $newdir =~ s|///*|/|g;
      }
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    require File::Spec;
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      my $pwd = `cmd /c cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd_simple {
      my $pwd = `cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd {
      my $pwd;
      $pwd = Win32::GetCwd();
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      my $pwd;
      if (!defined &Dos::GetCwd) {
          chomp($pwd = `command /c cd`);
          $pwd =~ s:\\:/:g ;
      } else {
          $pwd = Dos::GetCwd();
      }
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $pwd = `/usr/bin/fullpath -t`;
      chomp $pwd;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      return $ENV{'PWD'} = EPOC::getcwd();
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
  __END__
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
CWD

$fatpacked{"Digest/Perl/MD5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIGEST_PERL_MD5';
  package Digest::Perl::MD5;
  use strict;
  use integer;
  use Exporter;
  use vars qw($VERSION @ISA @EXPORTER @EXPORT_OK);
  
  @EXPORT_OK = qw(md5 md5_hex md5_base64);
  
  @ISA = 'Exporter';
  $VERSION = '1.9';
  
  # I-Vektor
  sub A() { 0x67_45_23_01 }
  sub B() { 0xef_cd_ab_89 }
  sub C() { 0x98_ba_dc_fe }
  sub D() { 0x10_32_54_76 }
  
  # for internal use
  sub MAX() { 0xFFFFFFFF }
  
  # pad a message to a multiple of 64
  sub padding {
      my $l = length (my $msg = shift() . chr(128));    
      $msg .= "\0" x (($l%64<=56?56:120)-$l%64);
      $l = ($l-1)*8;
      $msg .= pack 'VV', $l & MAX , ($l >> 16 >> 16);
  }
  
  
  sub rotate_left($$) {
  	#$_[0] << $_[1] | $_[0] >> (32 - $_[1]);
  	#my $right = $_[0] >> (32 - $_[1]);
  	#my $rmask = (1 << $_[1]) - 1;
  	($_[0] << $_[1]) | (( $_[0] >> (32 - $_[1])  )  & ((1 << $_[1]) - 1));
  	#$_[0] << $_[1] | (($_[0]>> (32 - $_[1])) & (1 << (32 - $_[1])) - 1);
  }
  
  sub gen_code {
    # Discard upper 32 bits on 64 bit archs.
    my $MSK = ((1 << 16) << 16) ? ' & ' . MAX : '';
  #	FF => "X0=rotate_left(((X1&X2)|(~X1&X3))+X0+X4+X6$MSK,X5)+X1$MSK;",
  #	GG => "X0=rotate_left(((X1&X3)|(X2&(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
    my %f = (
  	FF => "X0=rotate_left((X3^(X1&(X2^X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  	GG => "X0=rotate_left((X2^(X3&(X1^X2)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  	HH => "X0=rotate_left((X1^X2^X3)+X0+X4+X6$MSK,X5)+X1$MSK;",
  	II => "X0=rotate_left((X2^(X1|(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
    );
    #unless ( (1 << 16) << 16) { %f = %{$CODES{'32bit'}} }
    #else { %f = %{$CODES{'64bit'}} }
  
    my %s = (  # shift lengths
  	S11 => 7, S12 => 12, S13 => 17, S14 => 22, S21 => 5, S22 => 9, S23 => 14,
  	S24 => 20, S31 => 4, S32 => 11, S33 => 16, S34 => 23, S41 => 6, S42 => 10,
  	S43 => 15, S44 => 21
    );
  
    my $insert = "\n";
    while(defined( my $data = <DATA> )) {
  	chomp $data;
  	next unless $data =~ /^[FGHI]/;
  	my ($func,@x) = split /,/, $data;
  	my $c = $f{$func};
  	$c =~ s/X(\d)/$x[$1]/g;
  	$c =~ s/(S\d{2})/$s{$1}/;
  	$c =~ s/^(.*)=rotate_left\((.*),(.*)\)\+(.*)$//;
  
  	my $su = 32 - $3;
  	my $sh = (1 << $3) - 1;
  
  	$c = "$1=(((\$r=$2)<<$3)|((\$r>>$su)&$sh))+$4";
  
  	#my $rotate = "(($2 << $3) || (($2 >> (32 - $3)) & (1 << $2) - 1)))"; 
  	# $c = "\$r = $2;
  	# $1 = ((\$r << $3) | ((\$r >> (32 - $3))  & ((1 << $3) - 1))) + $4";
  	$insert .= "\t$c\n";
    }
    close DATA;
    
    my $dump = '
    sub round {
  	my ($a,$b,$c,$d) = @_[0 .. 3];
  	my $r;' . $insert . '
  	$_[0]+$a' . $MSK . ', $_[1]+$b ' . $MSK . 
          ', $_[2]+$c' . $MSK . ', $_[3]+$d' . $MSK . ';
    }';
    eval $dump;
    # print "$dump\n";
    # exit 0;
  }
  
  gen_code();
  
  #########################################
  # Private output converter functions:
  sub _encode_hex { unpack 'H*', $_[0] }
  sub _encode_base64 {
  	my $res;
  	while ($_[0] =~ /(.{1,45})/gs) {
  		$res .= substr pack('u', $1), 1;
  		chop $res;
  	}
  	$res =~ tr|` -_|AA-Za-z0-9+/|;#`
  	chop $res; chop $res;
  	$res
  }
  
  #########################################
  # OOP interface:
  sub new {
  	my $proto = shift;
  	my $class = ref $proto || $proto;
  	my $self = {};
  	bless $self, $class;
  	$self->reset();
  	$self
  }
  
  sub reset {
  	my $self = shift;
  	delete $self->{_data};
  	$self->{_state} = [A,B,C,D];
  	$self->{_length} = 0;
  	$self
  }
  
  sub add {
  	my $self = shift;
  	$self->{_data} .= join '', @_ if @_;
  	my ($i,$c);
  	for $i (0 .. (length $self->{_data})/64-1) {
  		my @X = unpack 'V16', substr $self->{_data}, $i*64, 64;
  		@{$self->{_state}} = round(@{$self->{_state}},@X);
  		++$c;
  	}
  	if ($c) {
  		substr ($self->{_data}, 0, $c*64) = '';
  		$self->{_length} += $c*64;
  	}
  	$self
  }
  
  sub finalize {
  	my $self = shift;
  	$self->{_data} .= chr(128);
      my $l = $self->{_length} + length $self->{_data};
      $self->{_data} .= "\0" x (($l%64<=56?56:120)-$l%64);
      $l = ($l-1)*8;
      $self->{_data} .= pack 'VV', $l & MAX , ($l >> 16 >> 16);
  	$self->add();
  	$self
  }
  
  sub addfile {
    	my ($self,$fh) = @_;
  	if (!ref($fh) && ref(\$fh) ne "GLOB") {
  	    require Symbol;
  	    $fh = Symbol::qualify($fh, scalar caller);
  	}
  	# $self->{_data} .= do{local$/;<$fh>};
  	my $read = 0;
  	my $buffer = '';
  	$self->add($buffer) while $read = read $fh, $buffer, 8192;
  	die __PACKAGE__, " read failed: $!" unless defined $read;
  	$self
  }
  
  sub add_bits {
  	my $self = shift;
  	return $self->add( pack 'B*', shift ) if @_ == 1;
  	my ($b,$n) = @_;
  	die __PACKAGE__, " Invalid number of bits\n" if $n%8;
  	$self->add( substr $b, 0, $n/8 )
  }
  
  sub digest {
  	my $self = shift;
  	$self->finalize();
  	my $res = pack 'V4', @{$self->{_state}};
  	$self->reset();
  	$res
  }
  
  sub hexdigest {
  	_encode_hex($_[0]->digest)
  }
  
  sub b64digest {
  	_encode_base64($_[0]->digest)
  }
  
  sub clone {
  	my $self = shift;
  	my $clone = { 
  		_state => [@{$self->{_state}}],
  		_length => $self->{_length},
  		_data => $self->{_data}
  	};
  	bless $clone, ref $self || $self;
  }
  
  #########################################
  # Procedural interface:
  sub md5 {
  	my $message = padding(join'',@_);
  	my ($a,$b,$c,$d) = (A,B,C,D);
  	my $i;
  	for $i (0 .. (length $message)/64-1) {
  		my @X = unpack 'V16', substr $message,$i*64,64;	
  		($a,$b,$c,$d) = round($a,$b,$c,$d,@X);
  	}
  	pack 'V4',$a,$b,$c,$d;
  }
  sub md5_hex { _encode_hex &md5 } 
  sub md5_base64 { _encode_base64 &md5 }
  
  
  1;
  
  =head1 NAME
  
  Digest::MD5::Perl - Perl implementation of Ron Rivests MD5 Algorithm
  
  =head1 DISCLAIMER
  
  This is B<not> an interface (like C<Digest::MD5>) but a Perl implementation of MD5.
  It is written in perl only and because of this it is slow but it works without C-Code.
  You should use C<Digest::MD5> instead of this module if it is available.
  This module is only useful for
  
  =over 4
  
  =item
  
  computers where you cannot install C<Digest::MD5> (e.g. lack of a C-Compiler)
  
  =item
  
  encrypting only small amounts of data (less than one million bytes). I use it to
  hash passwords.
  
  =item
  
  educational purposes
  
  =back
  
  =head1 SYNOPSIS
  
   # Functional style
   use Digest::MD5  qw(md5 md5_hex md5_base64);
  
   $hash = md5 $data;
   $hash = md5_hex $data;
   $hash = md5_base64 $data;
      
  
   # OO style
   use Digest::MD5;
  
   $ctx = Digest::MD5->new;
  
   $ctx->add($data);
   $ctx->addfile(*FILE);
  
   $digest = $ctx->digest;
   $digest = $ctx->hexdigest;
   $digest = $ctx->b64digest;
  
  =head1 DESCRIPTION
  
  This modules has the same interface as the much faster C<Digest::MD5>. So you can
  easily exchange them, e.g.
  
  	BEGIN {
  	  eval {
  	    require Digest::MD5;
  	    import Digest::MD5 'md5_hex'
  	  };
  	  if ($@) { # ups, no Digest::MD5
  	    require Digest::Perl::MD5;
  	    import Digest::Perl::MD5 'md5_hex'
  	  }		
  	}
  
  If the C<Digest::MD5> module is available it is used and if not you take
  C<Digest::Perl::MD5>.
  
  You can also install the Perl part of Digest::MD5 together with Digest::Perl::MD5
  and use Digest::MD5 as normal, it falls back to Digest::Perl::MD5 if it
  cannot load its object files.
  
  For a detailed Documentation see the C<Digest::MD5> module.
  
  =head1 EXAMPLES
  
  The simplest way to use this library is to import the md5_hex()
  function (or one of its cousins):
  
      use Digest::Perl::MD5 'md5_hex';
      print 'Digest is ', md5_hex('foobarbaz'), "\n";
  
  The above example would print out the message
  
      Digest is 6df23dc03f9b54cc38a0fc1483df6e21
  
  provided that the implementation is working correctly.  The same
  checksum can also be calculated in OO style:
  
      use Digest::MD5;
      
      $md5 = Digest::MD5->new;
      $md5->add('foo', 'bar');
      $md5->add('baz');
      $digest = $md5->hexdigest;
      
      print "Digest is $digest\n";
  
  The digest methods are destructive. That means you can only call them
  once and the $md5 objects is reset after use. You can make a copy with clone:
  
  	$md5->clone->hexdigest
  
  =head1 LIMITATIONS
  
  This implementation of the MD5 algorithm has some limitations:
  
  =over 4
  
  =item
  
  It's slow, very slow. I've done my very best but Digest::MD5 is still about 100 times faster.
  You can only encrypt Data up to one million bytes in an acceptable time. But it's very useful
  for encrypting small amounts of data like passwords.
  
  =item
  
  You can only encrypt up to 2^32 bits = 512 MB on 32bit archs. But You should
  use C<Digest::MD5> for those amounts of data anyway.
  
  =back
  
  =head1 SEE ALSO
  
  L<Digest::MD5>
  
  L<md5(1)>
  
  RFC 1321
  
  tools/md5: a small BSD compatible md5 tool written in pure perl.
  
  =head1 COPYRIGHT
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
   Copyright 2000 Christian Lackas, Imperia Software Solutions
   Copyright 1998-1999 Gisle Aas.
   Copyright 1995-1996 Neil Winton.
   Copyright 1991-1992 RSA Data Security, Inc.
  
  The MD5 algorithm is defined in RFC 1321. The basic C code
  implementing the algorithm is derived from that in the RFC and is
  covered by the following copyright:
  
  =over 4
  
  =item
  
  Copyright (C) 1991-1992, RSA Data Security, Inc. Created 1991. All
  rights reserved.
  
  License to copy and use this software is granted provided that it
  is identified as the "RSA Data Security, Inc. MD5 Message-Digest
  Algorithm" in all material mentioning or referencing this software
  or this function.
  
  License is also granted to make and use derivative works provided
  that such works are identified as "derived from the RSA Data
  Security, Inc. MD5 Message-Digest Algorithm" in all material
  mentioning or referencing the derived work.
  
  RSA Data Security, Inc. makes no representations concerning either
  the merchantability of this software or the suitability of this
  software for any particular purpose. It is provided "as is"
  without express or implied warranty of any kind.
  
  These notices must be retained in any copies of any part of this
  documentation and/or software.
  
  =back
  
  This copyright does not prohibit distribution of any version of Perl
  containing this extension under the terms of the GNU or Artistic
  licenses.
  
  =head1 AUTHORS
  
  The original MD5 interface was written by Neil Winton
  (<N.Winton (at) axion.bt.co.uk>).
  
  C<Digest::MD5> was made by Gisle Aas <gisle (at) aas.no> (I took his Interface
  and part of the documentation).
  
  Thanks to Guido Flohr for his 'use integer'-hint.
  
  This release was made by Christian Lackas <delta (at) lackas.net>.
  
  =cut
  
  __DATA__
  FF,$a,$b,$c,$d,$_[4],7,0xd76aa478,/* 1 */
  FF,$d,$a,$b,$c,$_[5],12,0xe8c7b756,/* 2 */
  FF,$c,$d,$a,$b,$_[6],17,0x242070db,/* 3 */
  FF,$b,$c,$d,$a,$_[7],22,0xc1bdceee,/* 4 */
  FF,$a,$b,$c,$d,$_[8],7,0xf57c0faf,/* 5 */
  FF,$d,$a,$b,$c,$_[9],12,0x4787c62a,/* 6 */
  FF,$c,$d,$a,$b,$_[10],17,0xa8304613,/* 7 */
  FF,$b,$c,$d,$a,$_[11],22,0xfd469501,/* 8 */
  FF,$a,$b,$c,$d,$_[12],7,0x698098d8,/* 9 */
  FF,$d,$a,$b,$c,$_[13],12,0x8b44f7af,/* 10 */
  FF,$c,$d,$a,$b,$_[14],17,0xffff5bb1,/* 11 */
  FF,$b,$c,$d,$a,$_[15],22,0x895cd7be,/* 12 */
  FF,$a,$b,$c,$d,$_[16],7,0x6b901122,/* 13 */
  FF,$d,$a,$b,$c,$_[17],12,0xfd987193,/* 14 */
  FF,$c,$d,$a,$b,$_[18],17,0xa679438e,/* 15 */
  FF,$b,$c,$d,$a,$_[19],22,0x49b40821,/* 16 */ 
  GG,$a,$b,$c,$d,$_[5],5,0xf61e2562,/* 17 */
  GG,$d,$a,$b,$c,$_[10],9,0xc040b340,/* 18 */
  GG,$c,$d,$a,$b,$_[15],14,0x265e5a51,/* 19 */
  GG,$b,$c,$d,$a,$_[4],20,0xe9b6c7aa,/* 20 */
  GG,$a,$b,$c,$d,$_[9],5,0xd62f105d,/* 21 */
  GG,$d,$a,$b,$c,$_[14],9,0x2441453,/* 22 */
  GG,$c,$d,$a,$b,$_[19],14,0xd8a1e681,/* 23 */
  GG,$b,$c,$d,$a,$_[8],20,0xe7d3fbc8,/* 24 */
  GG,$a,$b,$c,$d,$_[13],5,0x21e1cde6,/* 25 */
  GG,$d,$a,$b,$c,$_[18],9,0xc33707d6,/* 26 */
  GG,$c,$d,$a,$b,$_[7],14,0xf4d50d87,/* 27 */
  GG,$b,$c,$d,$a,$_[12],20,0x455a14ed,/* 28 */
  GG,$a,$b,$c,$d,$_[17],5,0xa9e3e905,/* 29 */
  GG,$d,$a,$b,$c,$_[6],9,0xfcefa3f8,/* 30 */
  GG,$c,$d,$a,$b,$_[11],14,0x676f02d9,/* 31 */
  GG,$b,$c,$d,$a,$_[16],20,0x8d2a4c8a,/* 32 */
  HH,$a,$b,$c,$d,$_[9],4,0xfffa3942,/* 33 */
  HH,$d,$a,$b,$c,$_[12],11,0x8771f681,/* 34 */
  HH,$c,$d,$a,$b,$_[15],16,0x6d9d6122,/* 35 */
  HH,$b,$c,$d,$a,$_[18],23,0xfde5380c,/* 36 */
  HH,$a,$b,$c,$d,$_[5],4,0xa4beea44,/* 37 */
  HH,$d,$a,$b,$c,$_[8],11,0x4bdecfa9,/* 38 */
  HH,$c,$d,$a,$b,$_[11],16,0xf6bb4b60,/* 39 */
  HH,$b,$c,$d,$a,$_[14],23,0xbebfbc70,/* 40 */
  HH,$a,$b,$c,$d,$_[17],4,0x289b7ec6,/* 41 */
  HH,$d,$a,$b,$c,$_[4],11,0xeaa127fa,/* 42 */
  HH,$c,$d,$a,$b,$_[7],16,0xd4ef3085,/* 43 */
  HH,$b,$c,$d,$a,$_[10],23,0x4881d05,/* 44 */
  HH,$a,$b,$c,$d,$_[13],4,0xd9d4d039,/* 45 */
  HH,$d,$a,$b,$c,$_[16],11,0xe6db99e5,/* 46 */
  HH,$c,$d,$a,$b,$_[19],16,0x1fa27cf8,/* 47 */
  HH,$b,$c,$d,$a,$_[6],23,0xc4ac5665,/* 48 */
  II,$a,$b,$c,$d,$_[4],6,0xf4292244,/* 49 */
  II,$d,$a,$b,$c,$_[11],10,0x432aff97,/* 50 */
  II,$c,$d,$a,$b,$_[18],15,0xab9423a7,/* 51 */
  II,$b,$c,$d,$a,$_[9],21,0xfc93a039,/* 52 */
  II,$a,$b,$c,$d,$_[16],6,0x655b59c3,/* 53 */
  II,$d,$a,$b,$c,$_[7],10,0x8f0ccc92,/* 54 */
  II,$c,$d,$a,$b,$_[14],15,0xffeff47d,/* 55 */
  II,$b,$c,$d,$a,$_[5],21,0x85845dd1,/* 56 */
  II,$a,$b,$c,$d,$_[12],6,0x6fa87e4f,/* 57 */
  II,$d,$a,$b,$c,$_[19],10,0xfe2ce6e0,/* 58 */
  II,$c,$d,$a,$b,$_[10],15,0xa3014314,/* 59 */
  II,$b,$c,$d,$a,$_[17],21,0x4e0811a1,/* 60 */
  II,$a,$b,$c,$d,$_[8],6,0xf7537e82,/* 61 */
  II,$d,$a,$b,$c,$_[15],10,0xbd3af235,/* 62 */
  II,$c,$d,$a,$b,$_[6],15,0x2ad7d2bb,/* 63 */
  II,$b,$c,$d,$a,$_[13],21,0xeb86d391,/* 64 */
DIGEST_PERL_MD5

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  # vim: ts=4 sts=4 sw=4 et:
  package HTTP::Tiny;
  use strict;
  use warnings;
  # ABSTRACT: A small, simple, correct HTTP/1.1 client
  
  our $VERSION = '0.058';
  
  use Carp ();
  
  #pod =method new
  #pod
  #pod     $http = HTTP::Tiny->new( %attributes );
  #pod
  #pod This constructor returns a new HTTP::Tiny object.  Valid attributes include:
  #pod
  #pod =for :list
  #pod * C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If
  #pod   C<agent> — ends in a space character, the default user-agent string is
  #pod   appended.
  #pod * C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class
  #pod   that supports the C<add> and C<cookie_header> methods
  #pod * C<default_headers> — A hashref of default headers to apply to requests
  #pod * C<local_address> — The local IP address to bind to
  #pod * C<keep_alive> — Whether to reuse the last connection (if for the same
  #pod   scheme, host and port) (defaults to 1)
  #pod * C<max_redirect> — Maximum number of redirects allowed (defaults to 5)
  #pod * C<max_size> — Maximum response size in bytes (only when not using a data
  #pod   callback).  If defined, responses larger than this will return an
  #pod   exception.
  #pod * C<http_proxy> — URL of a proxy server to use for HTTP connections
  #pod   (default is C<$ENV{http_proxy}> — if set)
  #pod * C<https_proxy> — URL of a proxy server to use for HTTPS connections
  #pod   (default is C<$ENV{https_proxy}> — if set)
  #pod * C<proxy> — URL of a generic proxy server for both HTTP and HTTPS
  #pod   connections (default is C<$ENV{all_proxy}> — if set)
  #pod * C<no_proxy> — List of domain suffixes that should not be proxied.  Must
  #pod   be a comma-separated string or an array reference. (default is
  #pod   C<$ENV{no_proxy}> —)
  #pod * C<timeout> — Request timeout in seconds (default is 60) If a socket open,
  #pod   read or write takes longer than the timeout, an exception is thrown.
  #pod * C<verify_SSL> — A boolean that indicates whether to validate the SSL
  #pod   certificate of an C<https> — connection (default is false)
  #pod * C<SSL_options> — A hashref of C<SSL_*> — options to pass through to
  #pod   L<IO::Socket::SSL>
  #pod
  #pod Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
  #pod prevent getting the corresponding proxies from the environment.
  #pod
  #pod Exceptions from C<max_size>, C<timeout> or other errors will result in a
  #pod pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
  #pod content field in the response will contain the text of the exception.
  #pod
  #pod The C<keep_alive> parameter enables a persistent connection, but only to a
  #pod single destination scheme, host and port.  Also, if any connection-relevant
  #pod attributes are modified, or if the process ID or thread ID change, the
  #pod persistent connection will be dropped.  If you want persistent connections
  #pod across multiple destinations, use multiple HTTP::Tiny objects.
  #pod
  #pod See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
  #pod
  #pod =cut
  
  my @attributes;
  BEGIN {
      @attributes = qw(
          cookie_jar default_headers http_proxy https_proxy keep_alive
          local_address max_redirect max_size proxy no_proxy
          SSL_options verify_SSL
      );
      my %persist_ok = map {; $_ => 1 } qw(
          cookie_jar default_headers max_redirect max_size
      );
      no strict 'refs';
      no warnings 'uninitialized';
      for my $accessor ( @attributes ) {
          *{$accessor} = sub {
              @_ > 1
                  ? do {
                      delete $_[0]->{handle} if !$persist_ok{$accessor} && $_[1] ne $_[0]->{$accessor};
                      $_[0]->{$accessor} = $_[1]
                  }
                  : $_[0]->{$accessor};
          };
      }
  }
  
  sub agent {
      my($self, $agent) = @_;
      if( @_ > 1 ){
          $self->{agent} =
              (defined $agent && $agent =~ / $/) ? $agent . $self->_agent : $agent;
      }
      return $self->{agent};
  }
  
  sub timeout {
      my ($self, $timeout) = @_;
      if ( @_ > 1 ) {
          $self->{timeout} = $timeout;
          if ($self->{handle}) {
              $self->{handle}->timeout($timeout);
          }
      }
      return $self->{timeout};
  }
  
  sub new {
      my($class, %args) = @_;
  
      my $self = {
          max_redirect => 5,
          timeout      => 60,
          keep_alive   => 1,
          verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, # no verification by default
          no_proxy     => $ENV{no_proxy},
      };
  
      bless $self, $class;
  
      $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};
  
      for my $key ( @attributes ) {
          $self->{$key} = $args{$key} if exists $args{$key}
      }
  
      $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );
  
      $self->_set_proxies;
  
      return $self;
  }
  
  sub _set_proxies {
      my ($self) = @_;
  
      # get proxies from %ENV only if not provided; explicit undef will disable
      # getting proxies from the environment
  
      # generic proxy
      if (! exists $self->{proxy} ) {
          $self->{proxy} = $ENV{all_proxy} || $ENV{ALL_PROXY};
      }
  
      if ( defined $self->{proxy} ) {
          $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
      }
      else {
          delete $self->{proxy};
      }
  
      # http proxy
      if (! exists $self->{http_proxy} ) {
          # under CGI, bypass HTTP_PROXY as request sets it from Proxy header
          local $ENV{HTTP_PROXY} if $ENV{REQUEST_METHOD};
          $self->{http_proxy} = $ENV{http_proxy} || $ENV{HTTP_PROXY} || $self->{proxy};
      }
  
      if ( defined $self->{http_proxy} ) {
          $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
          $self->{_has_proxy}{http} = 1;
      }
      else {
          delete $self->{http_proxy};
      }
  
      # https proxy
      if (! exists $self->{https_proxy} ) {
          $self->{https_proxy} = $ENV{https_proxy} || $ENV{HTTPS_PROXY} || $self->{proxy};
      }
  
      if ( $self->{https_proxy} ) {
          $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
          $self->{_has_proxy}{https} = 1;
      }
      else {
          delete $self->{https_proxy};
      }
  
      # Split no_proxy to array reference if not provided as such
      unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
          $self->{no_proxy} =
              (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
      }
  
      return;
  }
  
  #pod =method get|head|put|post|delete
  #pod
  #pod     $response = $http->get($url);
  #pod     $response = $http->get($url, \%options);
  #pod     $response = $http->head($url);
  #pod
  #pod These methods are shorthand for calling C<request()> for the given method.  The
  #pod URL must have unsafe characters escaped and international domain names encoded.
  #pod See C<request()> for valid options and a description of the response.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX.
  #pod
  #pod =cut
  
  for my $sub_name ( qw/get head put post delete/ ) {
      my $req_method = uc $sub_name;
      no strict 'refs';
      eval <<"HERE"; ## no critic
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
  }
  
  #pod =method post_form
  #pod
  #pod     $response = $http->post_form($url, $form_data);
  #pod     $response = $http->post_form($url, $form_data, \%options);
  #pod
  #pod This method executes a C<POST> request and sends the key/value pairs from a
  #pod form data hash or array reference to the given URL with a C<content-type> of
  #pod C<application/x-www-form-urlencoded>.  If data is provided as an array
  #pod reference, the order is preserved; if provided as a hash reference, the terms
  #pod are sorted on key and value for consistency.  See documentation for the
  #pod C<www_form_urlencode> method for details on the encoding.
  #pod
  #pod The URL must have unsafe characters escaped and international domain names
  #pod encoded.  See C<request()> for valid options and a description of the response.
  #pod Any C<content-type> header or content in the options hashref will be ignored.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX.
  #pod
  #pod =cut
  
  sub post_form {
      my ($self, $url, $data, $args) = @_;
      (@_ == 3 || @_ == 4 && ref $args eq 'HASH')
          or Carp::croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ . "\n");
  
      my $headers = {};
      while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
          $headers->{lc $key} = $value;
      }
      delete $args->{headers};
  
      return $self->request('POST', $url, {
              %$args,
              content => $self->www_form_urlencode($data),
              headers => {
                  %$headers,
                  'content-type' => 'application/x-www-form-urlencoded'
              },
          }
      );
  }
  
  #pod =method mirror
  #pod
  #pod     $response = $http->mirror($url, $file, \%options)
  #pod     if ( $response->{success} ) {
  #pod         print "$file is up to date\n";
  #pod     }
  #pod
  #pod Executes a C<GET> request for the URL and saves the response body to the file
  #pod name provided.  The URL must have unsafe characters escaped and international
  #pod domain names encoded.  If the file already exists, the request will include an
  #pod C<If-Modified-Since> header with the modification timestamp of the file.  You
  #pod may specify a different C<If-Modified-Since> header yourself in the C<<
  #pod $options->{headers} >> hash.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX
  #pod or if the status code is 304 (unmodified).
  #pod
  #pod If the file was modified and the server response includes a properly
  #pod formatted C<Last-Modified> header, the file modification time will
  #pod be updated accordingly.
  #pod
  #pod =cut
  
  sub mirror {
      my ($self, $url, $file, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ . "\n");
      if ( -e $file and my $mtime = (stat($file))[9] ) {
          $args->{headers}{'if-modified-since'} ||= $self->_http_date($mtime);
      }
      my $tempfile = $file . int(rand(2**31));
  
      require Fcntl;
      sysopen my $fh, $tempfile, Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()
         or Carp::croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);
      binmode $fh;
      $args->{data_callback} = sub { print {$fh} $_[0] };
      my $response = $self->request('GET', $url, $args);
      close $fh
          or Carp::croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);
  
      if ( $response->{success} ) {
          rename $tempfile, $file
              or Carp::croak(qq/Error replacing $file with $tempfile: $!\n/);
          my $lm = $response->{headers}{'last-modified'};
          if ( $lm and my $mtime = $self->_parse_http_date($lm) ) {
              utime $mtime, $mtime, $file;
          }
      }
      $response->{success} ||= $response->{status} eq '304';
      unlink $tempfile;
      return $response;
  }
  
  #pod =method request
  #pod
  #pod     $response = $http->request($method, $url);
  #pod     $response = $http->request($method, $url, \%options);
  #pod
  #pod Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
  #pod 'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
  #pod international domain names encoded.
  #pod
  #pod If the URL includes a "user:password" stanza, they will be used for Basic-style
  #pod authorization headers.  (Authorization headers will not be included in a
  #pod redirected request.) For example:
  #pod
  #pod     $http->request('GET', 'http://Aladdin:open sesame@example.com/');
  #pod
  #pod If the "user:password" stanza contains reserved characters, they must
  #pod be percent-escaped:
  #pod
  #pod     $http->request('GET', 'http://john%40example.com:password@example.com/');
  #pod
  #pod A hashref of options may be appended to modify the request.
  #pod
  #pod Valid options are:
  #pod
  #pod =for :list
  #pod * C<headers> —
  #pod     A hashref containing headers to include with the request.  If the value for
  #pod     a header is an array reference, the header will be output multiple times with
  #pod     each value in the array.  These headers over-write any default headers.
  #pod * C<content> —
  #pod     A scalar to include as the body of the request OR a code reference
  #pod     that will be called iteratively to produce the body of the request
  #pod * C<trailer_callback> —
  #pod     A code reference that will be called if it exists to provide a hashref
  #pod     of trailing headers (only used with chunked transfer-encoding)
  #pod * C<data_callback> —
  #pod     A code reference that will be called for each chunks of the response
  #pod     body received.
  #pod * C<peer> —
  #pod     Override host resolution and force all connections to go only to a
  #pod     specific peer address, regardless of the URL of the request.  This will
  #pod     include any redirections!  This options should be used with extreme
  #pod     caution (e.g. debugging or very special circumstances).
  #pod
  #pod The C<Host> header is generated from the URL in accordance with RFC 2616.  It
  #pod is a fatal error to specify C<Host> in the C<headers> option.  Other headers
  #pod may be ignored or overwritten if necessary for transport compliance.
  #pod
  #pod If the C<content> option is a code reference, it will be called iteratively
  #pod to provide the content body of the request.  It should return the empty
  #pod string or undef when the iterator is exhausted.
  #pod
  #pod If the C<content> option is the empty string, no C<content-type> or
  #pod C<content-length> headers will be generated.
  #pod
  #pod If the C<data_callback> option is provided, it will be called iteratively until
  #pod the entire response body is received.  The first argument will be a string
  #pod containing a chunk of the response body, the second argument will be the
  #pod in-progress response hash reference, as described below.  (This allows
  #pod customizing the action of the callback based on the C<status> or C<headers>
  #pod received prior to the content body.)
  #pod
  #pod The C<request> method returns a hashref containing the response.  The hashref
  #pod will have the following keys:
  #pod
  #pod =for :list
  #pod * C<success> —
  #pod     Boolean indicating whether the operation returned a 2XX status code
  #pod * C<url> —
  #pod     URL that provided the response. This is the URL of the request unless
  #pod     there were redirections, in which case it is the last URL queried
  #pod     in a redirection chain
  #pod * C<status> —
  #pod     The HTTP status code of the response
  #pod * C<reason> —
  #pod     The response phrase returned by the server
  #pod * C<content> —
  #pod     The body of the response.  If the response does not have any content
  #pod     or if a data callback is provided to consume the response body,
  #pod     this will be the empty string
  #pod * C<headers> —
  #pod     A hashref of header fields.  All header field names will be normalized
  #pod     to be lower case. If a header is repeated, the value will be an arrayref;
  #pod     it will otherwise be a scalar string containing the value
  #pod * C<redirects>
  #pod     If this field exists, it is an arrayref of response hash references from
  #pod     redirects in the same order that redirections occurred.  If it does
  #pod     not exist, then no redirections occurred.
  #pod
  #pod On an exception during the execution of the request, the C<status> field will
  #pod contain 599, and the C<content> field will contain the text of the exception.
  #pod
  #pod =cut
  
  my %idempotent = map { $_ => 1 } qw/GET HEAD PUT DELETE OPTIONS TRACE/;
  
  sub request {
      my ($self, $method, $url, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ . "\n");
      $args ||= {}; # we keep some state in this during _request
  
      # RFC 2616 Section 8.1.4 mandates a single retry on broken socket
      my $response;
      for ( 0 .. 1 ) {
          $response = eval { $self->_request($method, $url, $args) };
          last unless $@ && $idempotent{$method}
              && $@ =~ m{^(?:Socket closed|Unexpected end)};
      }
  
      if (my $e = $@) {
          # maybe we got a response hash thrown from somewhere deep
          if ( ref $e eq 'HASH' && exists $e->{status} ) {
              return $e;
          }
  
          # otherwise, stringify it
          $e = "$e";
          $response = {
              url     => $url,
              success => q{},
              status  => 599,
              reason  => 'Internal Exception',
              content => $e,
              headers => {
                  'content-type'   => 'text/plain',
                  'content-length' => length $e,
              }
          };
      }
      return $response;
  }
  
  #pod =method www_form_urlencode
  #pod
  #pod     $params = $http->www_form_urlencode( $data );
  #pod     $response = $http->get("http://example.com/query?$params");
  #pod
  #pod This method converts the key/value pairs from a data hash or array reference
  #pod into a C<x-www-form-urlencoded> string.  The keys and values from the data
  #pod reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
  #pod array reference, the key will be repeated with each of the values of the array
  #pod reference.  If data is provided as a hash reference, the key/value pairs in the
  #pod resulting string will be sorted by key and value for consistent ordering.
  #pod
  #pod =cut
  
  sub www_form_urlencode {
      my ($self, $data) = @_;
      (@_ == 2 && ref $data)
          or Carp::croak(q/Usage: $http->www_form_urlencode(DATAREF)/ . "\n");
      (ref $data eq 'HASH' || ref $data eq 'ARRAY')
          or Carp::croak("form data must be a hash or array reference\n");
  
      my @params = ref $data eq 'HASH' ? %$data : @$data;
      @params % 2 == 0
          or Carp::croak("form data reference must have an even number of terms\n");
  
      my @terms;
      while( @params ) {
          my ($key, $value) = splice(@params, 0, 2);
          if ( ref $value eq 'ARRAY' ) {
              unshift @params, map { $key => $_ } @$value;
          }
          else {
              push @terms, join("=", map { $self->_uri_escape($_) } $key, $value);
          }
      }
  
      return join("&", (ref $data eq 'ARRAY') ? (@terms) : (sort @terms) );
  }
  
  #pod =method can_ssl
  #pod
  #pod     $ok         = HTTP::Tiny->can_ssl;
  #pod     ($ok, $why) = HTTP::Tiny->can_ssl;
  #pod     ($ok, $why) = $http->can_ssl;
  #pod
  #pod Indicates if SSL support is available.  When called as a class object, it
  #pod checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
  #pod When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
  #pod is set in C<SSL_options>, it checks that a CA file is available.
  #pod
  #pod In scalar context, returns a boolean indicating if SSL is available.
  #pod In list context, returns the boolean and a (possibly multi-line) string of
  #pod errors indicating why SSL isn't available.
  #pod
  #pod =cut
  
  sub can_ssl {
      my ($self) = @_;
  
      my($ok, $reason) = (1, '');
  
      # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
      unless (eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)}) {
          $ok = 0;
          $reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/;
      }
  
      # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
      unless (eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)}) {
          $ok = 0;
          $reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/;
      }
  
      # If an object, check that SSL config lets us get a CA if necessary
      if ( ref($self) && ( $self->{verify_SSL} || $self->{SSL_options}{SSL_verify_mode} ) ) {
          my $handle = HTTP::Tiny::Handle->new(
              SSL_options => $self->{SSL_options},
              verify_SSL  => $self->{verify_SSL},
          );
          unless ( eval { $handle->_find_CA_file; 1 } ) {
              $ok = 0;
              $reason .= "$@";
          }
      }
  
      wantarray ? ($ok, $reason) : $ok;
  }
  
  #pod =method connected
  #pod
  #pod     $host = $http->connected;
  #pod     ($host, $port) = $http->connected;
  #pod
  #pod Indicates if a connection to a peer is being kept alive, per the C<keep_alive>
  #pod option.
  #pod
  #pod In scalar context, returns the peer host and port, joined with a colon, or
  #pod C<undef> (if no peer is connected).
  #pod In list context, returns the peer host and port or an empty list (if no peer
  #pod is connected).
  #pod
  #pod B<Note>: This method cannot reliably be used to discover whether the remote
  #pod host has closed its end of the socket.
  #pod
  #pod =cut
  
  sub connected {
      my ($self) = @_;
  
      # If a socket exists...
      if ($self->{handle} && $self->{handle}{fh}) {
          my $socket = $self->{handle}{fh};
  
          # ...and is connected, return the peer host and port.
          if ($socket->connected) {
              return wantarray
                  ? ($socket->peerhost, $socket->peerport)
                  : join(':', $socket->peerhost, $socket->peerport);
          }
      }
      return;
  }
  
  #--------------------------------------------------------------------------#
  # private methods
  #--------------------------------------------------------------------------#
  
  my %DefaultPort = (
      http => 80,
      https => 443,
  );
  
  sub _agent {
      my $class = ref($_[0]) || $_[0];
      (my $default_agent = $class) =~ s{::}{-}g;
      return $default_agent . "/" . $class->VERSION;
  }
  
  sub _request {
      my ($self, $method, $url, $args) = @_;
  
      my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);
  
      my $request = {
          method    => $method,
          scheme    => $scheme,
          host      => $host,
          port      => $port,
          host_port => ($port == $DefaultPort{$scheme} ? $host : "$host:$port"),
          uri       => $path_query,
          headers   => {},
      };
  
      my $peer = $args->{peer} || $host;
  
      # We remove the cached handle so it is not reused in the case of redirect.
      # If all is well, it will be recached at the end of _request.  We only
      # reuse for the same scheme, host and port
      my $handle = delete $self->{handle};
      if ( $handle ) {
          unless ( $handle->can_reuse( $scheme, $host, $port, $peer ) ) {
              $handle->close;
              undef $handle;
          }
      }
      $handle ||= $self->_open_handle( $request, $scheme, $host, $port, $peer );
  
      $self->_prepare_headers_and_cb($request, $args, $url, $auth);
      $handle->write_request($request);
  
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
  
      $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};
      my @redir_args = $self->_maybe_redirect($request, $response, $args);
  
      my $known_message_length;
      if ($method eq 'HEAD' || $response->{status} =~ /^[23]04/) {
          # response has no message body
          $known_message_length = 1;
      }
      else {
          # Ignore any data callbacks during redirection.
          my $cb_args = @redir_args ? +{} : $args;
          my $data_cb = $self->_prepare_data_cb($response, $cb_args);
          $known_message_length = $handle->read_body($data_cb, $response);
      }
  
      if ( $self->{keep_alive}
          && $known_message_length
          && $response->{protocol} eq 'HTTP/1.1'
          && ($response->{headers}{connection} || '') ne 'close'
      ) {
          $self->{handle} = $handle;
      }
      else {
          $handle->close;
      }
  
      $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
      $response->{url} = $url;
  
      # Push the current response onto the stack of redirects if redirecting.
      if (@redir_args) {
          push @{$args->{_redirects}}, $response;
          return $self->_request(@redir_args, $args);
      }
  
      # Copy the stack of redirects into the response before returning.
      $response->{redirects} = delete $args->{_redirects}
        if @{$args->{_redirects}};
      return $response;
  }
  
  sub _open_handle {
      my ($self, $request, $scheme, $host, $port, $peer) = @_;
  
      my $handle  = HTTP::Tiny::Handle->new(
          timeout         => $self->{timeout},
          SSL_options     => $self->{SSL_options},
          verify_SSL      => $self->{verify_SSL},
          local_address   => $self->{local_address},
          keep_alive      => $self->{keep_alive}
      );
  
      if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @{$self->{no_proxy}}) {
          return $self->_proxy_connect( $request, $handle );
      }
      else {
          return $handle->connect($scheme, $host, $port, $peer);
      }
  }
  
  sub _proxy_connect {
      my ($self, $request, $handle) = @_;
  
      my @proxy_vars;
      if ( $request->{scheme} eq 'https' ) {
          Carp::croak(qq{No https_proxy defined}) unless $self->{https_proxy};
          @proxy_vars = $self->_split_proxy( https_proxy => $self->{https_proxy} );
          if ( $proxy_vars[0] eq 'https' ) {
              Carp::croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}});
          }
      }
      else {
          Carp::croak(qq{No http_proxy defined}) unless $self->{http_proxy};
          @proxy_vars = $self->_split_proxy( http_proxy => $self->{http_proxy} );
      }
  
      my ($p_scheme, $p_host, $p_port, $p_auth) = @proxy_vars;
  
      if ( length $p_auth && ! defined $request->{headers}{'proxy-authorization'} ) {
          $self->_add_basic_auth_header( $request, 'proxy-authorization' => $p_auth );
      }
  
      $handle->connect($p_scheme, $p_host, $p_port, $p_host);
  
      if ($request->{scheme} eq 'https') {
          $self->_create_proxy_tunnel( $request, $handle );
      }
      else {
          # non-tunneled proxy requires absolute URI
          $request->{uri} = "$request->{scheme}://$request->{host_port}$request->{uri}";
      }
  
      return $handle;
  }
  
  sub _split_proxy {
      my ($self, $type, $proxy) = @_;
  
      my ($scheme, $host, $port, $path_query, $auth) = eval { $self->_split_url($proxy) };
  
      unless(
          defined($scheme) && length($scheme) && length($host) && length($port)
          && $path_query eq '/'
      ) {
          Carp::croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n});
      }
  
      return ($scheme, $host, $port, $auth);
  }
  
  sub _create_proxy_tunnel {
      my ($self, $request, $handle) = @_;
  
      $handle->_assert_ssl;
  
      my $agent = exists($request->{headers}{'user-agent'})
          ? $request->{headers}{'user-agent'} : $self->{agent};
  
      my $connect_request = {
          method    => 'CONNECT',
          uri       => "$request->{host}:$request->{port}",
          headers   => {
              host => "$request->{host}:$request->{port}",
              'user-agent' => $agent,
          }
      };
  
      if ( $request->{headers}{'proxy-authorization'} ) {
          $connect_request->{headers}{'proxy-authorization'} =
              delete $request->{headers}{'proxy-authorization'};
      }
  
      $handle->write_request($connect_request);
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
  
      # if CONNECT failed, throw the response so it will be
      # returned from the original request() method;
      unless (substr($response->{status},0,1) eq '2') {
          die $response;
      }
  
      # tunnel established, so start SSL handshake
      $handle->start_ssl( $request->{host} );
  
      return;
  }
  
  sub _prepare_headers_and_cb {
      my ($self, $request, $args, $url, $auth) = @_;
  
      for ($self->{default_headers}, $args->{headers}) {
          next unless defined;
          while (my ($k, $v) = each %$_) {
              $request->{headers}{lc $k} = $v;
              $request->{header_case}{lc $k} = $k;
          }
      }
  
      if (exists $request->{headers}{'host'}) {
          die(qq/The 'Host' header must not be provided as header option\n/);
      }
  
      $request->{headers}{'host'}         = $request->{host_port};
      $request->{headers}{'user-agent'} ||= $self->{agent};
      $request->{headers}{'connection'}   = "close"
          unless $self->{keep_alive};
  
      if ( defined $args->{content} ) {
          if (ref $args->{content} eq 'CODE') {
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'transfer-encoding'} = 'chunked'
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = $args->{content};
          }
          elsif ( length $args->{content} ) {
              my $content = $args->{content};
              if ( $] ge '5.008' ) {
                  utf8::downgrade($content, 1)
                      or die(qq/Wide character in request message body\n/);
              }
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'content-length'} = length $content
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = sub { substr $content, 0, length $content, '' };
          }
          $request->{trailer_cb} = $args->{trailer_callback}
              if ref $args->{trailer_callback} eq 'CODE';
      }
  
      ### If we have a cookie jar, then maybe add relevant cookies
      if ( $self->{cookie_jar} ) {
          my $cookies = $self->cookie_jar->cookie_header( $url );
          $request->{headers}{cookie} = $cookies if length $cookies;
      }
  
      # if we have Basic auth parameters, add them
      if ( length $auth && ! defined $request->{headers}{authorization} ) {
          $self->_add_basic_auth_header( $request, 'authorization' => $auth );
      }
  
      return;
  }
  
  sub _add_basic_auth_header {
      my ($self, $request, $header, $auth) = @_;
      require MIME::Base64;
      $request->{headers}{$header} =
          "Basic " . MIME::Base64::encode_base64($auth, "");
      return;
  }
  
  sub _prepare_data_cb {
      my ($self, $response, $args) = @_;
      my $data_cb = $args->{data_callback};
      $response->{content} = '';
  
      if (!$data_cb || $response->{status} !~ /^2/) {
          if (defined $self->{max_size}) {
              $data_cb = sub {
                  $_[1]->{content} .= $_[0];
                  die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
                    if length $_[1]->{content} > $self->{max_size};
              };
          }
          else {
              $data_cb = sub { $_[1]->{content} .= $_[0] };
          }
      }
      return $data_cb;
  }
  
  sub _update_cookie_jar {
      my ($self, $url, $response) = @_;
  
      my $cookies = $response->{headers}->{'set-cookie'};
      return unless defined $cookies;
  
      my @cookies = ref $cookies ? @$cookies : $cookies;
  
      $self->cookie_jar->add( $url, $_ ) for @cookies;
  
      return;
  }
  
  sub _validate_cookie_jar {
      my ($class, $jar) = @_;
  
      # duck typing
      for my $method ( qw/add cookie_header/ ) {
          Carp::croak(qq/Cookie jar must provide the '$method' method\n/)
              unless ref($jar) && ref($jar)->can($method);
      }
  
      return;
  }
  
  sub _maybe_redirect {
      my ($self, $request, $response, $args) = @_;
      my $headers = $response->{headers};
      my ($status, $method) = ($response->{status}, $request->{method});
      $args->{_redirects} ||= [];
  
      if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))
          and $headers->{location}
          and @{$args->{_redirects}} < $self->{max_redirect}
      ) {
          my $location = ($headers->{location} =~ /^\//)
              ? "$request->{scheme}://$request->{host_port}$headers->{location}"
              : $headers->{location} ;
          return (($status eq '303' ? 'GET' : $method), $location);
      }
      return;
  }
  
  sub _split_url {
      my $url = pop;
  
      # URI regex adapted from the URI module
      my ($scheme, $host, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
        or die(qq/Cannot parse URL: '$url'\n/);
  
      $scheme     = lc $scheme;
      $path_query = "/$path_query" unless $path_query =~ m<\A/>;
  
      my $auth = '';
      if ( (my $i = index $host, '@') != -1 ) {
          # user:pass@host
          $auth = substr $host, 0, $i, ''; # take up to the @ for auth
          substr $host, 0, 1, '';          # knock the @ off the host
  
          # userinfo might be percent escaped, so recover real auth info
          $auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
      }
      my $port = $host =~ s/:(\d*)\z// && length $1 ? $1
               : $scheme eq 'http'                  ? 80
               : $scheme eq 'https'                 ? 443
               : undef;
  
      return ($scheme, (length $host ? lc $host : "localhost") , $port, $path_query, $auth);
  }
  
  # Date conversions adapted from HTTP::Date
  my $DoW = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
  my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
  sub _http_date {
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($_[1]);
      return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
          substr($DoW,$wday*4,3),
          $mday, substr($MoY,$mon*4,3), $year+1900,
          $hour, $min, $sec
      );
  }
  
  sub _parse_http_date {
      my ($self, $str) = @_;
      require Time::Local;
      my @tl_parts;
      if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/ ) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/ ) {
          @tl_parts = ($5, $4, $3, $2, (index($MoY,$1)/4), $6);
      }
      return eval {
          my $t = @tl_parts ? Time::Local::timegm(@tl_parts) : -1;
          $t < 0 ? undef : $t;
      };
  }
  
  # URI escaping adapted from URI::Escape
  # c.f. http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
  # perl 5.6 ready UTF-8 encoding adapted from JSON::PP
  my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
  $escapes{' '}="+";
  my $unsafe_char = qr/[^A-Za-z0-9\-\._~]/;
  
  sub _uri_escape {
      my ($self, $str) = @_;
      if ( $] ge '5.008' ) {
          utf8::encode($str);
      }
      else {
          $str = pack("U*", unpack("C*", $str)) # UTF-8 encode a byte string
              if ( length $str == do { use bytes; length $str } );
          $str = pack("C*", unpack("C*", $str)); # clear UTF-8 flag
      }
      $str =~ s/($unsafe_char)/$escapes{$1}/ge;
      return $str;
  }
  
  package
      HTTP::Tiny::Handle; # hide from PAUSE/indexers
  use strict;
  use warnings;
  
  use Errno      qw[EINTR EPIPE];
  use IO::Socket qw[SOCK_STREAM];
  use Socket     qw[SOL_SOCKET SO_KEEPALIVE];
  
  # PERL_HTTP_TINY_IPV4_ONLY is a private environment variable to force old
  # behavior if someone is unable to boostrap CPAN from a new perl install; it is
  # not intended for general, per-client use and may be removed in the future
  my $SOCKET_CLASS =
      $ENV{PERL_HTTP_TINY_IPV4_ONLY} ? 'IO::Socket::INET' :
      eval { require IO::Socket::IP; IO::Socket::IP->VERSION(0.25) } ? 'IO::Socket::IP' :
      'IO::Socket::INET';
  
  sub BUFSIZE () { 32768 } ## no critic
  
  my $Printable = sub {
      local $_ = shift;
      s/\r/\\r/g;
      s/\n/\\n/g;
      s/\t/\\t/g;
      s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;
      $_;
  };
  
  my $Token = qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;
  my $Field_Content = qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;
  
  sub new {
      my ($class, %args) = @_;
      return bless {
          rbuf             => '',
          timeout          => 60,
          max_line_size    => 16384,
          max_header_lines => 64,
          verify_SSL       => 0,
          SSL_options      => {},
          %args
      }, $class;
  }
  
  sub timeout {
      my ($self, $timeout) = @_;
      if ( @_ > 1 ) {
          $self->{timeout} = $timeout;
          if ( $self->{fh} && $self->{fh}->can('timeout') ) {
              $self->{fh}->timeout($timeout);
          }
      }
      return $self->{timeout};
  }
  
  sub connect {
      @_ == 5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ . "\n");
      my ($self, $scheme, $host, $port, $peer) = @_;
  
      if ( $scheme eq 'https' ) {
          $self->_assert_ssl;
      }
      elsif ( $scheme ne 'http' ) {
        die(qq/Unsupported URL scheme '$scheme'\n/);
      }
      $self->{fh} = $SOCKET_CLASS->new(
          PeerHost  => $peer,
          PeerPort  => $port,
          $self->{local_address} ?
              ( LocalAddr => $self->{local_address} ) : (),
          Proto     => 'tcp',
          Type      => SOCK_STREAM,
          Timeout   => $self->{timeout},
      ) or die(qq/Could not connect to '$host:$port': $@\n/);
  
      binmode($self->{fh})
        or die(qq/Could not binmode() socket: '$!'\n/);
  
      if ( $self->{keep_alive} ) {
          unless ( defined( $self->{fh}->setsockopt( SOL_SOCKET, SO_KEEPALIVE, 1 ) ) ) {
              CORE::close($self->{fh});
              die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/);
          }
      }
  
      $self->start_ssl($host) if $scheme eq 'https';
  
      $self->{scheme} = $scheme;
      $self->{host} = $host;
      $self->{peer} = $peer;
      $self->{port} = $port;
      $self->{pid} = $$;
      $self->{tid} = _get_tid();
  
      return $self;
  }
  
  sub start_ssl {
      my ($self, $host) = @_;
  
      # As this might be used via CONNECT after an SSL session
      # to a proxy, we shut down any existing SSL before attempting
      # the handshake
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          unless ( $self->{fh}->stop_SSL ) {
              my $ssl_err = IO::Socket::SSL->errstr;
              die(qq/Error halting prior SSL connection: $ssl_err/);
          }
      }
  
      my $ssl_args = $self->_ssl_args($host);
      IO::Socket::SSL->start_SSL(
          $self->{fh},
          %$ssl_args,
          SSL_create_ctx_callback => sub {
              my $ctx = shift;
              Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
          },
      );
  
      unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          my $ssl_err = IO::Socket::SSL->errstr;
          die(qq/SSL connection failed for $host: $ssl_err\n/);
      }
  }
  
  sub close {
      @_ == 1 || die(q/Usage: $handle->close()/ . "\n");
      my ($self) = @_;
      CORE::close($self->{fh})
        or die(qq/Could not close socket: '$!'\n/);
  }
  
  sub write {
      @_ == 2 || die(q/Usage: $handle->write(buf)/ . "\n");
      my ($self, $buf) = @_;
  
      if ( $] ge '5.008' ) {
          utf8::downgrade($buf, 1)
              or die(qq/Wide character in write()\n/);
      }
  
      my $len = length $buf;
      my $off = 0;
  
      local $SIG{PIPE} = 'IGNORE';
  
      while () {
          $self->can_write
            or die(qq/Timed out while waiting for socket to become ready for writing\n/);
          my $r = syswrite($self->{fh}, $buf, $len, $off);
          if (defined $r) {
              $len -= $r;
              $off += $r;
              last unless $len > 0;
          }
          elsif ($! == EPIPE) {
              die(qq/Socket closed by remote server: $!\n/);
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not write to SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not write to socket: '$!'\n/);
              }
  
          }
      }
      return $off;
  }
  
  sub read {
      @_ == 2 || @_ == 3 || die(q/Usage: $handle->read(len [, allow_partial])/ . "\n");
      my ($self, $len, $allow_partial) = @_;
  
      my $buf  = '';
      my $got = length $self->{rbuf};
  
      if ($got) {
          my $take = ($got < $len) ? $got : $len;
          $buf  = substr($self->{rbuf}, 0, $take, '');
          $len -= $take;
      }
  
      while ($len > 0) {
          $self->can_read
            or die(q/Timed out while waiting for socket to become ready for reading/ . "\n");
          my $r = sysread($self->{fh}, $buf, $len, length $buf);
          if (defined $r) {
              last unless $r;
              $len -= $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      if ($len && !$allow_partial) {
          die(qq/Unexpected end of stream\n/);
      }
      return $buf;
  }
  
  sub readline {
      @_ == 1 || die(q/Usage: $handle->readline()/ . "\n");
      my ($self) = @_;
  
      while () {
          if ($self->{rbuf} =~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x) {
              return $1;
          }
          if (length $self->{rbuf} >= $self->{max_line_size}) {
              die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/);
          }
          $self->can_read
            or die(qq/Timed out while waiting for socket to become ready for reading\n/);
          my $r = sysread($self->{fh}, $self->{rbuf}, BUFSIZE, length $self->{rbuf});
          if (defined $r) {
              last unless $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      die(qq/Unexpected end of stream while looking for line\n/);
  }
  
  sub read_header_lines {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->read_header_lines([headers])/ . "\n");
      my ($self, $headers) = @_;
      $headers ||= {};
      my $lines   = 0;
      my $val;
  
      while () {
           my $line = $self->readline;
  
           if (++$lines >= $self->{max_header_lines}) {
               die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/);
           }
           elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x) {
               my ($field_name) = lc $1;
               if (exists $headers->{$field_name}) {
                   for ($headers->{$field_name}) {
                       $_ = [$_] unless ref $_ eq "ARRAY";
                       push @$_, $2;
                       $val = \$_->[-1];
                   }
               }
               else {
                   $val = \($headers->{$field_name} = $2);
               }
           }
           elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x) {
               $val
                 or die(qq/Unexpected header continuation line\n/);
               next unless length $1;
               $$val .= ' ' if length $$val;
               $$val .= $1;
           }
           elsif ($line =~ /\A \x0D?\x0A \z/x) {
              last;
           }
           else {
              die(q/Malformed header line: / . $Printable->($line) . "\n");
           }
      }
      return $headers;
  }
  
  sub write_request {
      @_ == 2 || die(q/Usage: $handle->write_request(request)/ . "\n");
      my($self, $request) = @_;
      $self->write_request_header(@{$request}{qw/method uri headers header_case/});
      $self->write_body($request) if $request->{cb};
      return;
  }
  
  # Standard request header names/case from HTTP/1.1 RFCs
  my @rfc_request_headers = qw(
    Accept Accept-Charset Accept-Encoding Accept-Language Authorization
    Cache-Control Connection Content-Length Expect From Host
    If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
    Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer
    Transfer-Encoding Upgrade User-Agent Via
  );
  
  my @other_request_headers = qw(
    Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin
    X-XSS-Protection
  );
  
  my %HeaderCase = map { lc($_) => $_ } @rfc_request_headers, @other_request_headers;
  
  # to avoid multiple small writes and hence nagle, you can pass the method line or anything else to
  # combine writes.
  sub write_header_lines {
      (@_ >= 2 && @_ <= 4 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ . "\n");
      my($self, $headers, $header_case, $prefix_data) = @_;
      $header_case ||= {};
  
      my $buf = (defined $prefix_data ? $prefix_data : '');
  
      # Per RFC, control fields should be listed first
      my %seen;
      for my $k ( qw/host cache-control expect max-forwards pragma range te/ ) {
          next unless exists $headers->{$k};
          $seen{$k}++;
          my $field_name = $HeaderCase{$k};
          my $v = $headers->{$k};
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              $_ = '' unless defined $_;
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
  
      # Other headers sent in arbitrary order
      while (my ($k, $v) = each %$headers) {
          my $field_name = lc $k;
          next if $seen{$field_name};
          if (exists $HeaderCase{$field_name}) {
              $field_name = $HeaderCase{$field_name};
          }
          else {
              if (exists $header_case->{$field_name}) {
                  $field_name = $header_case->{$field_name};
              }
              else {
                  $field_name =~ s/\b(\w)/\u$1/g;
              }
              $field_name =~ /\A $Token+ \z/xo
                or die(q/Invalid HTTP header field name: / . $Printable->($field_name) . "\n");
              $HeaderCase{lc $field_name} = $field_name;
          }
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              # unwrap a field value if pre-wrapped by user
              s/\x0D?\x0A\s+/ /g;
              die(qq/Invalid HTTP header field value ($field_name): / . $Printable->($_). "\n")
                unless $_ eq '' || /\A $Field_Content \z/xo;
              $_ = '' unless defined $_;
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
      $buf .= "\x0D\x0A";
      return $self->write($buf);
  }
  
  # return value indicates whether message length was defined; this is generally
  # true unless there was no content-length header and we just read until EOF.
  # Other message length errors are thrown as exceptions
  sub read_body {
      @_ == 3 || die(q/Usage: $handle->read_body(callback, response)/ . "\n");
      my ($self, $cb, $response) = @_;
      my $te = $response->{headers}{'transfer-encoding'} || '';
      my $chunked = grep { /chunked/i } ( ref $te eq 'ARRAY' ? @$te : $te ) ;
      return $chunked
          ? $self->read_chunked_body($cb, $response)
          : $self->read_content_body($cb, $response);
  }
  
  sub write_body {
      @_ == 2 || die(q/Usage: $handle->write_body(request)/ . "\n");
      my ($self, $request) = @_;
      if ($request->{headers}{'content-length'}) {
          return $self->write_content_body($request);
      }
      else {
          return $self->write_chunked_body($request);
      }
  }
  
  sub read_content_body {
      @_ == 3 || @_ == 4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ . "\n");
      my ($self, $cb, $response, $content_length) = @_;
      $content_length ||= $response->{headers}{'content-length'};
  
      if ( defined $content_length ) {
          my $len = $content_length;
          while ($len > 0) {
              my $read = ($len > BUFSIZE) ? BUFSIZE : $len;
              $cb->($self->read($read, 0), $response);
              $len -= $read;
          }
          return length($self->{rbuf}) == 0;
      }
  
      my $chunk;
      $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );
  
      return;
  }
  
  sub write_content_body {
      @_ == 2 || die(q/Usage: $handle->write_content_body(request)/ . "\n");
      my ($self, $request) = @_;
  
      my ($len, $content_length) = (0, $request->{headers}{'content-length'});
      while () {
          my $data = $request->{cb}->();
  
          defined $data && length $data
            or last;
  
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_content()\n/);
          }
  
          $len += $self->write($data);
      }
  
      $len == $content_length
        or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);
  
      return $len;
  }
  
  sub read_chunked_body {
      @_ == 3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ . "\n");
      my ($self, $cb, $response) = @_;
  
      while () {
          my $head = $self->readline;
  
          $head =~ /\A ([A-Fa-f0-9]+)/x
            or die(q/Malformed chunk head: / . $Printable->($head) . "\n");
  
          my $len = hex($1)
            or last;
  
          $self->read_content_body($cb, $response, $len);
  
          $self->read(2) eq "\x0D\x0A"
            or die(qq/Malformed chunk: missing CRLF after chunk data\n/);
      }
      $self->read_header_lines($response->{headers});
      return 1;
  }
  
  sub write_chunked_body {
      @_ == 2 || die(q/Usage: $handle->write_chunked_body(request)/ . "\n");
      my ($self, $request) = @_;
  
      my $len = 0;
      while () {
          my $data = $request->{cb}->();
  
          defined $data && length $data
            or last;
  
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_chunked_body()\n/);
          }
  
          $len += length $data;
  
          my $chunk  = sprintf '%X', length $data;
             $chunk .= "\x0D\x0A";
             $chunk .= $data;
             $chunk .= "\x0D\x0A";
  
          $self->write($chunk);
      }
      $self->write("0\x0D\x0A");
      $self->write_header_lines($request->{trailer_cb}->())
          if ref $request->{trailer_cb} eq 'CODE';
      return $len;
  }
  
  sub read_response_header {
      @_ == 1 || die(q/Usage: $handle->read_response_header()/ . "\n");
      my ($self) = @_;
  
      my $line = $self->readline;
  
      $line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x
        or die(q/Malformed Status-Line: / . $Printable->($line). "\n");
  
      my ($protocol, $version, $status, $reason) = ($1, $2, $3, $4);
  
      die (qq/Unsupported HTTP protocol: $protocol\n/)
          unless $version =~ /0*1\.0*[01]/;
  
      return {
          status       => $status,
          reason       => $reason,
          headers      => $self->read_header_lines,
          protocol     => $protocol,
      };
  }
  
  sub write_request_header {
      @_ == 5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ . "\n");
      my ($self, $method, $request_uri, $headers, $header_case) = @_;
  
      return $self->write_header_lines($headers, $header_case, "$method $request_uri HTTP/1.1\x0D\x0A");
  }
  
  sub _do_timeout {
      my ($self, $type, $timeout) = @_;
      $timeout = $self->{timeout}
          unless defined $timeout && $timeout >= 0;
  
      my $fd = fileno $self->{fh};
      defined $fd && $fd >= 0
        or die(qq/select(2): 'Bad file descriptor'\n/);
  
      my $initial = time;
      my $pending = $timeout;
      my $nfound;
  
      vec(my $fdset = '', $fd, 1) = 1;
  
      while () {
          $nfound = ($type eq 'read')
              ? select($fdset, undef, undef, $pending)
              : select(undef, $fdset, undef, $pending) ;
          if ($nfound == -1) {
              $! == EINTR
                or die(qq/select(2): '$!'\n/);
              redo if !$timeout || ($pending = $timeout - (time - $initial)) > 0;
              $nfound = 0;
          }
          last;
      }
      $! = 0;
      return $nfound;
  }
  
  sub can_read {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_read([timeout])/ . "\n");
      my $self = shift;
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          return 1 if $self->{fh}->pending;
      }
      return $self->_do_timeout('read', @_)
  }
  
  sub can_write {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_write([timeout])/ . "\n");
      my $self = shift;
      return $self->_do_timeout('write', @_)
  }
  
  sub _assert_ssl {
      my($ok, $reason) = HTTP::Tiny->can_ssl();
      die $reason unless $ok;
  }
  
  sub can_reuse {
      my ($self,$scheme,$host,$port,$peer) = @_;
      return 0 if
          $self->{pid} != $$
          || $self->{tid} != _get_tid()
          || length($self->{rbuf})
          || $scheme ne $self->{scheme}
          || $host ne $self->{host}
          || $port ne $self->{port}
          || $peer ne $self->{peer}
          || eval { $self->can_read(0) }
          || $@ ;
          return 1;
  }
  
  # Try to find a CA bundle to validate the SSL cert,
  # prefer Mozilla::CA or fallback to a system file
  sub _find_CA_file {
      my $self = shift();
  
      my $ca_file =
        defined( $self->{SSL_options}->{SSL_ca_file} )
        ? $self->{SSL_options}->{SSL_ca_file}
        : $ENV{SSL_CERT_FILE};
  
      if ( defined $ca_file ) {
          unless ( -r $ca_file ) {
              die qq/SSL_ca_file '$ca_file' not found or not readable\n/;
          }
          return $ca_file;
      }
  
      return Mozilla::CA::SSL_ca_file()
          if eval { require Mozilla::CA; 1 };
  
      # cert list copied from golang src/crypto/x509/root_unix.go
      foreach my $ca_bundle (
          "/etc/ssl/certs/ca-certificates.crt",     # Debian/Ubuntu/Gentoo etc.
          "/etc/pki/tls/certs/ca-bundle.crt",       # Fedora/RHEL
          "/etc/ssl/ca-bundle.pem",                 # OpenSUSE
          "/etc/openssl/certs/ca-certificates.crt", # NetBSD
          "/etc/ssl/cert.pem",                      # OpenBSD
          "/usr/local/share/certs/ca-root-nss.crt", # FreeBSD/DragonFly
          "/etc/pki/tls/cacert.pem",                # OpenELEC
          "/etc/certs/ca-certificates.crt",         # Solaris 11.2+
      ) {
          return $ca_bundle if -e $ca_bundle;
      }
  
      die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/
        . qq/Try installing Mozilla::CA from CPAN\n/;
  }
  
  # for thread safety, we need to know thread id if threads are loaded
  sub _get_tid {
      no warnings 'reserved'; # for 'threads'
      return threads->can("tid") ? threads->tid : 0;
  }
  
  sub _ssl_args {
      my ($self, $host) = @_;
  
      my %ssl_args;
  
      # This test reimplements IO::Socket::SSL::can_client_sni(), which wasn't
      # added until IO::Socket::SSL 1.84
      if ( Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000 ) {
          $ssl_args{SSL_hostname} = $host,          # Sane SNI support
      }
  
      if ($self->{verify_SSL}) {
          $ssl_args{SSL_verifycn_scheme}  = 'http'; # enable CN validation
          $ssl_args{SSL_verifycn_name}    = $host;  # set validation hostname
          $ssl_args{SSL_verify_mode}      = 0x01;   # enable cert validation
          $ssl_args{SSL_ca_file}          = $self->_find_CA_file;
      }
      else {
          $ssl_args{SSL_verifycn_scheme}  = 'none'; # disable CN validation
          $ssl_args{SSL_verify_mode}      = 0x00;   # disable cert validation
      }
  
      # user options override settings from verify_SSL
      for my $k ( keys %{$self->{SSL_options}} ) {
          $ssl_args{$k} = $self->{SSL_options}{$k} if $k =~ m/^SSL_/;
      }
  
      return \%ssl_args;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Tiny - A small, simple, correct HTTP/1.1 client
  
  =head1 VERSION
  
  version 0.058
  
  =head1 SYNOPSIS
  
      use HTTP::Tiny;
  
      my $response = HTTP::Tiny->new->get('http://example.com/');
  
      die "Failed!\n" unless $response->{success};
  
      print "$response->{status} $response->{reason}\n";
  
      while (my ($k, $v) = each %{$response->{headers}}) {
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              print "$k: $_\n";
          }
      }
  
      print $response->{content} if length $response->{content};
  
  =head1 DESCRIPTION
  
  This is a very simple HTTP/1.1 client, designed for doing simple
  requests without the overhead of a large framework like L<LWP::UserAgent>.
  
  It is more correct and more complete than L<HTTP::Lite>.  It supports
  proxies and redirection.  It also correctly resumes after EINTR.
  
  If L<IO::Socket::IP> 0.25 or later is installed, HTTP::Tiny will use it instead
  of L<IO::Socket::INET> for transparent support for both IPv4 and IPv6.
  
  Cookie support requires L<HTTP::CookieJar> or an equivalent class.
  
  =head1 METHODS
  
  =head2 new
  
      $http = HTTP::Tiny->new( %attributes );
  
  This constructor returns a new HTTP::Tiny object.  Valid attributes include:
  
  =over 4
  
  =item *
  
  C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> — ends in a space character, the default user-agent string is appended.
  
  =item *
  
  C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class that supports the C<add> and C<cookie_header> methods
  
  =item *
  
  C<default_headers> — A hashref of default headers to apply to requests
  
  =item *
  
  C<local_address> — The local IP address to bind to
  
  =item *
  
  C<keep_alive> — Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
  
  =item *
  
  C<max_redirect> — Maximum number of redirects allowed (defaults to 5)
  
  =item *
  
  C<max_size> — Maximum response size in bytes (only when not using a data callback).  If defined, responses larger than this will return an exception.
  
  =item *
  
  C<http_proxy> — URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> — if set)
  
  =item *
  
  C<https_proxy> — URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> — if set)
  
  =item *
  
  C<proxy> — URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> — if set)
  
  =item *
  
  C<no_proxy> — List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}> —)
  
  =item *
  
  C<timeout> — Request timeout in seconds (default is 60) If a socket open, read or write takes longer than the timeout, an exception is thrown.
  
  =item *
  
  C<verify_SSL> — A boolean that indicates whether to validate the SSL certificate of an C<https> — connection (default is false)
  
  =item *
  
  C<SSL_options> — A hashref of C<SSL_*> — options to pass through to L<IO::Socket::SSL>
  
  =back
  
  Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
  prevent getting the corresponding proxies from the environment.
  
  Exceptions from C<max_size>, C<timeout> or other errors will result in a
  pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
  content field in the response will contain the text of the exception.
  
  The C<keep_alive> parameter enables a persistent connection, but only to a
  single destination scheme, host and port.  Also, if any connection-relevant
  attributes are modified, or if the process ID or thread ID change, the
  persistent connection will be dropped.  If you want persistent connections
  across multiple destinations, use multiple HTTP::Tiny objects.
  
  See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
  
  =head2 get|head|put|post|delete
  
      $response = $http->get($url);
      $response = $http->get($url, \%options);
      $response = $http->head($url);
  
  These methods are shorthand for calling C<request()> for the given method.  The
  URL must have unsafe characters escaped and international domain names encoded.
  See C<request()> for valid options and a description of the response.
  
  The C<success> field of the response will be true if the status code is 2XX.
  
  =head2 post_form
  
      $response = $http->post_form($url, $form_data);
      $response = $http->post_form($url, $form_data, \%options);
  
  This method executes a C<POST> request and sends the key/value pairs from a
  form data hash or array reference to the given URL with a C<content-type> of
  C<application/x-www-form-urlencoded>.  If data is provided as an array
  reference, the order is preserved; if provided as a hash reference, the terms
  are sorted on key and value for consistency.  See documentation for the
  C<www_form_urlencode> method for details on the encoding.
  
  The URL must have unsafe characters escaped and international domain names
  encoded.  See C<request()> for valid options and a description of the response.
  Any C<content-type> header or content in the options hashref will be ignored.
  
  The C<success> field of the response will be true if the status code is 2XX.
  
  =head2 mirror
  
      $response = $http->mirror($url, $file, \%options)
      if ( $response->{success} ) {
          print "$file is up to date\n";
      }
  
  Executes a C<GET> request for the URL and saves the response body to the file
  name provided.  The URL must have unsafe characters escaped and international
  domain names encoded.  If the file already exists, the request will include an
  C<If-Modified-Since> header with the modification timestamp of the file.  You
  may specify a different C<If-Modified-Since> header yourself in the C<<
  $options->{headers} >> hash.
  
  The C<success> field of the response will be true if the status code is 2XX
  or if the status code is 304 (unmodified).
  
  If the file was modified and the server response includes a properly
  formatted C<Last-Modified> header, the file modification time will
  be updated accordingly.
  
  =head2 request
  
      $response = $http->request($method, $url);
      $response = $http->request($method, $url, \%options);
  
  Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
  'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
  international domain names encoded.
  
  If the URL includes a "user:password" stanza, they will be used for Basic-style
  authorization headers.  (Authorization headers will not be included in a
  redirected request.) For example:
  
      $http->request('GET', 'http://Aladdin:open sesame@example.com/');
  
  If the "user:password" stanza contains reserved characters, they must
  be percent-escaped:
  
      $http->request('GET', 'http://john%40example.com:password@example.com/');
  
  A hashref of options may be appended to modify the request.
  
  Valid options are:
  
  =over 4
  
  =item *
  
  C<headers> — A hashref containing headers to include with the request.  If the value for a header is an array reference, the header will be output multiple times with each value in the array.  These headers over-write any default headers.
  
  =item *
  
  C<content> — A scalar to include as the body of the request OR a code reference that will be called iteratively to produce the body of the request
  
  =item *
  
  C<trailer_callback> — A code reference that will be called if it exists to provide a hashref of trailing headers (only used with chunked transfer-encoding)
  
  =item *
  
  C<data_callback> — A code reference that will be called for each chunks of the response body received.
  
  =item *
  
  C<peer> — Override host resolution and force all connections to go only to a specific peer address, regardless of the URL of the request.  This will include any redirections!  This options should be used with extreme caution (e.g. debugging or very special circumstances).
  
  =back
  
  The C<Host> header is generated from the URL in accordance with RFC 2616.  It
  is a fatal error to specify C<Host> in the C<headers> option.  Other headers
  may be ignored or overwritten if necessary for transport compliance.
  
  If the C<content> option is a code reference, it will be called iteratively
  to provide the content body of the request.  It should return the empty
  string or undef when the iterator is exhausted.
  
  If the C<content> option is the empty string, no C<content-type> or
  C<content-length> headers will be generated.
  
  If the C<data_callback> option is provided, it will be called iteratively until
  the entire response body is received.  The first argument will be a string
  containing a chunk of the response body, the second argument will be the
  in-progress response hash reference, as described below.  (This allows
  customizing the action of the callback based on the C<status> or C<headers>
  received prior to the content body.)
  
  The C<request> method returns a hashref containing the response.  The hashref
  will have the following keys:
  
  =over 4
  
  =item *
  
  C<success> — Boolean indicating whether the operation returned a 2XX status code
  
  =item *
  
  C<url> — URL that provided the response. This is the URL of the request unless there were redirections, in which case it is the last URL queried in a redirection chain
  
  =item *
  
  C<status> — The HTTP status code of the response
  
  =item *
  
  C<reason> — The response phrase returned by the server
  
  =item *
  
  C<content> — The body of the response.  If the response does not have any content or if a data callback is provided to consume the response body, this will be the empty string
  
  =item *
  
  C<headers> — A hashref of header fields.  All header field names will be normalized to be lower case. If a header is repeated, the value will be an arrayref; it will otherwise be a scalar string containing the value
  
  =item *
  
  C<redirects> If this field exists, it is an arrayref of response hash references from redirects in the same order that redirections occurred.  If it does not exist, then no redirections occurred.
  
  =back
  
  On an exception during the execution of the request, the C<status> field will
  contain 599, and the C<content> field will contain the text of the exception.
  
  =head2 www_form_urlencode
  
      $params = $http->www_form_urlencode( $data );
      $response = $http->get("http://example.com/query?$params");
  
  This method converts the key/value pairs from a data hash or array reference
  into a C<x-www-form-urlencoded> string.  The keys and values from the data
  reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
  array reference, the key will be repeated with each of the values of the array
  reference.  If data is provided as a hash reference, the key/value pairs in the
  resulting string will be sorted by key and value for consistent ordering.
  
  =head2 can_ssl
  
      $ok         = HTTP::Tiny->can_ssl;
      ($ok, $why) = HTTP::Tiny->can_ssl;
      ($ok, $why) = $http->can_ssl;
  
  Indicates if SSL support is available.  When called as a class object, it
  checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
  When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
  is set in C<SSL_options>, it checks that a CA file is available.
  
  In scalar context, returns a boolean indicating if SSL is available.
  In list context, returns the boolean and a (possibly multi-line) string of
  errors indicating why SSL isn't available.
  
  =head2 connected
  
      $host = $http->connected;
      ($host, $port) = $http->connected;
  
  Indicates if a connection to a peer is being kept alive, per the C<keep_alive>
  option.
  
  In scalar context, returns the peer host and port, joined with a colon, or
  C<undef> (if no peer is connected).
  In list context, returns the peer host and port or an empty list (if no peer
  is connected).
  
  B<Note>: This method cannot reliably be used to discover whether the remote
  host has closed its end of the socket.
  
  =for Pod::Coverage SSL_options
  agent
  cookie_jar
  default_headers
  http_proxy
  https_proxy
  keep_alive
  local_address
  max_redirect
  max_size
  no_proxy
  proxy
  timeout
  verify_SSL
  
  =head1 SSL SUPPORT
  
  Direct C<https> connections are supported only if L<IO::Socket::SSL> 1.56 or
  greater and L<Net::SSLeay> 1.49 or greater are installed. An exception will be
  thrown if new enough versions of these modules are not installed or if the SSL
  encryption fails. You can also use C<HTTP::Tiny::can_ssl()> utility function
  that returns boolean to see if the required modules are installed.
  
  An C<https> connection may be made via an C<http> proxy that supports the CONNECT
  command (i.e. RFC 2817).  You may not proxy C<https> via a proxy that itself
  requires C<https> to communicate.
  
  SSL provides two distinct capabilities:
  
  =over 4
  
  =item *
  
  Encrypted communication channel
  
  =item *
  
  Verification of server identity
  
  =back
  
  B<By default, HTTP::Tiny does not verify server identity>.
  
  Server identity verification is controversial and potentially tricky because it
  depends on a (usually paid) third-party Certificate Authority (CA) trust model
  to validate a certificate as legitimate.  This discriminates against servers
  with self-signed certificates or certificates signed by free, community-driven
  CA's such as L<CAcert.org|http://cacert.org>.
  
  By default, HTTP::Tiny does not make any assumptions about your trust model,
  threat level or risk tolerance.  It just aims to give you an encrypted channel
  when you need one.
  
  Setting the C<verify_SSL> attribute to a true value will make HTTP::Tiny verify
  that an SSL connection has a valid SSL certificate corresponding to the host
  name of the connection and that the SSL certificate has been verified by a CA.
  Assuming you trust the CA, this will protect against a L<man-in-the-middle
  attack|http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If you are
  concerned about security, you should enable this option.
  
  Certificate verification requires a file containing trusted CA certificates.
  
  If the environment variable C<SSL_CERT_FILE> is present, HTTP::Tiny
  will try to find a CA certificate file in that location.
  
  If the L<Mozilla::CA> module is installed, HTTP::Tiny will use the CA file
  included with it as a source of trusted CA's.  (This means you trust Mozilla,
  the author of Mozilla::CA, the CPAN mirror where you got Mozilla::CA, the
  toolchain used to install it, and your operating system security, right?)
  
  If that module is not available, then HTTP::Tiny will search several
  system-specific default locations for a CA certificate file:
  
  =over 4
  
  =item *
  
  /etc/ssl/certs/ca-certificates.crt
  
  =item *
  
  /etc/pki/tls/certs/ca-bundle.crt
  
  =item *
  
  /etc/ssl/ca-bundle.pem
  
  =back
  
  An exception will be raised if C<verify_SSL> is true and no CA certificate file
  is available.
  
  If you desire complete control over SSL connections, the C<SSL_options> attribute
  lets you provide a hash reference that will be passed through to
  C<IO::Socket::SSL::start_SSL()>, overriding any options set by HTTP::Tiny. For
  example, to provide your own trusted CA file:
  
      SSL_options => {
          SSL_ca_file => $file_path,
      }
  
  The C<SSL_options> attribute could also be used for such things as providing a
  client certificate for authentication to a server or controlling the choice of
  cipher used for the SSL connection. See L<IO::Socket::SSL> documentation for
  details.
  
  =head1 PROXY SUPPORT
  
  HTTP::Tiny can proxy both C<http> and C<https> requests.  Only Basic proxy
  authorization is supported and it must be provided as part of the proxy URL:
  C<http://user:pass@proxy.example.com/>.
  
  HTTP::Tiny supports the following proxy environment variables:
  
  =over 4
  
  =item *
  
  http_proxy or HTTP_PROXY
  
  =item *
  
  https_proxy or HTTPS_PROXY
  
  =item *
  
  all_proxy or ALL_PROXY
  
  =back
  
  If the C<REQUEST_METHOD> environment variable is set, then this might be a CGI
  process and C<HTTP_PROXY> would be set from the C<Proxy:> header, which is a
  security risk.  If C<REQUEST_METHOD> is set, C<HTTP_PROXY> (the upper case
  variant only) is ignored.
  
  Tunnelling C<https> over an C<http> proxy using the CONNECT method is
  supported.  If your proxy uses C<https> itself, you can not tunnel C<https>
  over it.
  
  Be warned that proxying an C<https> connection opens you to the risk of a
  man-in-the-middle attack by the proxy server.
  
  The C<no_proxy> environment variable is supported in the format of a
  comma-separated list of domain extensions proxy should not be used for.
  
  Proxy arguments passed to C<new> will override their corresponding
  environment variables.
  
  =head1 LIMITATIONS
  
  HTTP::Tiny is I<conditionally compliant> with the
  L<HTTP/1.1 specifications|http://www.w3.org/Protocols/>:
  
  =over 4
  
  =item *
  
  "Message Syntax and Routing" [RFC7230]
  
  =item *
  
  "Semantics and Content" [RFC7231]
  
  =item *
  
  "Conditional Requests" [RFC7232]
  
  =item *
  
  "Range Requests" [RFC7233]
  
  =item *
  
  "Caching" [RFC7234]
  
  =item *
  
  "Authentication" [RFC7235]
  
  =back
  
  It attempts to meet all "MUST" requirements of the specification, but does not
  implement all "SHOULD" requirements.  (Note: it was developed against the
  earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235
  spec.)
  
  Some particular limitations of note include:
  
  =over
  
  =item *
  
  HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring
  that user-defined headers and content are compliant with the HTTP/1.1
  specification.
  
  =item *
  
  Users must ensure that URLs are properly escaped for unsafe characters and that
  international domain names are properly encoded to ASCII. See L<URI::Escape>,
  L<URI::_punycode> and L<Net::IDN::Encode>.
  
  =item *
  
  Redirection is very strict against the specification.  Redirection is only
  automatic for response codes 301, 302, 307 and 308 if the request method is
  'GET' or 'HEAD'.  Response code 303 is always converted into a 'GET'
  redirection, as mandated by the specification.  There is no automatic support
  for status 305 ("Use proxy") redirections.
  
  =item *
  
  There is no provision for delaying a request body using an C<Expect> header.
  Unexpected C<1XX> responses are silently ignored as per the specification.
  
  =item *
  
  Only 'chunked' C<Transfer-Encoding> is supported.
  
  =item *
  
  There is no support for a Request-URI of '*' for the 'OPTIONS' request.
  
  =item *
  
  Headers mentioned in the RFCs and some other, well-known headers are
  generated with their canonical case.  Other headers are sent in the
  case provided by the user.  Except for control headers (which are sent first),
  headers are sent in arbitrary order.
  
  =back
  
  Despite the limitations listed above, HTTP::Tiny is considered
  feature-complete.  New feature requests should be directed to
  L<HTTP::Tiny::UA>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<HTTP::Tiny::UA> - Higher level UA features for HTTP::Tiny
  
  =item *
  
  L<HTTP::Thin> - HTTP::Tiny wrapper with L<HTTP::Request>/L<HTTP::Response> compatibility
  
  =item *
  
  L<HTTP::Tiny::Mech> - Wrap L<WWW::Mechanize> instance in HTTP::Tiny compatible interface
  
  =item *
  
  L<IO::Socket::IP> - Required for IPv6 support
  
  =item *
  
  L<IO::Socket::SSL> - Required for SSL support
  
  =item *
  
  L<LWP::UserAgent> - If HTTP::Tiny isn't enough for you, this is the "standard" way to do things
  
  =item *
  
  L<Mozilla::CA> - Required if you want to validate SSL certificates
  
  =item *
  
  L<Net::SSLeay> - Required for SSL support
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/chansen/p5-http-tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/chansen/p5-http-tiny>
  
    git clone https://github.com/chansen/p5-http-tiny.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Christian Hansen <chansen@cpan.org>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Alan Gardner Alessandro Ghedini A. Sinan Unur Brad Gilbert brian m. carlson Chris Nehren Weyl Claes Jakobsson Clinton Gormley David Golden Dean Pearce Edward Zborowski James Raspass Jeremy Mates Jess Robinson Lukas Eklund Martin J. Evans Martin-Louis Bright Mike Doherty Olaf Alders Olivier Mengué Petr Písař SkyMarshal Sören Kornetzki Syohei YOSHIDA Tatsuhiko Miyagawa Tom Hukins Tony Cook
  
  =over 4
  
  =item *
  
  Alan Gardner <gardner@pythian.com>
  
  =item *
  
  Alessandro Ghedini <al3xbio@gmail.com>
  
  =item *
  
  A. Sinan Unur <nanis@cpan.org>
  
  =item *
  
  Brad Gilbert <bgills@cpan.org>
  
  =item *
  
  brian m. carlson <sandals@crustytoothpaste.net>
  
  =item *
  
  Chris Nehren <apeiron@cpan.org>
  
  =item *
  
  Chris Weyl <cweyl@alumni.drew.edu>
  
  =item *
  
  Claes Jakobsson <claes@surfar.nu>
  
  =item *
  
  Clinton Gormley <clint@traveljury.com>
  
  =item *
  
  David Golden <xdg@xdg.me>
  
  =item *
  
  Dean Pearce <pearce@pythian.com>
  
  =item *
  
  Edward Zborowski <ed@rubensteintech.com>
  
  =item *
  
  James Raspass <jraspass@gmail.com>
  
  =item *
  
  Jeremy Mates <jmates@cpan.org>
  
  =item *
  
  Jess Robinson <castaway@desert-island.me.uk>
  
  =item *
  
  Lukas Eklund <leklund@gmail.com>
  
  =item *
  
  Martin J. Evans <mjegh@ntlworld.com>
  
  =item *
  
  Martin-Louis Bright <mlbright@gmail.com>
  
  =item *
  
  Mike Doherty <doherty@cpan.org>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Petr Písař <ppisar@redhat.com>
  
  =item *
  
  SkyMarshal <skymarshal1729@gmail.com>
  
  =item *
  
  Sören Kornetzki <soeren.kornetzki@delti.com>
  
  =item *
  
  Syohei YOSHIDA <syohex@gmail.com>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  Tom Hukins <tom@eborcom.com>
  
  =item *
  
  Tony Cook <tony@develop-help.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Christian Hansen.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_TINY

$fatpacked{"IO/Socket/IP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_IP';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2010-2015 -- leonerd@leonerd.org.uk
  
  package IO::Socket::IP;
  # $VERSION needs to be set before  use base 'IO::Socket'
  #  - https://rt.cpan.org/Ticket/Display.html?id=92107
  BEGIN {
     $VERSION = '0.37';
  }
  
  use strict;
  use warnings;
  use base qw( IO::Socket );
  
  use Carp;
  
  use Socket 1.97 qw(
     getaddrinfo getnameinfo
     sockaddr_family
     AF_INET
     AI_PASSIVE
     IPPROTO_TCP IPPROTO_UDP
     IPPROTO_IPV6 IPV6_V6ONLY
     NI_DGRAM NI_NUMERICHOST NI_NUMERICSERV NIx_NOHOST NIx_NOSERV
     SO_REUSEADDR SO_REUSEPORT SO_BROADCAST SO_ERROR
     SOCK_DGRAM SOCK_STREAM
     SOL_SOCKET
  );
  my $AF_INET6 = eval { Socket::AF_INET6() }; # may not be defined
  my $AI_ADDRCONFIG = eval { Socket::AI_ADDRCONFIG() } || 0;
  use POSIX qw( dup2 );
  use Errno qw( EINVAL EINPROGRESS EISCONN ENOTCONN ETIMEDOUT EWOULDBLOCK );
  
  use constant HAVE_MSWIN32 => ( $^O eq "MSWin32" );
  
  # At least one OS (Android) is known not to have getprotobyname()
  use constant HAVE_GETPROTOBYNAME => defined eval { getprotobyname( "tcp" ) };
  
  my $IPv6_re = do {
     # translation of RFC 3986 3.2.2 ABNF to re
     my $IPv4address = do {
        my $dec_octet = q<(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])>;
        qq<$dec_octet(?: \\. $dec_octet){3}>;
     };
     my $IPv6address = do {
        my $h16  = qq<[0-9A-Fa-f]{1,4}>;
        my $ls32 = qq<(?: $h16 : $h16 | $IPv4address)>;
        qq<(?:
                                              (?: $h16 : ){6} $ls32
           |                               :: (?: $h16 : ){5} $ls32
           | (?:                   $h16 )? :: (?: $h16 : ){4} $ls32
           | (?: (?: $h16 : ){0,1} $h16 )? :: (?: $h16 : ){3} $ls32
           | (?: (?: $h16 : ){0,2} $h16 )? :: (?: $h16 : ){2} $ls32
           | (?: (?: $h16 : ){0,3} $h16 )? ::     $h16 :      $ls32
           | (?: (?: $h16 : ){0,4} $h16 )? ::                 $ls32
           | (?: (?: $h16 : ){0,5} $h16 )? ::                 $h16
           | (?: (?: $h16 : ){0,6} $h16 )? ::
        )>
     };
     qr<$IPv6address>xo;
  };
  
  =head1 NAME
  
  C<IO::Socket::IP> - Family-neutral IP socket supporting both IPv4 and IPv6
  
  =head1 SYNOPSIS
  
   use IO::Socket::IP;
  
   my $sock = IO::Socket::IP->new(
      PeerHost => "www.google.com",
      PeerPort => "http",
      Type     => SOCK_STREAM,
   ) or die "Cannot construct socket - $@";
  
   my $familyname = ( $sock->sockdomain == PF_INET6 ) ? "IPv6" :
                    ( $sock->sockdomain == PF_INET  ) ? "IPv4" :
                                                        "unknown";
  
   printf "Connected to google via %s\n", $familyname;
  
  =head1 DESCRIPTION
  
  This module provides a protocol-independent way to use IPv4 and IPv6 sockets,
  intended as a replacement for L<IO::Socket::INET>. Most constructor arguments
  and methods are provided in a backward-compatible way. For a list of known
  differences, see the C<IO::Socket::INET> INCOMPATIBILITES section below.
  
  It uses the C<getaddrinfo(3)> function to convert hostnames and service names
  or port numbers into sets of possible addresses to connect to or listen on.
  This allows it to work for IPv6 where the system supports it, while still
  falling back to IPv4-only on systems which don't.
  
  =head1 REPLACING C<IO::Socket> DEFAULT BEHAVIOUR
  
  By placing C<-register> in the import list, L<IO::Socket> uses
  C<IO::Socket::IP> rather than C<IO::Socket::INET> as the class that handles
  C<PF_INET>.  C<IO::Socket> will also use C<IO::Socket::IP> rather than
  C<IO::Socket::INET6> to handle C<PF_INET6>, provided that the C<AF_INET6>
  constant is available.
  
  Changing C<IO::Socket>'s default behaviour means that calling the
  C<IO::Socket> constructor with either C<PF_INET> or C<PF_INET6> as the
  C<Domain> parameter will yield an C<IO::Socket::IP> object.
  
   use IO::Socket::IP -register;
  
   my $sock = IO::Socket->new(
      Domain    => PF_INET6,
      LocalHost => "::1",
      Listen    => 1,
   ) or die "Cannot create socket - $@\n";
  
   print "Created a socket of type " . ref($sock) . "\n";
  
  Note that C<-register> is a global setting that applies to the entire program;
  it cannot be applied only for certain callers, removed, or limited by lexical
  scope.
  
  =cut
  
  sub import
  {
     my $pkg = shift;
     my @symbols;
  
     foreach ( @_ ) {
        if( $_ eq "-register" ) {
           IO::Socket::IP::_ForINET->register_domain( AF_INET );
           IO::Socket::IP::_ForINET6->register_domain( $AF_INET6 ) if defined $AF_INET6;
        }
        else {
           push @symbols, $_;
        }
     }
  
     @_ = ( $pkg, @symbols );
     goto &IO::Socket::import;
  }
  
  # Convenient capability test function
  {
     my $can_disable_v6only;
     sub CAN_DISABLE_V6ONLY
     {
        return $can_disable_v6only if defined $can_disable_v6only;
  
        socket my $testsock, Socket::PF_INET6(), SOCK_STREAM, 0 or
           die "Cannot socket(PF_INET6) - $!";
  
        if( setsockopt $testsock, IPPROTO_IPV6, IPV6_V6ONLY, 0 ) {
           return $can_disable_v6only = 1;
        }
        elsif( $! == EINVAL ) {
           return $can_disable_v6only = 0;
        }
        else {
           die "Cannot setsockopt() - $!";
        }
     }
  }
  
  =head1 CONSTRUCTORS
  
  =cut
  
  =head2 $sock = IO::Socket::IP->new( %args )
  
  Creates a new C<IO::Socket::IP> object, containing a newly created socket
  handle according to the named arguments passed. The recognised arguments are:
  
  =over 8
  
  =item PeerHost => STRING
  
  =item PeerService => STRING
  
  Hostname and service name for the peer to C<connect()> to. The service name
  may be given as a port number, as a decimal string.
  
  =item PeerAddr => STRING
  
  =item PeerPort => STRING
  
  For symmetry with the accessor methods and compatibility with
  C<IO::Socket::INET>, these are accepted as synonyms for C<PeerHost> and
  C<PeerService> respectively.
  
  =item PeerAddrInfo => ARRAY
  
  Alternate form of specifying the peer to C<connect()> to. This should be an
  array of the form returned by C<Socket::getaddrinfo>.
  
  This parameter takes precedence over the C<Peer*>, C<Family>, C<Type> and
  C<Proto> arguments.
  
  =item LocalHost => STRING
  
  =item LocalService => STRING
  
  Hostname and service name for the local address to C<bind()> to.
  
  =item LocalAddr => STRING
  
  =item LocalPort => STRING
  
  For symmetry with the accessor methods and compatibility with
  C<IO::Socket::INET>, these are accepted as synonyms for C<LocalHost> and
  C<LocalService> respectively.
  
  =item LocalAddrInfo => ARRAY
  
  Alternate form of specifying the local address to C<bind()> to. This should be
  an array of the form returned by C<Socket::getaddrinfo>.
  
  This parameter takes precedence over the C<Local*>, C<Family>, C<Type> and
  C<Proto> arguments.
  
  =item Family => INT
  
  The address family to pass to C<getaddrinfo> (e.g. C<AF_INET>, C<AF_INET6>).
  Normally this will be left undefined, and C<getaddrinfo> will search using any
  address family supported by the system.
  
  =item Type => INT
  
  The socket type to pass to C<getaddrinfo> (e.g. C<SOCK_STREAM>,
  C<SOCK_DGRAM>). Normally defined by the caller; if left undefined
  C<getaddrinfo> may attempt to infer the type from the service name.
  
  =item Proto => STRING or INT
  
  The IP protocol to use for the socket (e.g. C<'tcp'>, C<IPPROTO_TCP>,
  C<'udp'>,C<IPPROTO_UDP>). Normally this will be left undefined, and either
  C<getaddrinfo> or the kernel will choose an appropriate value. May be given
  either in string name or numeric form.
  
  =item GetAddrInfoFlags => INT
  
  More flags to pass to the C<getaddrinfo()> function. If not supplied, a
  default of C<AI_ADDRCONFIG> will be used.
  
  These flags will be combined with C<AI_PASSIVE> if the C<Listen> argument is
  given. For more information see the documentation about C<getaddrinfo()> in
  the L<Socket> module.
  
  =item Listen => INT
  
  If defined, puts the socket into listening mode where new connections can be
  accepted using the C<accept> method. The value given is used as the
  C<listen(2)> queue size.
  
  =item ReuseAddr => BOOL
  
  If true, set the C<SO_REUSEADDR> sockopt
  
  =item ReusePort => BOOL
  
  If true, set the C<SO_REUSEPORT> sockopt (not all OSes implement this sockopt)
  
  =item Broadcast => BOOL
  
  If true, set the C<SO_BROADCAST> sockopt
  
  =item V6Only => BOOL
  
  If defined, set the C<IPV6_V6ONLY> sockopt when creating C<PF_INET6> sockets
  to the given value. If true, a listening-mode socket will only listen on the
  C<AF_INET6> addresses; if false it will also accept connections from
  C<AF_INET> addresses.
  
  If not defined, the socket option will not be changed, and default value set
  by the operating system will apply. For repeatable behaviour across platforms
  it is recommended this value always be defined for listening-mode sockets.
  
  Note that not all platforms support disabling this option. Some, at least
  OpenBSD and MirBSD, will fail with C<EINVAL> if you attempt to disable it.
  To determine whether it is possible to disable, you may use the class method
  
   if( IO::Socket::IP->CAN_DISABLE_V6ONLY ) {
      ...
   }
   else {
      ...
   }
  
  If your platform does not support disabling this option but you still want to
  listen for both C<AF_INET> and C<AF_INET6> connections you will have to create
  two listening sockets, one bound to each protocol.
  
  =item MultiHomed
  
  This C<IO::Socket::INET>-style argument is ignored, except if it is defined
  but false. See the C<IO::Socket::INET> INCOMPATIBILITES section below.
  
  However, the behaviour it enables is always performed by C<IO::Socket::IP>.
  
  =item Blocking => BOOL
  
  If defined but false, the socket will be set to non-blocking mode. Otherwise
  it will default to blocking mode. See the NON-BLOCKING section below for more
  detail.
  
  =item Timeout => NUM
  
  If defined, gives a maximum time in seconds to block per C<connect()> call
  when in blocking mode. If missing, no timeout is applied other than that
  provided by the underlying operating system. When in non-blocking mode this
  parameter is ignored.
  
  Note that if the hostname resolves to multiple address candidates, the same
  timeout will apply to each connection attempt individually, rather than to the
  operation as a whole. Further note that the timeout does not apply to the
  initial hostname resolve operation, if connecting by hostname.
  
  This behviour is copied inspired by C<IO::Socket::INET>; for more fine grained
  control over connection timeouts, consider performing a nonblocking connect
  directly.
  
  =back
  
  If neither C<Type> nor C<Proto> hints are provided, a default of
  C<SOCK_STREAM> and C<IPPROTO_TCP> respectively will be set, to maintain
  compatibility with C<IO::Socket::INET>. Other named arguments that are not
  recognised are ignored.
  
  If neither C<Family> nor any hosts or addresses are passed, nor any
  C<*AddrInfo>, then the constructor has no information on which to decide a
  socket family to create. In this case, it performs a C<getaddinfo> call with
  the C<AI_ADDRCONFIG> flag, no host name, and a service name of C<"0">, and
  uses the family of the first returned result.
  
  If the constructor fails, it will set C<$@> to an appropriate error message;
  this may be from C<$!> or it may be some other string; not every failure
  necessarily has an associated C<errno> value.
  
  =head2 $sock = IO::Socket::IP->new( $peeraddr )
  
  As a special case, if the constructor is passed a single argument (as
  opposed to an even-sized list of key/value pairs), it is taken to be the value
  of the C<PeerAddr> parameter. This is parsed in the same way, according to the
  behaviour given in the C<PeerHost> AND C<LocalHost> PARSING section below.
  
  =cut
  
  sub new
  {
     my $class = shift;
     my %arg = (@_ == 1) ? (PeerHost => $_[0]) : @_;
     return $class->SUPER::new(%arg);
  }
  
  # IO::Socket may call this one; neaten up the arguments from IO::Socket::INET
  # before calling our real _configure method
  sub configure
  {
     my $self = shift;
     my ( $arg ) = @_;
  
     $arg->{PeerHost} = delete $arg->{PeerAddr}
        if exists $arg->{PeerAddr} && !exists $arg->{PeerHost};
  
     $arg->{PeerService} = delete $arg->{PeerPort}
        if exists $arg->{PeerPort} && !exists $arg->{PeerService};
  
     $arg->{LocalHost} = delete $arg->{LocalAddr}
        if exists $arg->{LocalAddr} && !exists $arg->{LocalHost};
  
     $arg->{LocalService} = delete $arg->{LocalPort}
        if exists $arg->{LocalPort} && !exists $arg->{LocalService};
  
     for my $type (qw(Peer Local)) {
        my $host    = $type . 'Host';
        my $service = $type . 'Service';
  
        if( defined $arg->{$host} ) {
           ( $arg->{$host}, my $s ) = $self->split_addr( $arg->{$host} );
           # IO::Socket::INET compat - *Host parsed port always takes precedence
           $arg->{$service} = $s if defined $s;
        }
     }
  
     $self->_io_socket_ip__configure( $arg );
  }
  
  # Avoid simply calling it _configure, as some subclasses of IO::Socket::INET on CPAN already take that
  sub _io_socket_ip__configure
  {
     my $self = shift;
     my ( $arg ) = @_;
  
     my %hints;
     my @localinfos;
     my @peerinfos;
  
     my $listenqueue = $arg->{Listen};
     if( defined $listenqueue and
         ( defined $arg->{PeerHost} || defined $arg->{PeerService} || defined $arg->{PeerAddrInfo} ) ) {
        croak "Cannot Listen with a peer address";
     }
  
     if( defined $arg->{GetAddrInfoFlags} ) {
        $hints{flags} = $arg->{GetAddrInfoFlags};
     }
     else {
        $hints{flags} = $AI_ADDRCONFIG;
     }
  
     if( defined( my $family = $arg->{Family} ) ) {
        $hints{family} = $family;
     }
  
     if( defined( my $type = $arg->{Type} ) ) {
        $hints{socktype} = $type;
     }
  
     if( defined( my $proto = $arg->{Proto} ) ) {
        unless( $proto =~ m/^\d+$/ ) {
           my $protonum = HAVE_GETPROTOBYNAME
              ? getprotobyname( $proto )
              : eval { Socket->${\"IPPROTO_\U$proto"}() };
           defined $protonum or croak "Unrecognised protocol $proto";
           $proto = $protonum;
        }
  
        $hints{protocol} = $proto;
     }
  
     # To maintain compatibility with IO::Socket::INET, imply a default of
     # SOCK_STREAM + IPPROTO_TCP if neither hint is given
     if( !defined $hints{socktype} and !defined $hints{protocol} ) {
        $hints{socktype} = SOCK_STREAM;
        $hints{protocol} = IPPROTO_TCP;
     }
  
     # Some OSes (NetBSD) don't seem to like just a protocol hint without a
     # socktype hint as well. We'll set a couple of common ones
     if( !defined $hints{socktype} and defined $hints{protocol} ) {
        $hints{socktype} = SOCK_STREAM if $hints{protocol} == IPPROTO_TCP;
        $hints{socktype} = SOCK_DGRAM  if $hints{protocol} == IPPROTO_UDP;
     }
  
     if( my $info = $arg->{LocalAddrInfo} ) {
        ref $info eq "ARRAY" or croak "Expected 'LocalAddrInfo' to be an ARRAY ref";
        @localinfos = @$info;
     }
     elsif( defined $arg->{LocalHost} or
            defined $arg->{LocalService} or
            HAVE_MSWIN32 and $arg->{Listen} ) {
        # Either may be undef
        my $host = $arg->{LocalHost};
        my $service = $arg->{LocalService};
  
        unless ( defined $host or defined $service ) {
           $service = 0;
        }
  
        local $1; # Placate a taint-related bug; [perl #67962]
        defined $service and $service =~ s/\((\d+)\)$// and
           my $fallback_port = $1;
  
        my %localhints = %hints;
        $localhints{flags} |= AI_PASSIVE;
        ( my $err, @localinfos ) = getaddrinfo( $host, $service, \%localhints );
  
        if( $err and defined $fallback_port ) {
           ( $err, @localinfos ) = getaddrinfo( $host, $fallback_port, \%localhints );
        }
  
        if( $err ) {
           $@ = "$err";
           $! = EINVAL;
           return;
        }
     }
  
     if( my $info = $arg->{PeerAddrInfo} ) {
        ref $info eq "ARRAY" or croak "Expected 'PeerAddrInfo' to be an ARRAY ref";
        @peerinfos = @$info;
     }
     elsif( defined $arg->{PeerHost} or defined $arg->{PeerService} ) {
        defined( my $host = $arg->{PeerHost} ) or
           croak "Expected 'PeerHost'";
        defined( my $service = $arg->{PeerService} ) or
           croak "Expected 'PeerService'";
  
        local $1; # Placate a taint-related bug; [perl #67962]
        defined $service and $service =~ s/\((\d+)\)$// and
           my $fallback_port = $1;
  
        ( my $err, @peerinfos ) = getaddrinfo( $host, $service, \%hints );
  
        if( $err and defined $fallback_port ) {
           ( $err, @peerinfos ) = getaddrinfo( $host, $fallback_port, \%hints );
        }
  
        if( $err ) {
           $@ = "$err";
           $! = EINVAL;
           return;
        }
     }
  
     my @sockopts_enabled;
     push @sockopts_enabled, SO_REUSEADDR if $arg->{ReuseAddr};
     push @sockopts_enabled, SO_REUSEPORT if $arg->{ReusePort};
     push @sockopts_enabled, SO_BROADCAST if $arg->{Broadcast};
  
     my $blocking = $arg->{Blocking};
     defined $blocking or $blocking = 1;
  
     my $v6only = $arg->{V6Only};
  
     # IO::Socket::INET defines this key. IO::Socket::IP always implements the
     # behaviour it requests, so we can ignore it, unless the caller is for some
     # reason asking to disable it.
     if( defined $arg->{MultiHomed} and !$arg->{MultiHomed} ) {
        croak "Cannot disable the MultiHomed parameter";
     }
  
     my @infos;
     foreach my $local ( @localinfos ? @localinfos : {} ) {
        foreach my $peer ( @peerinfos ? @peerinfos : {} ) {
           next if defined $local->{family}   and defined $peer->{family}   and
              $local->{family} != $peer->{family};
           next if defined $local->{socktype} and defined $peer->{socktype} and
              $local->{socktype} != $peer->{socktype};
           next if defined $local->{protocol} and defined $peer->{protocol} and
              $local->{protocol} != $peer->{protocol};
  
           my $family   = $local->{family}   || $peer->{family}   or next;
           my $socktype = $local->{socktype} || $peer->{socktype} or next;
           my $protocol = $local->{protocol} || $peer->{protocol} || 0;
  
           push @infos, {
              family    => $family,
              socktype  => $socktype,
              protocol  => $protocol,
              localaddr => $local->{addr},
              peeraddr  => $peer->{addr},
           };
        }
     }
  
     if( !@infos ) {
        # If there was a Family hint then create a plain unbound, unconnected socket
        if( defined $hints{family} ) {
           @infos = ( {
              family   => $hints{family},
              socktype => $hints{socktype},
              protocol => $hints{protocol},
           } );
        }
        # If there wasn't, use getaddrinfo()'s AI_ADDRCONFIG side-effect to guess a
        # suitable family first.
        else {
           ( my $err, @infos ) = getaddrinfo( "", "0", \%hints );
           if( $err ) {
              $@ = "$err";
              $! = EINVAL;
              return;
           }
  
           # We'll take all the @infos anyway, because some OSes (HPUX) are known to
           # ignore the AI_ADDRCONFIG hint and return AF_INET6 even if they don't
           # support them
        }
     }
  
     # In the nonblocking case, caller will be calling ->setup multiple times.
     # Store configuration in the object for the ->setup method
     # Yes, these are messy. Sorry, I can't help that...
  
     ${*$self}{io_socket_ip_infos} = \@infos;
  
     ${*$self}{io_socket_ip_idx} = -1;
  
     ${*$self}{io_socket_ip_sockopts} = \@sockopts_enabled;
     ${*$self}{io_socket_ip_v6only} = $v6only;
     ${*$self}{io_socket_ip_listenqueue} = $listenqueue;
     ${*$self}{io_socket_ip_blocking} = $blocking;
  
     ${*$self}{io_socket_ip_errors} = [ undef, undef, undef ];
  
     # ->setup is allowed to return false in nonblocking mode
     $self->setup or !$blocking or return undef;
  
     return $self;
  }
  
  sub setup
  {
     my $self = shift;
  
     while(1) {
        ${*$self}{io_socket_ip_idx}++;
        last if ${*$self}{io_socket_ip_idx} >= @{ ${*$self}{io_socket_ip_infos} };
  
        my $info = ${*$self}{io_socket_ip_infos}->[${*$self}{io_socket_ip_idx}];
  
        $self->socket( @{$info}{qw( family socktype protocol )} ) or
           ( ${*$self}{io_socket_ip_errors}[2] = $!, next );
  
        $self->blocking( 0 ) unless ${*$self}{io_socket_ip_blocking};
  
        foreach my $sockopt ( @{ ${*$self}{io_socket_ip_sockopts} } ) {
           $self->setsockopt( SOL_SOCKET, $sockopt, pack "i", 1 ) or ( $@ = "$!", return undef );
        }
  
        if( defined ${*$self}{io_socket_ip_v6only} and defined $AF_INET6 and $info->{family} == $AF_INET6 ) {
           my $v6only = ${*$self}{io_socket_ip_v6only};
           $self->setsockopt( IPPROTO_IPV6, IPV6_V6ONLY, pack "i", $v6only ) or ( $@ = "$!", return undef );
        }
  
        if( defined( my $addr = $info->{localaddr} ) ) {
           $self->bind( $addr ) or
              ( ${*$self}{io_socket_ip_errors}[1] = $!, next );
        }
  
        if( defined( my $listenqueue = ${*$self}{io_socket_ip_listenqueue} ) ) {
           $self->listen( $listenqueue ) or ( $@ = "$!", return undef );
        }
  
        if( defined( my $addr = $info->{peeraddr} ) ) {
           if( $self->connect( $addr ) ) {
              $! = 0;
              return 1;
           }
  
           if( $! == EINPROGRESS or $! == EWOULDBLOCK ) {
              ${*$self}{io_socket_ip_connect_in_progress} = 1;
              return 0;
           }
  
           # If connect failed but we have no system error there must be an error
           # at the application layer, like a bad certificate with
           # IO::Socket::SSL.
           # In this case don't continue IP based multi-homing because the problem
           # cannot be solved at the IP layer.
           return 0 if ! $!;
  
           ${*$self}{io_socket_ip_errors}[0] = $!;
           next;
        }
  
        return 1;
     }
  
     # Pick the most appropriate error, stringified
     $! = ( grep defined, @{ ${*$self}{io_socket_ip_errors}} )[0];
     $@ = "$!";
     return undef;
  }
  
  sub connect :method
  {
     my $self = shift;
  
     # It seems that IO::Socket hides EINPROGRESS errors, making them look like
     # a success. This is annoying here.
     # Instead of putting up with its frankly-irritating intentional breakage of
     # useful APIs I'm just going to end-run around it and call core's connect()
     # directly
  
     if( @_ ) {
        my ( $addr ) = @_;
  
        # Annoyingly IO::Socket's connect() is where the timeout logic is
        # implemented, so we'll have to reinvent it here
        my $timeout = ${*$self}{'io_socket_timeout'};
  
        return connect( $self, $addr ) unless defined $timeout;
  
        my $was_blocking = $self->blocking( 0 );
  
        my $err = defined connect( $self, $addr ) ? 0 : $!+0;
  
        if( !$err ) {
           # All happy
           $self->blocking( $was_blocking );
           return 1;
        }
        elsif( not( $err == EINPROGRESS or $err == EWOULDBLOCK ) ) {
           # Failed for some other reason
           return undef;
        }
        elsif( !$was_blocking ) {
           # We shouldn't block anyway
           return undef;
        }
  
        my $vec = ''; vec( $vec, $self->fileno, 1 ) = 1;
        if( !select( undef, $vec, $vec, $timeout ) ) {
           $! = ETIMEDOUT;
           return undef;
        }
  
        # Hoist the error by connect()ing a second time
        $err = $self->getsockopt( SOL_SOCKET, SO_ERROR );
        $err = 0 if $err == EISCONN; # Some OSes give EISCONN
  
        $self->blocking( $was_blocking );
  
        $! = $err, return undef if $err;
        return 1;
     }
  
     return 1 if !${*$self}{io_socket_ip_connect_in_progress};
  
     # See if a connect attempt has just failed with an error
     if( my $errno = $self->getsockopt( SOL_SOCKET, SO_ERROR ) ) {
        delete ${*$self}{io_socket_ip_connect_in_progress};
        ${*$self}{io_socket_ip_errors}[0] = $! = $errno;
        return $self->setup;
     }
  
     # No error, so either connect is still in progress, or has completed
     # successfully. We can tell by trying to connect() again; either it will
     # succeed or we'll get EISCONN (connected successfully), or EALREADY
     # (still in progress). This even works on MSWin32.
     my $addr = ${*$self}{io_socket_ip_infos}[${*$self}{io_socket_ip_idx}]{peeraddr};
  
     if( connect( $self, $addr ) or $! == EISCONN ) {
        delete ${*$self}{io_socket_ip_connect_in_progress};
        $! = 0;
        return 1;
     }
     else {
        $! = EINPROGRESS;
        return 0;
     }
  }
  
  sub connected
  {
     my $self = shift;
     return defined $self->fileno &&
            !${*$self}{io_socket_ip_connect_in_progress} &&
            defined getpeername( $self ); # ->peername caches, we need to detect disconnection
  }
  
  =head1 METHODS
  
  As well as the following methods, this class inherits all the methods in
  L<IO::Socket> and L<IO::Handle>.
  
  =cut
  
  sub _get_host_service
  {
     my $self = shift;
     my ( $addr, $flags, $xflags ) = @_;
  
     defined $addr or
        $! = ENOTCONN, return;
  
     $flags |= NI_DGRAM if $self->socktype == SOCK_DGRAM;
  
     my ( $err, $host, $service ) = getnameinfo( $addr, $flags, $xflags || 0 );
     croak "getnameinfo - $err" if $err;
  
     return ( $host, $service );
  }
  
  sub _unpack_sockaddr
  {
     my ( $addr ) = @_;
     my $family = sockaddr_family $addr;
  
     if( $family == AF_INET ) {
        return ( Socket::unpack_sockaddr_in( $addr ) )[1];
     }
     elsif( defined $AF_INET6 and $family == $AF_INET6 ) {
        return ( Socket::unpack_sockaddr_in6( $addr ) )[1];
     }
     else {
        croak "Unrecognised address family $family";
     }
  }
  
  =head2 ( $host, $service ) = $sock->sockhost_service( $numeric )
  
  Returns the hostname and service name of the local address (that is, the
  socket address given by the C<sockname> method).
  
  If C<$numeric> is true, these will be given in numeric form rather than being
  resolved into names.
  
  The following four convenience wrappers may be used to obtain one of the two
  values returned here. If both host and service names are required, this method
  is preferable to the following wrappers, because it will call
  C<getnameinfo(3)> only once.
  
  =cut
  
  sub sockhost_service
  {
     my $self = shift;
     my ( $numeric ) = @_;
  
     $self->_get_host_service( $self->sockname, $numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0 );
  }
  
  =head2 $addr = $sock->sockhost
  
  Return the numeric form of the local address as a textual representation
  
  =head2 $port = $sock->sockport
  
  Return the numeric form of the local port number
  
  =head2 $host = $sock->sockhostname
  
  Return the resolved name of the local address
  
  =head2 $service = $sock->sockservice
  
  Return the resolved name of the local port number
  
  =cut
  
  sub sockhost { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, NI_NUMERICHOST, NIx_NOSERV ) )[0] }
  sub sockport { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, NI_NUMERICSERV, NIx_NOHOST ) )[1] }
  
  sub sockhostname { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, 0, NIx_NOSERV ) )[0] }
  sub sockservice  { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, 0, NIx_NOHOST ) )[1] }
  
  =head2 $addr = $sock->sockaddr
  
  Return the local address as a binary octet string
  
  =cut
  
  sub sockaddr { my $self = shift; _unpack_sockaddr $self->sockname }
  
  =head2 ( $host, $service ) = $sock->peerhost_service( $numeric )
  
  Returns the hostname and service name of the peer address (that is, the
  socket address given by the C<peername> method), similar to the
  C<sockhost_service> method.
  
  The following four convenience wrappers may be used to obtain one of the two
  values returned here. If both host and service names are required, this method
  is preferable to the following wrappers, because it will call
  C<getnameinfo(3)> only once.
  
  =cut
  
  sub peerhost_service
  {
     my $self = shift;
     my ( $numeric ) = @_;
  
     $self->_get_host_service( $self->peername, $numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0 );
  }
  
  =head2 $addr = $sock->peerhost
  
  Return the numeric form of the peer address as a textual representation
  
  =head2 $port = $sock->peerport
  
  Return the numeric form of the peer port number
  
  =head2 $host = $sock->peerhostname
  
  Return the resolved name of the peer address
  
  =head2 $service = $sock->peerservice
  
  Return the resolved name of the peer port number
  
  =cut
  
  sub peerhost { my $self = shift; scalar +( $self->_get_host_service( $self->peername, NI_NUMERICHOST, NIx_NOSERV ) )[0] }
  sub peerport { my $self = shift; scalar +( $self->_get_host_service( $self->peername, NI_NUMERICSERV, NIx_NOHOST ) )[1] }
  
  sub peerhostname { my $self = shift; scalar +( $self->_get_host_service( $self->peername, 0, NIx_NOSERV ) )[0] }
  sub peerservice  { my $self = shift; scalar +( $self->_get_host_service( $self->peername, 0, NIx_NOHOST ) )[1] }
  
  =head2 $addr = $peer->peeraddr
  
  Return the peer address as a binary octet string
  
  =cut
  
  sub peeraddr { my $self = shift; _unpack_sockaddr $self->peername }
  
  # This unbelievably dodgy hack works around the bug that IO::Socket doesn't do
  # it
  #    https://rt.cpan.org/Ticket/Display.html?id=61577
  sub accept
  {
     my $self = shift;
     my ( $new, $peer ) = $self->SUPER::accept( @_ ) or return;
  
     ${*$new}{$_} = ${*$self}{$_} for qw( io_socket_domain io_socket_type io_socket_proto );
  
     return wantarray ? ( $new, $peer )
                      : $new;
  }
  
  # This second unbelievably dodgy hack guarantees that $self->fileno doesn't
  # change, which is useful during nonblocking connect
  sub socket :method
  {
     my $self = shift;
     return $self->SUPER::socket(@_) if not defined $self->fileno;
  
     # I hate core prototypes sometimes...
     socket( my $tmph, $_[0], $_[1], $_[2] ) or return undef;
  
     dup2( $tmph->fileno, $self->fileno ) or die "Unable to dup2 $tmph onto $self - $!";
  }
  
  # Versions of IO::Socket before 1.35 may leave socktype undef if from, say, an
  #   ->fdopen call. In this case we'll apply a fix
  BEGIN {
     if( eval($IO::Socket::VERSION) < 1.35 ) {
        *socktype = sub {
           my $self = shift;
           my $type = $self->SUPER::socktype;
           if( !defined $type ) {
              $type = $self->sockopt( Socket::SO_TYPE() );
           }
           return $type;
        };
     }
  }
  
  =head2 $inet = $sock->as_inet
  
  Returns a new L<IO::Socket::INET> instance wrapping the same filehandle. This
  may be useful in cases where it is required, for backward-compatibility, to
  have a real object of C<IO::Socket::INET> type instead of C<IO::Socket::IP>.
  The new object will wrap the same underlying socket filehandle as the
  original, so care should be taken not to continue to use both objects
  concurrently. Ideally the original C<$sock> should be discarded after this
  method is called.
  
  This method checks that the socket domain is C<PF_INET> and will throw an
  exception if it isn't.
  
  =cut
  
  sub as_inet
  {
     my $self = shift;
     croak "Cannot downgrade a non-PF_INET socket to IO::Socket::INET" unless $self->sockdomain == AF_INET;
     return IO::Socket::INET->new_from_fd( $self->fileno, "r+" );
  }
  
  =head1 NON-BLOCKING
  
  If the constructor is passed a defined but false value for the C<Blocking>
  argument then the socket is put into non-blocking mode. When in non-blocking
  mode, the socket will not be set up by the time the constructor returns,
  because the underlying C<connect(2)> syscall would otherwise have to block.
  
  The non-blocking behaviour is an extension of the C<IO::Socket::INET> API,
  unique to C<IO::Socket::IP>, because the former does not support multi-homed
  non-blocking connect.
  
  When using non-blocking mode, the caller must repeatedly check for
  writeability on the filehandle (for instance using C<select> or C<IO::Poll>).
  Each time the filehandle is ready to write, the C<connect> method must be
  called, with no arguments. Note that some operating systems, most notably
  C<MSWin32> do not report a C<connect()> failure using write-ready; so you must
  also C<select()> for exceptional status.
  
  While C<connect> returns false, the value of C<$!> indicates whether it should
  be tried again (by being set to the value C<EINPROGRESS>, or C<EWOULDBLOCK> on
  MSWin32), or whether a permanent error has occurred (e.g. C<ECONNREFUSED>).
  
  Once the socket has been connected to the peer, C<connect> will return true
  and the socket will now be ready to use.
  
  Note that calls to the platform's underlying C<getaddrinfo(3)> function may
  block. If C<IO::Socket::IP> has to perform this lookup, the constructor will
  block even when in non-blocking mode.
  
  To avoid this blocking behaviour, the caller should pass in the result of such
  a lookup using the C<PeerAddrInfo> or C<LocalAddrInfo> arguments. This can be
  achieved by using L<Net::LibAsyncNS>, or the C<getaddrinfo(3)> function can be
  called in a child process.
  
   use IO::Socket::IP;
   use Errno qw( EINPROGRESS EWOULDBLOCK );
  
   my @peeraddrinfo = ... # Caller must obtain the getaddinfo result here
  
   my $socket = IO::Socket::IP->new(
      PeerAddrInfo => \@peeraddrinfo,
      Blocking     => 0,
   ) or die "Cannot construct socket - $@";
  
   while( !$socket->connect and ( $! == EINPROGRESS || $! == EWOULDBLOCK ) ) {
      my $wvec = '';
      vec( $wvec, fileno $socket, 1 ) = 1;
      my $evec = '';
      vec( $evec, fileno $socket, 1 ) = 1;
  
      select( undef, $wvec, $evec, undef ) or die "Cannot select - $!";
   }
  
   die "Cannot connect - $!" if $!;
  
   ...
  
  The example above uses C<select()>, but any similar mechanism should work
  analogously. C<IO::Socket::IP> takes care when creating new socket filehandles
  to preserve the actual file descriptor number, so such techniques as C<poll>
  or C<epoll> should be transparent to its reallocation of a different socket
  underneath, perhaps in order to switch protocol family between C<PF_INET> and
  C<PF_INET6>.
  
  For another example using C<IO::Poll> and C<Net::LibAsyncNS>, see the
  F<examples/nonblocking_libasyncns.pl> file in the module distribution.
  
  =cut
  
  =head1 C<PeerHost> AND C<LocalHost> PARSING
  
  To support the C<IO::Socket::INET> API, the host and port information may be
  passed in a single string rather than as two separate arguments.
  
  If either C<LocalHost> or C<PeerHost> (or their C<...Addr> synonyms) have any
  of the following special forms then special parsing is applied.
  
  The value of the C<...Host> argument will be split to give both the hostname
  and port (or service name):
  
   hostname.example.org:http    # Host name
   192.0.2.1:80                 # IPv4 address
   [2001:db8::1]:80             # IPv6 address
  
  In each case, the port or service name (e.g. C<80>) is passed as the
  C<LocalService> or C<PeerService> argument.
  
  Either of C<LocalService> or C<PeerService> (or their C<...Port> synonyms) can
  be either a service name, a decimal number, or a string containing both a
  service name and number, in a form such as
  
   http(80)
  
  In this case, the name (C<http>) will be tried first, but if the resolver does
  not understand it then the port number (C<80>) will be used instead.
  
  If the C<...Host> argument is in this special form and the corresponding
  C<...Service> or C<...Port> argument is also defined, the one parsed from
  the C<...Host> argument will take precedence and the other will be ignored.
  
  =head2 ( $host, $port ) = IO::Socket::IP->split_addr( $addr )
  
  Utility method that provides the parsing functionality described above.
  Returns a 2-element list, containing either the split hostname and port
  description if it could be parsed, or the given address and C<undef> if it was
  not recognised.
  
   IO::Socket::IP->split_addr( "hostname:http" )
                                # ( "hostname",  "http" )
  
   IO::Socket::IP->split_addr( "192.0.2.1:80" )
                                # ( "192.0.2.1", "80"   )
  
   IO::Socket::IP->split_addr( "[2001:db8::1]:80" )
                                # ( "2001:db8::1", "80" )
  
   IO::Socket::IP->split_addr( "something.else" )
                                # ( "something.else", undef )
  
  =cut
  
  sub split_addr
  {
     shift;
     my ( $addr ) = @_;
  
     local ( $1, $2 ); # Placate a taint-related bug; [perl #67962]
     if( $addr =~ m/\A\[($IPv6_re)\](?::([^\s:]*))?\z/ or
         $addr =~ m/\A([^\s:]*):([^\s:]*)\z/ ) {
        return ( $1, $2 ) if defined $2 and length $2;
        return ( $1, undef );
     }
  
     return ( $addr, undef );
  }
  
  =head2 $addr = IO::Socket::IP->join_addr( $host, $port )
  
  Utility method that performs the reverse of C<split_addr>, returning a string
  formed by joining the specified host address and port number. The host address
  will be wrapped in C<[]> brackets if required (because it is a raw IPv6
  numeric address).
  
  This can be especially useful when combined with the C<sockhost_service> or
  C<peerhost_service> methods.
  
   say "Connected to ", IO::Socket::IP->join_addr( $sock->peerhost_service );
  
  =cut
  
  sub join_addr
  {
     shift;
     my ( $host, $port ) = @_;
  
     $host = "[$host]" if $host =~ m/:/;
  
     return join ":", $host, $port if defined $port;
     return $host;
  }
  
  # Since IO::Socket->new( Domain => ... ) will delete the Domain parameter
  # before calling ->configure, we need to keep track of which it was
  
  package # hide from indexer
     IO::Socket::IP::_ForINET;
  use base qw( IO::Socket::IP );
  
  sub configure
  {
     # This is evil
     my $self = shift;
     my ( $arg ) = @_;
  
     bless $self, "IO::Socket::IP";
     $self->configure( { %$arg, Family => Socket::AF_INET() } );
  }
  
  package # hide from indexer
     IO::Socket::IP::_ForINET6;
  use base qw( IO::Socket::IP );
  
  sub configure
  {
     # This is evil
     my $self = shift;
     my ( $arg ) = @_;
  
     bless $self, "IO::Socket::IP";
     $self->configure( { %$arg, Family => Socket::AF_INET6() } );
  }
  
  =head1 C<IO::Socket::INET> INCOMPATIBILITES
  
  =over 4
  
  =item *
  
  The behaviour enabled by C<MultiHomed> is in fact implemented by
  C<IO::Socket::IP> as it is required to correctly support searching for a
  useable address from the results of the C<getaddrinfo(3)> call. The
  constructor will ignore the value of this argument, except if it is defined
  but false. An exception is thrown in this case, because that would request it
  disable the C<getaddrinfo(3)> search behaviour in the first place.
  
  =item *
  
  C<IO::Socket::IP> implements both the C<Blocking> and C<Timeout> parameters,
  but it implements the interaction of both in a different way.
  
  In C<::INET>, supplying a timeout overrides the non-blocking behaviour,
  meaning that the C<connect()> operation will still block despite that the
  caller asked for a non-blocking socket. This is not explicitly specified in
  its documentation, nor does this author believe that is a useful behaviour -
  it appears to come from a quirk of implementation.
  
  In C<::IP> therefore, the C<Blocking> parameter takes precedence - if a
  non-blocking socket is requested, no operation will block. The C<Timeout>
  parameter here simply defines the maximum time that a blocking C<connect()>
  call will wait, if it blocks at all.
  
  In order to specifically obtain the "blocking connect then non-blocking send
  and receive" behaviour of specifying this combination of options to C<::INET>
  when using C<::IP>, perform first a blocking connect, then afterwards turn the
  socket into nonblocking mode.
  
   my $sock = IO::Socket::IP->new(
      PeerHost => $peer,
      Timeout => 20,
   ) or die "Cannot connect - $@";
  
   $sock->blocking( 0 );
  
  This code will behave identically under both C<IO::Socket::INET> and
  C<IO::Socket::IP>.
  
  =back
  
  =cut
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  Investigate whether C<POSIX::dup2> upsets BSD's C<kqueue> watchers, and if so,
  consider what possible workarounds might be applied.
  
  =back
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
IO_SOCKET_IP

$fatpacked{"JSON/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_TINY';
  package JSON::Tiny;
  
  # Minimalistic JSON. Adapted from Mojo::JSON. (c)2012-2015 David Oswald
  # License: Artistic 2.0 license.
  # http://www.perlfoundation.org/artistic_license_2_0
  
  use strict;
  use warnings;
  use Carp 'croak';
  use Exporter 'import';
  use Scalar::Util 'blessed';
  use Encode ();
  
  our $VERSION = '0.56';
  our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);
  
  # Literal names
  # Users may override Booleans with literal 0 or 1 if desired.
  our($FALSE, $TRUE) = map { bless \(my $dummy = $_), 'JSON::Tiny::_Bool' } 0, 1;
  
  # Escaped special character map with u2028 and u2029
  my %ESCAPE = (
    '"'     => '"',
    '\\'    => '\\',
    '/'     => '/',
    'b'     => "\x08",
    'f'     => "\x0c",
    'n'     => "\x0a",
    'r'     => "\x0d",
    't'     => "\x09",
    'u2028' => "\x{2028}",
    'u2029' => "\x{2029}"
  );
  my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;
  
  for(0x00 .. 0x1f) {
    my $packed = pack 'C', $_;
    $REVERSE{$packed} = sprintf '\u%.4X', $_ unless defined $REVERSE{$packed};
  }
  
  sub decode_json {
    my $err = _decode(\my $value, shift);
    return defined $err ? croak $err : $value;
  }
  
  sub encode_json { Encode::encode 'UTF-8', _encode_value(shift) }
  
  sub false () {$FALSE}  ## no critic (prototypes)
  
  sub from_json {
    my $err = _decode(\my $value, shift, 1);
    return defined $err ? croak $err : $value;
  }
  
  sub j {
    return encode_json $_[0] if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
    return decode_json $_[0];
  }
  
  sub to_json { _encode_value(shift) }
  
  sub true () {$TRUE} ## no critic (prototypes)
  
  sub _decode {
    my $valueref = shift;
  
    eval {
  
      # Missing input
      die "Missing or empty input\n" unless length( local $_ = shift );
  
      # UTF-8
      $_ = eval { Encode::decode('UTF-8', $_, 1) } unless shift;
      die "Input is not UTF-8 encoded\n" unless defined $_;
  
      # Value
      $$valueref = _decode_value();
  
      # Leftover data
      return m/\G[\x20\x09\x0a\x0d]*\z/gc || _throw('Unexpected data');
    } ? return undef : chomp $@;
  
    return $@;
  }
  
  sub _decode_array {
    my @array;
    until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {
  
      # Value
      push @array, _decode_value();
  
      # Separator
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if m/\G[\x20\x09\x0a\x0d]*\]/gc;
  
      # Invalid character
      _throw('Expected comma or right square bracket while parsing array');
    }
  
    return \@array;
  }
  
  sub _decode_object {
    my %hash;
    until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {
  
      # Quote
      m/\G[\x20\x09\x0a\x0d]*"/gc
        or _throw('Expected string while parsing object');
  
      # Key
      my $key = _decode_string();
  
      # Colon
      m/\G[\x20\x09\x0a\x0d]*:/gc
        or _throw('Expected colon while parsing object');
  
      # Value
      $hash{$key} = _decode_value();
  
      # Separator
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if m/\G[\x20\x09\x0a\x0d]*\}/gc;
  
      # Invalid character
      _throw('Expected comma or right curly bracket while parsing object');
    }
  
    return \%hash;
  }
  
  sub _decode_string {
    my $pos = pos;
    
    # Extract string with escaped characters
    m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc; # segfault on 5.8.x in t/20-mojo-json.t
    my $str = $1;
  
    # Invalid character
    unless (m/\G"/gc) {
      _throw('Unexpected character or invalid escape while parsing string')
        if m/\G[\x00-\x1f\\]/;
      _throw('Unterminated string');
    }
  
    # Unescape popular characters
    if (index($str, '\\u') < 0) {
      $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
      return $str;
    }
  
    # Unescape everything else
    my $buffer = '';
    while ($str =~ m/\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
      $buffer .= $1;
  
      # Popular character
      if ($2) { $buffer .= $ESCAPE{$2} }
  
      # Escaped
      else {
        my $ord = hex $3;
  
        # Surrogate pair
        if (($ord & 0xf800) == 0xd800) {
  
          # High surrogate
          ($ord & 0xfc00) == 0xd800
            or pos($_) = $pos + pos($str), _throw('Missing high-surrogate');
  
          # Low surrogate
          $str =~ m/\G\\u([Dd][C-Fc-f]..)/gc
            or pos($_) = $pos + pos($str), _throw('Missing low-surrogate');
  
          $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
        }
  
        # Character
        $buffer .= pack 'U', $ord;
      }
    }
  
    # The rest
    return $buffer . substr $str, pos $str, length $str;
  }
  
  sub _decode_value {
  
    # Leading whitespace
    m/\G[\x20\x09\x0a\x0d]*/gc;
  
    # String
    return _decode_string() if m/\G"/gc;
  
    # Object
    return _decode_object() if m/\G\{/gc;
  
    # Array
    return _decode_array() if m/\G\[/gc;
  
    # Number
    my ($i) = /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;
    return 0 + $i if defined $i;
  
    # True
    return $TRUE if m/\Gtrue/gc;
  
    # False
    return $FALSE if m/\Gfalse/gc;
  
    # Null
    return undef if m/\Gnull/gc;  ## no critic (return)
  
    # Invalid character
    _throw('Expected string, array, object, number, boolean or null');
  }
  
  sub _encode_array {
    '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
  }
  
  sub _encode_object {
    my $object = shift;
    my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
      sort keys %$object;
    return '{' . join(',', @pairs) . '}';
  }
  
  sub _encode_string {
    my $str = shift;
    $str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;
    return "\"$str\"";
  }
  
  sub _encode_value {
    my $value = shift;
  
    # Reference
    if (my $ref = ref $value) {
  
      # Object
      return _encode_object($value) if $ref eq 'HASH';
  
      # Array
      return _encode_array($value) if $ref eq 'ARRAY';
  
      # True or false
      return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
      return $value  ? 'true' : 'false' if $ref eq 'JSON::Tiny::_Bool';
  
      # Blessed reference with TO_JSON method
      if (blessed $value && (my $sub = $value->can('TO_JSON'))) {
        return _encode_value($value->$sub);
      }
    }
  
    # Null
    return 'null' unless defined $value;
  
  
    # Number (bitwise operators change behavior based on the internal value type)
  
    # "0" & $x will modify the flags on the "0" on perl < 5.14, so use a copy
    my $zero = "0";
    # "0" & $num -> 0. "0" & "" -> "". "0" & $string -> a character.
    # this maintains the internal type but speeds up the xor below.
    my $check = $zero & $value;
    return $value
      if length $check
      # 0 ^ itself          -> 0    (false)
      # $character ^ itself -> "\0" (true)
      && !($check ^ $check)
      # filter out "upgraded" strings whose numeric form doesn't strictly match
      && 0 + $value eq $value
      # filter out inf and nan
      && $value * 0 == 0;
  
    # String
    return _encode_string($value);
  }
  
  sub _throw {
  
    # Leading whitespace
    m/\G[\x20\x09\x0a\x0d]*/gc;
  
    # Context
    my $context = 'Malformed JSON: ' . shift;
    if (m/\G\z/gc) { $context .= ' before end of data' }
    else {
      my @lines = split "\n", substr($_, 0, pos);
      $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
    }
  
    die "$context\n";
  }
  
  # Emulate boolean type
  package JSON::Tiny::_Bool;
  use overload '""' => sub { ${$_[0]} }, fallback => 1;
  1;
JSON_TINY

$fatpacked{"LockFile/Lock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCKFILE_LOCK';
  ;# $Id
  ;#
  ;#  @COPYRIGHT@
  ;#
  ;# $Log: Lock.pm,v $
  ;# Revision 0.3  2007/09/28 19:20:14  jv
  ;# Track where lock was issued in the code.
  ;#
  ;# Revision 0.2.1.1  2000/01/04 21:16:28  ram
  ;# patch1: track where lock was issued in the code
  ;#
  ;# Revision 0.2  1999/12/07 20:51:04  ram
  ;# Baseline for 0.2 release.
  ;#
  
  use strict;
  
  ########################################################################
  package LockFile::Lock;
  
  #
  # A lock instance -- deferred class.
  #
  
  #
  # ->_lock_init
  #
  # Common lock initialization
  #
  # Attributes:
  #
  #	scheme		the LockFile::* object that created the lock
  #	filename	where lock was taken
  #	line		line in filename where lock was taken
  #
  sub _lock_init {
  	my $self = shift;
  	my ($scheme, $filename, $line) = @_;
  	$self->{'scheme'} = $scheme;
  	$self->{'filename'} = $filename;
  	$self->{'line'} = $line;
  }
  
  #
  # Common attribute access
  #
  
  sub scheme		{ $_[0]->{'scheme'} }
  sub filename	{ $_[0]->{'filename'} }
  sub line		{ $_[0]->{'line'} }
  
  #
  # ->release
  #
  # Release the lock
  #
  sub release {
  	my $self = shift;
  	return $self->scheme->release($self);
  }
  
  #
  # ->where
  #
  # Returns '"filename", line #' where lock was taken.
  #
  sub where {
  	my $self = shift;
  	return sprintf '"%s", line %d', $self->filename, $self->line;
  }
  
  1;
  
LOCKFILE_LOCK

$fatpacked{"LockFile/Lock/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCKFILE_LOCK_SIMPLE';
  ;# $Id
  ;#
  ;#  @COPYRIGHT@
  ;#
  ;# $Log: Simple.pm,v $
  ;# Revision 0.3  2007/09/28 19:18:27  jv
  ;# Track where lock was issued in the code.
  ;#
  ;# Revision 0.2.1.1  2000/01/04 21:16:35  ram
  ;# patch1: track where lock was issued in the code
  ;#
  ;# Revision 0.2  1999/12/07 20:51:04  ram
  ;# Baseline for 0.2 release.
  ;#
  
  use strict;
  
  ########################################################################
  package LockFile::Lock::Simple;
  
  require LockFile::Lock;
  
  use vars qw(@ISA);
  
  @ISA = qw(LockFile::Lock);
  
  #
  # ->make
  #
  # Creation routine
  #
  # Attributes:
  #
  #	scheme		the LockFile::* object that created the lock
  #	file		the locked file
  #	format		the format used to create the lockfile
  #	filename	where lock was taken
  #	line		line in filename where lock was taken
  #
  sub make {
  	my $self = bless {}, shift;
  	my ($scheme, $file, $format, $filename, $line) = @_;
  	$self->{'file'} = $file;
  	$self->{'format'} = $format;
  	$self->_lock_init($scheme, $filename, $line);
  	return $self;
  }
  
  #
  # Attribute access
  #
  
  sub file	{ $_[0]->{'file'} }
  sub format	{ $_[0]->{'format'} }
  
  1;
  
LOCKFILE_LOCK_SIMPLE

$fatpacked{"LockFile/Manager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCKFILE_MANAGER';
  ;# $Id
  ;#
  ;#  @COPYRIGHT@
  ;#
  ;# $Log: Manager.pm,v $
  ;# Revision 0.2  1999/12/07 20:51:05  ram
  ;# Baseline for 0.2 release.
  ;#
  
  use strict;
  
  ########################################################################
  package LockFile::Manager;
  
  #
  # A pool of all created locks.
  #
  
  my $MANAGER = undef;		# The main manager
  
  #
  # ->make
  #
  # Creates a new LockFile::Manager to hold the locks.
  #
  # Attributes:
  #
  #	pool		hash of LockFile::Lock objects
  #	wfunc		warning function to be called
  #	efunc		error function to be called
  #
  sub make {
  	my $self = bless {}, shift;
  	my ($wfunc, $efunc) = @_;
  	$self->{'pool'} = {};
  	$self->{'wfunc'} = $wfunc;
  	$self->{'efunc'} = $efunc;
  	return $self;
  }
  
  #
  # Attribute access
  #
  
  sub pool	{ $_[0]->{'pool'} }
  sub wfunc	{ $_[0]->{'wfunc'} }
  sub efunc	{ $_[0]->{'efunc'} }
  
  #
  # ->manager		-- "once" function
  #
  # Returns the main manager.
  #
  sub manager {
  	my ($class, $wfunc, $efunc) = @_;
  	return $MANAGER || ($MANAGER = $class->make($wfunc, $efunc));
  }
  
  #
  # ->remember
  #
  # Remember created locks.
  #
  sub remember {
  	my $self = shift;
  	my ($lock) = @_;				# A LockFile::Lock object
  	my $pool = $self->pool;
  	if (exists $pool->{$lock}) {
  		&{$self->efunc}("lock $lock already remembered");
  		return;
  	}
  	$pool->{$lock} = $lock;
  }
  
  #
  # ->forget
  #
  # Forget about a lock.
  #
  sub forget {
  	my $self = shift;
  	my ($lock) = @_;				# A LockFile::Lock object
  	my $pool = $self->pool;
  	unless (exists $pool->{$lock}) {
  		&{$self->efunc}("lock $lock not remembered yet");
  		return;
  	}
  	delete $pool->{$lock};
  }
  
  #
  # ->release_all
  #
  # Release all the locks.
  #
  sub release_all {
  	my $self = shift;
  	my $pool = $self->pool;
  	my $locks = scalar keys %$pool;
  	return unless $locks;
  
  	my $s = $locks == 1 ? '' : 's';
  	&{$self->wfunc}("releasing $locks pending lock$s...");
  
  	foreach my $lock (values %$pool) {
  		$lock->release;
  	}
  }
  
  sub END { $MANAGER->release_all if defined $MANAGER }
  
  1;
  
LOCKFILE_MANAGER

$fatpacked{"LockFile/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCKFILE_SIMPLE';
  ;# $Id$
  ;#
  ;#  @COPYRIGHT@
  ;#
  ;# $Log: Simple.pm,v $
  ;# Revision 0.4  2007/09/28 19:22:05  jv
  ;# Bump version.
  ;#
  ;# Revision 0.3  2007/09/28 19:19:41  jv
  ;# Revision 0.2.1.5  2000/09/18 19:55:07  ram
  ;# patch5: fixed computation of %F and %D when no '/' in file name
  ;# patch5: fixed OO example of lock to emphasize check on returned value
  ;# patch5: now warns when no lockfile is found during unlocking
  ;#
  ;# Revision 0.2.1.4  2000/08/15 18:41:43  ram
  ;# patch4: updated version number, grrr...
  ;#
  ;# Revision 0.2.1.3  2000/08/15 18:37:37  ram
  ;# patch3: fixed non-working "-wfunc => undef" due to misuse of defined()
  ;# patch3: check for stale lock while we wait for it
  ;# patch3: untaint pid before running kill() for -T scripts
  ;#
  ;# Revision 0.2.1.2  2000/03/02 22:35:02  ram
  ;# patch2: allow "undef" in -efunc and -wfunc to suppress logging
  ;# patch2: documented how to force warn() despite Log::Agent being there
  ;#
  ;# Revision 0.2.1.1  2000/01/04 21:18:10  ram
  ;# patch1: logerr and logwarn are autoloaded, need to check something real
  ;# patch1: forbid re-lock of a file we already locked
  ;# patch1: force $\ to be undef prior to writing the PID to lockfile
  ;# patch1: track where lock was issued in the code
  ;#
  ;# Revision 0.2.1.5  2000/09/18 19:55:07  ram
  ;# patch5: fixed computation of %F and %D when no '/' in file name
  ;# patch5: fixed OO example of lock to emphasize check on returned value
  ;# patch5: now warns when no lockfile is found during unlocking
  ;#
  ;# Revision 0.2.1.4  2000/08/15 18:41:43  ram
  ;# patch4: updated version number, grrr...
  ;#
  ;# Revision 0.2.1.3  2000/08/15 18:37:37  ram
  ;# patch3: fixed non-working "-wfunc => undef" due to misuse of defined()
  ;# patch3: check for stale lock while we wait for it
  ;# patch3: untaint pid before running kill() for -T scripts
  ;#
  ;# Revision 0.2.1.2  2000/03/02 22:35:02  ram
  ;# patch2: allow "undef" in -efunc and -wfunc to suppress logging
  ;# patch2: documented how to force warn() despite Log::Agent being there
  ;#
  ;# Revision 0.2.1.1  2000/01/04 21:18:10  ram
  ;# patch1: logerr and logwarn are autoloaded, need to check something real
  ;# patch1: forbid re-lock of a file we already locked
  ;# patch1: force $\ to be undef prior to writing the PID to lockfile
  ;# patch1: track where lock was issued in the code
  ;#
  ;# Revision 0.2  1999/12/07 20:51:05  ram
  ;# Baseline for 0.2 release.
  ;#
  
  use strict;
  
  ########################################################################
  package LockFile::Simple;
  
  #
  # This package extracts the simple locking logic used by mailagent-3.0
  # into a standalone Perl module to be reused in other applications.
  #
  
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
  
  use Sys::Hostname;
  require Exporter;
  require LockFile::Lock::Simple;
  eval "use Log::Agent";
  
  @ISA = qw(Exporter);
  @EXPORT = ();
  @EXPORT_OK = qw(lock trylock unlock);
  $VERSION = '0.208';
  
  my $LOCKER = undef;			# Default locking object
  
  #
  # ->make
  #
  # Create a file locking object, responsible for holding the locking
  # parameters to be used by all the subsequent locks requested from
  # this locking object.
  #
  # Configuration attributes:
  #
  #	autoclean		keep track of locks and release pending one at END time
  #   max				max number of attempts
  #	delay			seconds to wait between attempts
  #	format			how to derive lockfile from file to be locked
  #	hold			max amount of seconds before breaking lock (0 for never)
  #	ext				lock extension
  #	nfs				true if lock must "work" on top of NFS
  #	stale			try to detect stale locks via SIGZERO and delete them
  #	warn			flag to turn warnings on
  #	wmin			warn once after that many waiting seconds
  #	wafter			warn every that many seconds after first warning
  #	wfunc			warning function to be called
  #	efunc			error function to be called
  #
  # Additional attributes:
  #
  #	manager			lock manager, used when autoclean
  #	lock_by_file	returns lock by filename
  #
  # The creation routine first and sole argument is a "hash table list" listing
  # all the configuration attributes. Missing attributes are given a default
  # value. A call to ->configure can alter the configuration parameters of
  # an existing object.
  #
  sub make {
  	my $self = bless {}, shift;
  	my (@hlist) = @_;
  
  	# Set configuration defaults, then override with user preferences
  	$self->{'max'} = 30;
  	$self->{'delay'} = 2;
  	$self->{'hold'} = 3600;
  	$self->{'ext'} = '.lock';
  	$self->{'nfs'} = 0;
  	$self->{'stale'} = 0;
  	$self->{'warn'} = 1;
  	$self->{'wmin'} = 15;
  	$self->{'wafter'} = 20;
  	$self->{'autoclean'} = 0;
  	$self->{'lock_by_file'} = {};
  
  	# The logxxx routines are autoloaded, so need to check for @EXPORT
  	$self->{'wfunc'} = @Log::Agent::EXPORT ? \&logwarn : \&core_warn;
  	$self->{'efunc'} = @Log::Agent::EXPORT ?  \&logerr  : \&core_warn;
  
  	$self->configure(@hlist);		# Will init "manager" if necessary
  	return $self;
  }
  
  #
  # ->locker		-- "once" function
  #
  # Compute the default locking object.
  #
  sub locker {
  	return $LOCKER || ($LOCKER = LockFile::Simple->make('-warn' => 1));
  }
  
  #
  # ->configure
  #
  # Extract known configuration parameters from the specified hash list
  # and use their values to change the object's corresponding parameters.
  #
  # Parameters are specified as (-warn => 1, -ext => '.lock') for instance.
  #
  sub configure {
  	my $self = shift;
  	my (%hlist) = @_;
  	my @known = qw(
  		autoclean
  		max delay hold format ext nfs warn wfunc wmin wafter efunc stale
  	);
  
  	foreach my $attr (@known) {
  		$self->{$attr} = $hlist{"-$attr"} if exists $hlist{"-$attr"};
  	}
  
  	$self->{'wfunc'} = \&no_warn unless defined $self->{'wfunc'};
  	$self->{'efunc'} = \&no_warn unless defined $self->{'efunc'};
  
  	if ($self->autoclean) {
  		require LockFile::Manager;
  		# Created via "once" function
  		$self->{'manager'} = LockFile::Manager->manager(
  			$self->wfunc, $self->efunc);
  	}
  }
  
  #
  # Attribute access
  #
  
  sub max				{ $_[0]->{'max'} }
  sub delay			{ $_[0]->{'delay'} }
  sub format			{ $_[0]->{'format'} }
  sub hold			{ $_[0]->{'hold'} }
  sub nfs				{ $_[0]->{'nfs'} }
  sub stale			{ $_[0]->{'stale'} }
  sub ext				{ $_[0]->{'ext'} }
  sub warn			{ $_[0]->{'warn'} }
  sub wmin			{ $_[0]->{'wmin'} }
  sub wafter			{ $_[0]->{'wafter'} }
  sub wfunc			{ $_[0]->{'wfunc'} }
  sub efunc			{ $_[0]->{'efunc'} }
  sub autoclean		{ $_[0]->{'autoclean'} }
  sub lock_by_file	{ $_[0]->{'lock_by_file'} }
  sub manager			{ $_[0]->{'manager'} }
  
  #
  # Warning and error reporting -- Log::Agent used only when available
  #
  
  sub core_warn	{ CORE::warn(@_) }
  sub no_warn		{ return }
  
  #
  # ->lock
  #
  # Lock specified file, possibly using alternate file "format".
  # Returns whether file was locked or not at the end of the configured
  # blocking period by providing the LockFile::Lock instance if successful.
  #
  # For quick and dirty scripts wishing to use locks, create the locking
  # object if not invoked as a method, turning on warnings.
  #
  sub lock {
  	my $self = shift;
  	unless (ref $self) {			# Not invoked as a method
  		unshift(@_, $self);
  		$self = locker();
  	}
  	my ($file, $format) = @_;		# File to be locked, lock format
  	return $self->take_lock($file, $format, 0);
  }
  
  #
  # ->trylock
  #
  # Attempt to lock specified file, possibly using alternate file "format".
  # If the file is already locked, don't block and return undef. The
  # LockFile::Lock instance is returned upon success.
  #
  # For quick and dirty scripts wishing to use locks, create the locking
  # object if not invoked as a method, turning on warnings.
  #
  sub trylock {
  	my $self = shift;
  	unless (ref $self) {			# Not invoked as a method
  		unshift(@_, $self);
  		$self = locker();
  	}
  	my ($file, $format) = @_;		# File to be locked, lock format
  	return $self->take_lock($file, $format, 1);
  }
  
  #
  # ->take_lock
  #
  # Common code for ->lock and ->trylock.
  # Returns a LockFile::Lock object on success, undef on failure.
  #
  sub take_lock {
  	my $self = shift;
  	my ($file, $format, $tryonly) = @_;
  
  	#
  	# If lock was already taken by us, it's an error when $tryonly is 0.
  	# Otherwise, simply fail to get the lock.
  	#
  
  	my $lock = $self->lock_by_file->{$file};
  	if (defined $lock) {
  		my $where = $lock->where;
  		&{$self->efunc}("file $file already locked at $where") unless $tryonly;
  		return undef;
  	}
  
  	my $locked = $self->_acs_lock($file, $format, $tryonly);
  	return undef unless $locked;
  
  	#
  	# Create LockFile::Lock object
  	#
  
  	my ($package, $filename, $line) = caller(1);
  	$lock = LockFile::Lock::Simple->make($self, $file, $format,
  		$filename, $line);
  	$self->manager->remember($lock) if $self->autoclean;
  	$self->lock_by_file->{$file} = $lock;
  
  	return $lock;
  }
  
  #
  # ->unlock
  #
  # Unlock file.
  # Returns true if file was unlocked.
  #
  sub unlock {
  	my $self = shift;
  	unless (ref $self) {			# Not invoked as a method
  		unshift(@_, $self);
  		$self = locker();
  	}
  	my ($file, $format) = @_;		# File to be unlocked, lock format
  
  	if (defined $format) {
  		require Carp;
  		Carp::carp("2nd argument (format) is no longer needed nor used");
  	}
  
  	#
  	# Retrieve LockFile::Lock object
  	#
  
  	my $lock = $self->lock_by_file->{$file};
  
  	unless (defined $lock) {
  		&{$self->efunc}("file $file not currently locked");
  		return undef;
  	}
  
  	return $self->release($lock);
  }
  
  #
  # ->release			-- not exported (i.e. not documented)
  #
  # Same a unlock, but we're passed a LockFile::Lock object.
  # And we MUST be called as a method (usually via LockFile::Lock, not user code).
  #
  # Returns true if file was unlocked.
  #
  sub release {
  	my $self = shift;
  	my ($lock) = @_;
  	my $file = $lock->file;
  	my $format = $lock->format;
  	$self->manager->forget($lock) if $self->autoclean;
  	delete $self->lock_by_file->{$file};
  	return $self->_acs_unlock($file, $format);
  }
  
  #
  # ->lockfile
  #
  # Return the name of the lockfile, given the file name to lock and the custom
  # string provided by the user. The following macros are substituted:
  #	%D: the file dir name
  #   %f: the file name (full path)
  #   %F: the file base name (last path component)
  #   %p: the process's pid
  #   %%: a plain % character
  #
  sub lockfile {
  	my $self = shift;
  	my ($file, $format) = @_;
  	local $_ = defined($format) ? $format : $self->format;
  	s/%%/\01/g;				# Protect double percent signs
  	s/%/\02/g;				# Protect against substitutions adding their own %
  	s/\02f/$file/g;			# %f is the full path name
  	s/\02D/&dir($file)/ge;	# %D is the dir name
  	s/\02F/&base($file)/ge;	# %F is the base name
  	s/\02p/$$/g;			# %p is the process's pid
  	s/\02/%/g;				# All other % kept as-is
  	s/\01/%/g;				# Restore escaped % signs
  	$_;
  }
  
  # Return file basename (last path component)
  sub base {
  	my ($file) = @_;
  	my ($base) = $file =~ m|^.*/(.*)|;
  	return ($base eq '') ? $file : $base;
  }
  
  # Return dirname
  sub dir {
  	my ($file) = @_;
  	my ($dir) = $file =~ m|^(.*)/.*|;
  	return ($dir eq '') ? '.' : $dir;
  }
  
  #
  # _acs_lock			-- private
  #
  # Internal locking routine.
  #
  # If $try is true, don't wait if the file is already locked.
  # Returns true if the file was locked.
  #
  sub _acs_lock {		## private
  	my $self = shift;
  	my ($file, $format, $try) = @_;
  	my $max = $self->max;
  	my $delay = $self->delay;
  	my $stamp = $$;
  
  	# For NFS, we need something more unique than the process's PID
  	$stamp .= ':' . hostname if $self->nfs;
  
  	# Compute locking file name -- hardwired default format is "%f.lock"
  	my $lockfile = $file . $self->ext;
  	$format = $self->format unless defined $format;
  	$lockfile = $self->lockfile($file, $format) if defined $format;
  
  	# Detect stale locks or break lock if held for too long
  	$self->_acs_stale($file, $lockfile) if $self->stale;
  	$self->_acs_check($file, $lockfile) if $self->hold;
  
  	my $waited = 0;					# Amount of time spent sleeping
  	my $lastwarn = 0;				# Last time we warned them...
  	my $warn = $self->warn;
  	my ($wmin, $wafter, $wfunc);
  	($wmin, $wafter, $wfunc) = 
  		($self->wmin, $self->wafter, $self->wfunc) if $warn;
  	my $locked = 0;
  	my $mask = umask(0333);			# No write permission
  	local *FILE;
  
  	while ($max-- > 0) {
  		if (-f $lockfile) {
  			next unless $try;
  			umask($mask);
  			return 0;				# Already locked
  		}
  
  		# Attempt to create lock
  		if (open(FILE, ">$lockfile")) {
  			local $\ = undef;
  			print FILE "$stamp\n";
  			close FILE;
  			open(FILE, $lockfile);	# Check lock
  			my $l;
  			chop($l = <FILE>);
  			$locked = $l eq $stamp;
  			$l = <FILE>;			# Must be EOF
  			$locked = 0 if defined $l; 
  			close FILE;
  			last if $locked;		# Lock seems to be ours
  		} elsif ($try) {
  			umask($mask);
  			return 0;				# Already locked, or cannot create lock
  		}
  	} continue {
  		sleep($delay);				# Busy: wait
  		$waited += $delay;
  
  		# Warn them once after $wmin seconds and then every $wafter seconds
  		if (
  			$warn &&
  				((!$lastwarn && $waited > $wmin) ||
  				($waited - $lastwarn) > $wafter)
  		) {
  			my $waiting  = $lastwarn ? 'still waiting' : 'waiting';
  			my $after  = $lastwarn ? 'after' : 'since';
  			my $s = $waited == 1 ? '' : 's';
  			&$wfunc("$waiting for $file lock $after $waited second$s");
  			$lastwarn = $waited;
  		}
  
  		# While we wait, existing lockfile may become stale or too old
  		$self->_acs_stale($file, $lockfile) if $self->stale;
  		$self->_acs_check($file, $lockfile) if $self->hold;
  	}
  
  	umask($mask);
  	return $locked;
  }
  
  #
  # ->_acs_unlock		-- private
  #
  # Unlock file. If lock format is specified, it must match the one used
  # at lock time.
  #
  # Return true if file was indeed locked by us and is now properly unlocked.
  #
  sub _acs_unlock {	## private
  	my $self = shift;
  	my ($file, $format) = @_;		# Locked file, locking format
  	my $stamp = $$;
  	$stamp .= ':' . hostname if $self->nfs;
  
  	# Compute locking file name -- hardwired default format is "%f.lock"
  	my $lockfile = $file . $self->ext;
  	$format = $self->format unless defined $format;
  	$lockfile = $self->lockfile($file, $format) if defined $format;
  
  	local *FILE;
  	my $unlocked = 0;
  
  	if (-f $lockfile) {
  		open(FILE, $lockfile);
  		my $l;
  		chop($l = <FILE>);
  		close FILE;
  		if ($l eq $stamp) {			# Pid (plus hostname possibly) is OK
  			$unlocked = 1;
  			unless (unlink $lockfile) {
  				$unlocked = 0;
  				&{$self->efunc}("cannot unlock $file: $!");
  			}
  		} else {
  			&{$self->efunc}("cannot unlock $file: lock not owned");
  		}
  	} else {
  		&{$self->wfunc}("no lockfile found for $file");
  	}
  
  	return $unlocked;				# Did we successfully unlock?
  }
  
  #
  # ->_acs_check
  #
  # Make sure lock lasts only for a reasonable time. If it has expired,
  # then remove the lockfile.
  #
  # This is not enabled by default because there is a race condition between
  # the time we stat the file and the time we unlink the lockfile.
  #
  sub _acs_check {
  	my $self = shift;
  	my ($file, $lockfile) = @_;
  
  	my $mtime = (stat($lockfile))[9];
  	return unless defined $mtime;	# Assume file does not exist
  	my $hold = $self->hold;
  
  	# If file too old to be considered stale?
  	if ((time - $mtime) > $hold) {
  
  		# RACE CONDITION -- shall we lock the lockfile?
  
  		unless (unlink $lockfile) {
  			&{$self->efunc}("cannot unlink $lockfile: $!");
  			return;
  		}
  
  		if ($self->warn) {
  			my $s = $hold == 1 ? '' : 's';
  			&{$self->wfunc}("UNLOCKED $file (lock older than $hold second$s)");
  		}
  	}
  }
  
  #
  # ->_acs_stale
  #
  # Detect stale locks and remove them. This works by sending a SIGZERO to
  # the pid held in the lockfile. If configured for NFS, only processes
  # on the same host than the one holding the lock will be able to perform
  # the check.
  #
  # Stale lock detection is not enabled by default because there is a race
  # condition between the time we check for the pid, and the time we unlink
  # the lockfile: we could well be unlinking a new lockfile created inbetween.
  #
  sub _acs_stale {
  	my $self = shift;
  	my ($file, $lockfile) = @_;
  
  	local *FILE;
  	open(FILE, $lockfile) || return;
  	my $stamp;
  	chop($stamp = <FILE>);
  	close FILE;
  
  	my ($pid, $hostname);
  
  	if ($self->nfs) {
  		($pid, $hostname) = $stamp =~ /^(\d+):(\S+)/;
  		my $local = hostname;
  		return if $local ne $hostname;
  		return if kill 0, $pid;
  		$hostname = " on $hostname";
  	} else {
  		($pid) = $stamp =~ /^(\d+)$/;		# Untaint $pid for kill()
  		$hostname = '';
  		return if kill 0, $pid;
  	}
  
  	# RACE CONDITION -- shall we lock the lockfile?
  
  	unless (unlink $lockfile) {
  		&{$self->efunc}("cannot unlink stale $lockfile: $!");
  		return;
  	}
  
  	&{$self->wfunc}("UNLOCKED $file (stale lock by PID $pid$hostname)");
  }
  
  1;
  
  ########################################################################
  
  =head1 NAME
  
  LockFile::Simple - simple file locking scheme
  
  =head1 SYNOPSIS
  
   use LockFile::Simple qw(lock trylock unlock);
  
   # Simple locking using default settings
   lock("/some/file") || die "can't lock /some/file\n";
   warn "already locked\n" unless trylock("/some/file");
   unlock("/some/file");
  
   # Build customized locking manager object
   $lockmgr = LockFile::Simple->make(-format => '%f.lck',
  	-max => 20, -delay => 1, -nfs => 1);
  
   $lockmgr->lock("/some/file") || die "can't lock /some/file\n";
   $lockmgr->trylock("/some/file");
   $lockmgr->unlock("/some/file");
  
   $lockmgr->configure(-nfs => 0);
  
   # Using lock handles
   my $lock = $lockmgr->lock("/some/file");
   $lock->release;
  
  =head1 DESCRIPTION
  
  This simple locking scheme is not based on any file locking system calls
  such as C<flock()> or C<lockf()> but rather relies on basic file system
  primitives and properties, such as the atomicity of the C<write()> system
  call. It is not meant to be exempt from all race conditions, especially over
  NFS. The algorithm used is described below in the B<ALGORITHM> section.
  
  It is possible to customize the locking operations to attempt locking
  once every 5 seconds for 30 times, or delete stale locks (files that are
  deemed too ancient) before attempting the locking.
  
  =head1 ALGORITHM
  
  The locking alogrithm attempts to create a I<lockfile> using a temporarily
  redefined I<umask> (leaving only read rights to prevent further create
  operations). It then writes the process ID (PID) of the process and closes
  the file. That file is then re-opened and read. If we are able to read the
  same PID we wrote, and only that, we assume the locking is successful.
  
  When locking over NFS, i.e. when the one of the potentially locking processes
  could access the I<lockfile> via NFS, then writing the PID is not enough.
  We also write the hostname where locking is attempted to ensure the data
  are unique.
  
  =head1 CUSTOMIZING
  
  Customization is only possible by using the object-oriented interface,
  since the configuration parameters are stored within the object. The
  object creation routine C<make> can be given configuration parmeters in
  the form a "hash table list", i.e. a list of key/value pairs. Those
  parameters can later be changed via C<configure> by specifying a similar
  list of key/value pairs.
  
  To benefit from the bareword quoting Perl offers, all the parameters must
  be prefixed with the C<-> (minus) sign, as in C<-format> for the I<format>
  parameter..  However, when querying the object, the minus must be omitted,
  as in C<$obj-E<gt>format>.
  
  Here are the available configuration parmeters along with their meaning,
  listed in alphabetical order:
  
  =over 4
  
  =item I<autoclean>
  
  When true, all locks are remembered and pending ones are automatically
  released when the process exits normally (i.e. whenever Perl calls the
  END routines).
  
  =item I<delay>
  
  The amount of seconds to wait between locking attempts when the file appears
  to be already locked. Default is 2 seconds.
  
  =item I<efunc>
  
  A function pointer to dereference when an error is to be reported. By default,
  it redirects to the logerr() routine if you have Log::Agent installed,
  to Perl's warn() function otherwise.
  
  You may set it explicitely to C<\&LockFile::Simple::core_warn> to force the
  use of Perl's warn() function, or to C<undef> to suppress logging.
  
  =item I<ext>
  
  The locking extension that must be added to the file path to be locked to
  compute the I<lockfile> path. Default is C<.lock> (note that C<.> is part
  of the extension and can therefore be changed). Ignored when I<format> is
  also used.
  
  =item I<format>
  
  Using this parmeter supersedes the I<ext> parmeter. The formatting string
  specified is run through a rudimentary macro expansion to derive the
  I<lockfile> path from the file to be locked. The following macros are
  available:
  
      %%	A real % sign
      %f	The full file path name
      %D	The directory where the file resides
      %F	The base name of the file
      %p	The process ID (PID)
  
  The default is to use the locking extension, which itself is C<.lock>, so
  it is as if the format used was C<%f.lock>, but one could imagine things
  like C</var/run/%F.%p>, i.e. the I<lockfile> does not necessarily lie besides
  the locked file (which could even be missing).
  
  When locking, the locking format can be specified to supersede the object
  configuration itself.
  
  =item I<hold>
  
  Maximum amount of seconds we may hold a lock. Past that amount of time,
  an existing I<lockfile> is removed, being taken for a stale lock. Default
  is 3600 seconds. Specifying 0 prevents any forced unlocking.
  
  =item I<max>
  
  Amount of times we retry locking when the file is busy, sleeping I<delay>
  seconds between attempts. Defaults to 30.
  
  =item I<nfs>
  
  A boolean flag, false by default. Setting it to true means we could lock
  over NFS and therefore the hostname must be included along with the process
  ID in the stamp written to the lockfile.
  
  =item I<stale>
  
  A boolean flag, false by default. When set to true, we attempt to detect
  stale locks and break them if necessary.
  
  =item I<wafter>
  
  Stands for I<warn after>. It is the number of seconds past the first
  warning during locking time after which a new warning should be emitted.
  See I<warn> and I<wmin> below. Default is 20.
  
  =item I<warn>
  
  A boolean flag, true by default. To suppress any warning, set it to false.
  
  =item I<wfunc>
  
  A function pointer to dereference when a warning is to be issued. By default,
  it redirects to the logwarn() routine if you have Log::Agent installed,
  to Perl's warn() function otherwise.
  
  You may set it explicitely to C<\&LockFile::Simple::core_warn> to force the
  use of Perl's warn() function, or to C<undef> to suppress logging.
  
  =item I<wmin>
  
  The minimal amount of time when waiting for a lock after which a first
  warning must be emitted, if I<warn> is true. After that, a warning will
  be emitted every I<wafter> seconds. Defaults to 15.
  
  =back
  
  Each of those configuration attributes can be queried on the object directly:
  
      $obj = LockFile::Simple->make(-nfs => 1);
      $on_nfs = $obj->nfs;
  
  Those are pure query routines, i.e. you cannot say:
  
      $obj->nfs(0);                  # WRONG
      $obj->configure(-nfs => 0);    # Right
  
  to turn of the NFS attribute. That is because my OO background chokes
  at having querying functions with side effects.
  
  =head1 INTERFACE
  
  The OO interface documented below specifies the signature and the
  semantics of the operations. Only the C<lock>, C<trylock> and
  C<unlock> operation can be imported and used via a non-OO interface,
  with the exact same signature nonetheless.
  
  The interface contains all the attribute querying routines, one for
  each configuration parmeter documented in the B<CUSTOMIZING> section
  above, plus, in alphabetical order:
  
  =over 4
  
  =item configure(I<-key =E<gt> value, -key2 =E<gt> value2, ...>)
  
  Change the specified configuration parameters and silently ignore
  the invalid ones.
  
  =item lock(I<file>, I<format>)
  
  Attempt to lock the file, using the optional locking I<format> if
  specified, otherwise using the default I<format> scheme configured
  in the object, or by simply appending the I<ext> extension to the file.
  
  If the file is already locked, sleep I<delay> seconds before retrying,
  repeating try/sleep at most I<max> times. If warning is configured,
  a first warning is emitted after waiting for I<wmin> seconds, and
  then once every I<wafter> seconds, via  the I<wfunc> routine.
  
  Before the first attempt, and if I<hold> is non-zero, any existing
  I<lockfile> is checked for being too old, and it is removed if found
  to be stale. A warning is emitted via the I<wfunc> routine in that
  case, if allowed.
  
  Likewise, if I<stale> is non-zero, a check is made to see whether
  any locking process is still around (only if the lock holder is on the
  same machine when NFS locking is configured). Should the locking
  process be dead, the I<lockfile> is declared stale and removed.
  
  Returns a lock handle if the file has been successfully locked, which
  does not necessarily needs to be kept around. For instance:
  
      $obj->lock('ppp', '/var/run/ppp.%p');
      <do some work>
      $obj->unlock('ppp');
  
  or, using OO programming:
  
      my $lock = $obj->lock('ppp', '/var/run/ppp.%p') ||;
          die "Can't lock for ppp\n";
      <do some work>
      $lock->relase;   # The only method defined for a lock handle
  
  i.e. you don't even have to know which file was locked to release it, since
  there is a lock handle right there that knows enough about the lock parameters.
  
  =item lockfile(I<file>, I<format>)
  
  Simply compute the path of the I<lockfile> that would be used by the
  I<lock> procedure if it were passed the same parameters.
  
  =item make(I<-key =E<gt> value, -key2 =E<gt> value2, ...>)
  
  The creation routine for the simple lock object. Returns a blessed hash
  reference.
  
  =item trylock(I<file>, I<format>)
  
  Same as I<lock> except that it immediately returns false and does not
  sleep if the to-be-locked file is busy, i.e. already locked. Any
  stale locking file is removed, as I<lock> would do anyway.
  
  Returns a lock hande if the file has been successfully locked.
  
  =item unlock(I<file>)
  
  Unlock the I<file>.
  
  =back
  
  =head1 BUGS
  
  The algorithm is not bullet proof.  It's only reasonably safe.  Don't bet
  the integrity of a mission-critical database on it though.
  
  The sysopen() call should probably be used with the C<O_EXCL|O_CREAT> flags
  to be on the safer side. Still, over NFS, this is not an atomic operation
  anyway.
  
  B<BEWARE>: there is a race condition between the time we decide a lock is
  stale or too old and the time we unlink it. Don't use C<-stale> and set
  C<-hold> to 0 if you can't bear with that idea, but recall that this race
  only happens when something is already wrong. That does not make it right,
  nonetheless. ;-)
  
  =head1 AUTHOR
  
  Raphael Manfredi F<E<lt>Raphael_Manfredi@pobox.comE<gt>>
  
  =head1 SEE ALSO
  
  File::Flock(3).
  
  =cut
  
LOCKFILE_SIMPLE

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;
  use strict;
  use vars qw($VERSION);
  $VERSION = '0.234';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          push @{"$inheritor\::ISA"}, @_;
      };
  };
  
  "All your base are belong to us"
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  L<base>
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafaël Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007-10 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

$fatpacked{"version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);
  
  $VERSION = 0.9917;
  $CLASS = 'version';
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  
  push @ISA, "version::vpp";
  local $^W;
  
  *version::qv = \&version::vpp::qv;
  *version::declare = \&version::vpp::declare;
  *version::_VERSION = \&version::vpp::_VERSION;
  *version::vcmp = \&version::vpp::vcmp;
  *version::new = \&version::vpp::new;
  *version::numify = \&version::vpp::numify;
  *version::normal = \&version::vpp::normal;
  if ($] >= 5.009000) {
      no strict 'refs';
      *version::stringify = \&version::vpp::stringify;
      *{'version::(""'} = \&version::vpp::stringify;
      *{'version::(<=>'} = \&version::vpp::vcmp;
      *{'version::(cmp'} = \&version::vpp::vcmp;
      *version::parse = \&version::vpp::parse;
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
          local $^W;
          *{$class.'::declare'} =  \&{$CLASS.'::declare'};
          *{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
          map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
          %args =
          (
              qv => 1,
              'UNIVERSAL::VERSION' => 1,
          );
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
          *{$callpkg.'::declare'} =
          sub {return $class->declare(shift) }
          unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
          *{$callpkg.'::qv'} =
          sub {return $class->qv(shift) }
          unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
          local $^W;
          *UNIVERSAL::VERSION
          = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
          *{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
          *{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
          unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
          *{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
          unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  use vars qw($VERSION $CLASS @ISA $LAX $STRICT $WARN_CATEGORY);
  $VERSION = 0.9917;
  $CLASS = 'version::vpp';
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
  
VERSION

$fatpacked{"version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  use vars qw($VERSION $CLASS $STRICT $LAX);
  
  $VERSION = 0.9917;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  my $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  my $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  my $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  my $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
VERSION_REGEX

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use v5.009;
use strict;
use warnings;

package VC3::Builder;

use English qw/-mo_match_vars/;
use Getopt::Long qw/GetOptions/;
use Tie::RefHash;
use Cwd;

use Carp qw( confess );
$SIG{TERM} = \&cleanup_signal_handler;
$SIG{INT}  = \&cleanup_signal_handler;

# disable stdout buffering
select(STDOUT); $OUTPUT_AUTOFLUSH = 1;

my $pwd            = getcwd();
my $vc3_root       = $ENV{VC3_ROOT}       || "${pwd}/vc3-root";
my $vc3_distfiles  = $ENV{VC3_DISTFILES}  || "${pwd}/vc3-distfiles";
my $vc3_user_home  = $ENV{VC3_USER_HOME}  || "vc3-home";
my $vc3_repository = $ENV{VC3_REPOSITORY} || "http://download.virtualclusters.org/builder-files";

my @external_dependencies = qw/perl sh tail tar gcc g++ ld pkconfig make/;
my @cleanups;     # functions to call on exit.

# call main if running interactively
VC3::Builder::main();


sub usage {
    my ($script_name) = @_;
    return <<EOF;
$script_name [options] --require package[:min_version[:max_version]] --require ... [-- command-and-args]

  command-and-args      defaults to /bin/sh

  options are:

  --database <catalog>  defaults to <internal> if available, otherwise 
                        to ./vc3_catalog.json. May be specified several times,
                        with latter package recipes overwriting previous ones. 

  --install <root>      Install with base <root>. 
                        Default is ${vc3_root}
  --home <home>         Set \${HOME} to <root>/<home> if <home> is a relative
                        path, otherwise to <home> if it is an absolute path.
                        Default is ${vc3_user_home}

  --distfiles <dir>     Directory to cache unbuilt packages locally.
                        Default is ${vc3_distfiles}
  --repository <url>    Site to fetch packages if needed.
                        Default is ${vc3_repository}

  --force               Reinstall the packages named with --require and the
                        packages they depend on.


  --make-jobs <n>       Concurrent make jobs. Default is 4.
  --sh-on-error         On building error, run /bin/sh on the partially-built
                        environment.

  --sys package:version=<dir>
                        Assume <dir> to be the installation location of
                        package:version in the system.
                        (e.g. --sys python:2.7=/opt/local/)
  --no-sys=<package>    Do not use host system version of <package>. If
                        package is 'ALL', do not use system versions at
                        all. (Ignored if package specified with --sys.)

  --var NAME=VALUE      Add environment variable NAME with VALUE. 
                        May be specified several times.

  --revar PATTERN       All environment variables matching the regular
                        expression PATTERN are preserved.
                        (E.g. --revar "SGE_.*", --revar NAME is equivalent
                        to -var NAME=\$NAME)

  --interactive         Treat command-and-args as an interactive terminal.

  --silent              Do not print dependency information.
  --no-run              Set up environment, but do not execute any payload.

  --env-to <file>       Write environment scripts to <root>/<home>/<file>{,.cmd},
                        but do not execute the payload.

  --dot <file>          Write a dependency graph of the requirements to <file>.

  --parallel <dir>      Write specifications for a parallel build to <dir>.
                        (Implies --prestage.)

  --prestage            Download all files to --distfiles <dir> before
                        processing.

  Developers options:
  --debug               On a builder error, print the full back-trace. 

Examples:
    ${script_name} --require cvmfs 'ls /cvmfs/atlas.cern.ch' 
    ${script_name} --require maker-example-ecoli-01
EOF

}

sub cleanup_signal_handler {
    my ($signal) = @_;

    if($signal) {
        warn("Got signal!: $signal");
    }

    for my $fn (@cleanups) {
        eval { $fn->() };
    }

    if($signal) {
        $? = 128;
        exit $?;
    }
}

END {
    cleanup_signal_handler();
}

sub main {
    my @requires     = ();

    my $print_help   = 0;
    my $make_jobs    = 4;
    my $sh_on_error  = 0;
    my $env_to       = 0;

    my $debug_modules_used = 0;
    my $dry_run            = 0;
    my $no_run             = 0;
    my $debug_run          = 0;
    my $interactive_run    = 0;
    my $silent             = 0;
    my $force_rebuild      = 0;
    my $prestage           = 0;

    my $ignore_locks       = 0;

    my $dot_output;
    my $parallel_dir;       

    my @databases   = ();
    my @extra_vars  = ();
    my @re_vars     = ();
    my @sys_locs    = ();
    my @no_sys_locs = ();

    # if the executable name does looks like "perl", we use $0, as it has the
    # name of the script. Otherwise, this is a static run, and we use the given
    # executable name.
    my $script_name = ${EXECUTABLE_NAME} =~ /perl/ ? $0 : ${EXECUTABLE_NAME};

    my $original_command = join(' ', $script_name, @ARGV);


    my $opt_result = GetOptions(
        "help"        => \$print_help,

        "debug"    => \$debug_run,
        "silent"   => \$silent,

        "database=s"  => \@databases,
        "require=s"   => \@requires, 

        "install=s" => \$vc3_root,
        "home=s"    => \$vc3_user_home,

        "distfiles=s"  => \$vc3_distfiles, 
        "repository=s" => \$vc3_repository, 

        "make-jobs=n" => \$make_jobs,

        "sh-on-error"     => \$sh_on_error,

        "force"           => \$force_rebuild,
        "ignore-locks"    => \$ignore_locks,

        "env-to=s" => \$env_to,

        "dot=s"    => \$dot_output,

        "dry-run"  => \$dry_run,
        "no-run"   => \$no_run,
        "prestage" => \$prestage,

        "interactive" => \$interactive_run,

        "sys=s"    => \@sys_locs,
        "no-sys=s" => \@no_sys_locs,
        "var=s"    => \@extra_vars,
        "revar=s"  => \@re_vars,

        "parallel=s" => \$parallel_dir,

        # options for developing, not for runtime:
        "debug-modules-used" => \$debug_modules_used,
    );

    unless($opt_result) {
        print usage($script_name);
        exit 1;
    }

    if($debug_run) {
        $SIG{__DIE__}  =  \&confess;
    }

    unshift @databases, '<internal>';

    if($print_help) {
        print usage($script_name);
        exit 0;
    }

    if($debug_modules_used) {
        print_modules_used();
        exit 0;
    }

    if(defined $dot_output) {
        push @no_sys_locs, 'ALL';
        $dry_run = 1;
    }
    
    #disable system deps for now:
    push @no_sys_locs, 'ALL';

    if(defined $parallel_dir) {
        push @no_sys_locs, 'ALL';
    }

    unless(@requires) {
        print "At least one --require option should be given.\n\n" . usage($script_name);
        exit 1;
    }

    # set defaults
    my @command_and_args = @ARGV;
    if(!@command_and_args) {
        @command_and_args = ('/bin/sh',);
        $interactive_run = 1;
    }

    push @extra_vars, "MAKEFLAGS=-j${make_jobs}";
    push @extra_vars, "VC3_COMMAND_LINE=" . File::Spec->rel2abs(join(" ", $original_command));

    for my $pat (@re_vars) {
        for my $name (keys %ENV) {
            next unless $name =~ /$pat/;
            push @extra_vars, "$name='" . $ENV{$name} . "'";
        }
    }

    my $bag = VC3::Bag->new($dry_run, $interactive_run, $silent, \@databases, \@sys_locs, \@no_sys_locs, \@extra_vars);

    $bag->set_plan_for(@requires);

    if(defined $dot_output) {
        $bag->dot_graph($dot_output);
    }

    if($bag->dry_run) {
        exit 0;
    }

    if(defined $parallel_dir) {
        $bag->to_parallel($parallel_dir, $make_jobs);
        $bag->check_manual_requirements();

        $bag->set_plan_for('cctools-statics');
        $ignore_locks = 1;
        $prestage     = 1;
    }

    $bag->check_manual_requirements();

    if($prestage) {
        $bag->plan->prestage();
    }

    $bag->execute_plan($sh_on_error, $force_rebuild, $ignore_locks);

    my $exit_code;
    if($no_run) {
        $exit_code = 0;
    } elsif($env_to) {
        $bag->set_environment($env_to, @command_and_args);
        $exit_code = 0;
    } else {
        $exit_code = $bag->execute(@command_and_args);
    }

    exit $exit_code;
}

sub print_modules_used {
    my $file = "stub-debug-modules.txt";

    unlink "$vc3_distfiles/$file";

    File::Path::make_path($vc3_distfiles);

    my $ff       = HTTP::Tiny->new();
    my $url      = $vc3_repository . '/' . $file;
    my $output   = $vc3_distfiles  . '/' . $file;

    # dummy calls to trigger the use of the http module.
    my $response_a = $ff->mirror($url, $output);
    my $response_b = $ff->mirror($url, $output);

    my @modules = grep { /\.pm$/ } keys %INC;

    # add modules that %INC sometimes does not find:
    @modules = (@modules, qw/strict PerlIO encoding Digest::Perl::MD5/);

    # turn :: into /
    map { s^/^::^g }   @modules;

    # remove .pm extension
    map { s^\.pm$^^g } @modules;

    # remove duplicates
    @modules = uniq_words(@modules);

    @modules = sort { uc($a) cmp uc($b) } @modules;

    print join("\n", @modules), "\n";
}

sub uniq_words {
    my %words;
    for my $word (@_) {
        $words{$word} = 1;
    }

    return keys %words;
}

package VC3::Bag; 

use Carp qw/carp croak/;
use English qw/-mo_match_vars/;
use File::Copy;
use File::Spec ();
use File::Temp qw/tempfile/;
use FindBin  qw/$RealBin $RealScript/;
use JSON::Tiny;
use List::Util qw/max/;
use POSIX ();
use version ();

sub new {
    my ($class, $dry_run, $interactive_run, $silent, $databases, $sys_locs, $no_sys_locs, $extra_vars) = @_;

    my $self = bless {}, $class;

    $self->{dry_run}         = $dry_run;
    $self->{interactive_run} = $interactive_run;
    $self->{silent_run}      = $silent;

    $self->set_builder_variables();

    $self->{sources} = $self->decode_bags($databases);

    $self->{no_system} = { map { ( $_ => 1 ), } @{$no_sys_locs} };

    $self->add_manual_variables($extra_vars);
    $self->add_manual_packages($sys_locs);

    return $self;
}

sub check_manual_requirements() {
    my ($self) = @_;

    my @restricted_unmet;
    for my $w (@{$self->{order}}) {
        my $msg = $w->msgs_manual_requirements();
        if($msg) {
            $self->activate_widget($w);
            push @restricted_unmet, $w->msgs_manual_requirements();
        }
    }

    if(@restricted_unmet > 0) {
        my ($pid, $build_in) = $self->shell();

        print { $build_in } "cat <<EOF\n";

        for my $msg (@restricted_unmet) {
            for my $line (@{$msg}) {
                print { $build_in } "$line\n";
            }
            print { $build_in } "\n";
        }

        print { $build_in } "EOF\n";
        print { $build_in } "exit 0\n";

        die;
    }

    return 1;
}


sub active_widgets {
    my ($self) = @_;

    unless($self->{active_widgets}) {
        my %new;
        tie %new, 'Tie::RefHash';

        $self->{active_widgets} = \%new;
    }

    return $self->{active_widgets};
}

sub activate_widget {
    my ($self, $widget) = @_;
    $self->active_widgets->{$widget} = 1;
}

sub set_builder_variables {
    my ($self) = @_;

    $self->{environment_variables} = [];

    $self->set_machine_vars();

    # expand ~
    $vc3_root      = glob $vc3_root;
    $vc3_distfiles = glob $vc3_distfiles;
    $vc3_user_home = glob $vc3_user_home;

    # to absolute paths
    $vc3_root      = File::Spec->rel2abs(${vc3_root});
    $vc3_distfiles = File::Spec->rel2abs(${vc3_distfiles});
    unless(File::Spec->file_name_is_absolute($vc3_user_home)) {
        $vc3_user_home = File::Spec->join($vc3_root, $vc3_user_home);
    }

    my $tmp_dir = "$vc3_root/tmp";

    $self->root_dir($vc3_root);

    $self->home_dir($vc3_user_home);
    $self->tmp_dir($tmp_dir);

    $self->builder_path("$RealBin/$RealScript");

    File::Path::make_path($self->root_dir);
    File::Path::make_path($vc3_distfiles);
    File::Path::make_path(File::Spec->join($vc3_distfiles, 'manual-distribution'));
    File::Path::make_path(File::Spec->join($vc3_distfiles, 'perl'));
    File::Path::make_path(File::Spec->join($vc3_distfiles, 'python'));
    File::Path::make_path($self->home_dir);
    File::Path::make_path($self->tmp_dir);

    my ($profile_f, $profile_name) = tempfile(File::Spec->join($self->home_dir, '.vc3_sh-XXXXXX'));
    close $profile_f;
    $self->sh_profile($profile_name);
    push @cleanups, sub { $self->cleanup() };

    $self->add_builder_variable('VC3_ROOT',         $vc3_root);
    $self->add_builder_variable('VC3_DISTFILES',    $vc3_distfiles);
    $self->add_builder_variable('VC3_BUILDER_PATH', $self->builder_path);
    $self->add_builder_variable('HOME',             $self->home_dir);
    $self->add_builder_variable('TMP',              $self->tmp_dir);
    $self->add_builder_variable('TERM',             'linux');
    $self->add_builder_variable('USER',             getlogin() || $ENV{'USER'} || 'vc3-user');
}

sub DESTROY {
    my ($self) = @_;
    $self->cleanup();
}

sub root_dir {
    my ($self, $root) = @_;

    $self->{root_dir} = $root if($root);

    return $self->{root_dir};
}

sub home_dir {
    my ($self, $home) = @_;

    $self->{home_dir} = $home if($home);

    return $self->{home_dir};
}

sub tmp_dir {
    my ($self, $tmp) = @_;

    $self->{tmp_dir} = $tmp if($tmp);

    return $self->{tmp_dir};
}

sub plan {
    my ($self, $new) = @_;

    $self->{plan} = $new if($new);

    return $self->{plan};
}

sub builder_path {
    my ($self, $new) = @_;

    $self->{builder} = $new if($new);

    return $self->{builder};
}


sub sh_profile {
    my ($self, $init) = @_;

    $self->{sh_profile} = $init if($init);

    return $self->{sh_profile};
}

sub dry_run {
    my ($self) = @_;
    return $self->{dry_run};
}

sub environment_variables {
    my ($self, $new_vars) = @_;

    $self->{environment_variables} = $new_vars if($new_vars);

    return $self->{environment_variables};
}

sub add_builder_variable {
    my ($self, $name, $value) = @_;

    my $var = {
        name     => $name,
        value    => $value,
        clobber  => 1,
        absolute => 1
    };

    my $vars = $self->environment_variables;
    push @{$vars}, $var;

    return $var;
}

sub add_manual_variables {
    my ($self, $extra_vars) = @_;

    for my $var (@{$extra_vars}) {
        $var =~ m/
        ^
        (?<name>[A-Za-z_][A-Z-a-z_0-9]*)
        =
        (?<value>.*)
        $
        /x or die "Malformed variable specification: '$var'";

        $self->add_builder_variable($+{name}, $+{value});
    }
}

sub add_manual_packages {
    my ($self, $specs) = @_;

    for my $spec (@{$specs}) {
        $spec =~ m/
        ^
        (?<name>[A-Za-z_][A-Z-a-z_0-9]*)
        :
        (?<version>([0-9]+(\.?[0-9]){0,2}))
        =
        (?<dir>.*)
        $
        /x or die "Malformed manual specification: '$spec'\n";

        my ($name, $version, $dir) = @+{qw(name version dir)};

        my $s = {};
        $s->{version} = $version;
        $s->{sources} = [
            {
                type => 'system',
                'recipe' => [
                    "echo VC3_ROOT_SYSTEM: $dir"
                ]
            }
        ];

        my $widgets;
        eval { $widgets = $self->widgets_of($name) };
        if($@) {
            die "Could not find specification to overwrite for '$name'\n";
        }

        unshift @{$widgets}, VC3::Widget->new($self, $name, $s);
    }
}

sub del_builder_variable {
    my ($self, $name) = @_;

    my @vars = @{$self->environment_variables};
    @vars = grep { $name ne $_->{name} } @vars;

    $self->environment_variables(\@vars);
}

sub set_plan_for {
    my ($self, @requires) = @_;

    $self->{indent_level} = 0;

    my $plan = VC3::Plan->new($self);
    $self->plan($plan);

    if(!$plan->add_main_targets(@requires)) {
        die("Could not find an installation plan.\n");
    }

    $self->{ords} = $plan->order();
    my @ordered = sort { ($self->{ords}{$a} <=> $self->{ords}{$b}) || ($a cmp $b) } keys %{$self->{ords}};
    $self->{order} = [ map { $plan->elements->{$_}{widget} } @ordered ];

    return $plan;
}

sub execute_plan {
    my ($self, $sh_on_error, $force_rebuild, $ignore_locks) = @_;

    for my $w (@{$self->{order}}) {
        $self->build_widget($w, $sh_on_error, $force_rebuild, $ignore_locks);
        $self->activate_widget($w);
    }
}

sub cleanup {
    my ($self) = @_;

    if($self->{child_pid}) {
        $self->say('Cleaning payload with pid: ' . $self->{child_pid});
        kill 'TERM', -$self->{child_pid};
    }

    if(-f $self->sh_profile) {
        unlink $self->sh_profile;
    }

    my $cmd_file = $self->sh_profile . '.cmd';
    if(-f $cmd_file) {
        unlink $cmd_file;
    }

    if($self->{child_pid}) {
        # give 10 seconds for child to cleanup TERM, then REDRUM
        for my $i (1..5) {
            my $n = kill 0, -$self->{child_pid};
            if($n) {
                $self->say('Waiting for payload with pid: ' . $self->{child_pid} . "  $n");
                sleep(2);
            } else {
                $self->{child_pid} = undef;
                return;
            }
        }
        $self->say('Hard terminating for payload with pid: ' . $self->{child_pid});
        kill 'KILL', -$self->{child_pid};
        $self->{child_pid} = undef;
    }
}

sub set_machine_vars {
    my ($self) = @_;

    ($self->{osname}, undef, undef, undef, $self->{architecture}) = POSIX::uname();

    $self->{target} = $self->architecture . '/' . $self->distribution;

    my $ldd_version_raw = qx(ldd --version);
    $ldd_version_raw =~ /
    # we are looking for a line starting with 'ldd'
    ^ldd
    # followed by anything
    .*
    # followed by at least one space
    \s+
    # followed by the version number (that we capture)
    ([0-9.]+)
    # followed by any number of spaces at the end of the line
    \s*$
    # options: x allows regexp comments. m treats each line indepedently
    /xm ;

    $self->{glibc_version} = $1
    || 'unknown';

    $self->add_builder_variable('VC3_MACHINE_OS',            $self->osname);
    $self->add_builder_variable('VC3_MACHINE_ARCH',          $self->architecture);
    $self->add_builder_variable('VC3_MACHINE_GLIBC_VERSION', $self->glibc_version);
    $self->add_builder_variable('VC3_MACHINE_TARGET',        $self->{target});
}

sub target {
    my ($self) = @_;
    return $self->{target};
}

sub osname {
    my ($self) = @_;
    return $self->{osname};
}

sub architecture {
    my ($self) = @_;
    return $self->{architecture};
}

sub glibc_version {
    my ($self) = @_;
    return $self->{glibc_version};
}

# reads /etc/readhat-release and transforms something like:
# 'Red Hat Enterprise Linux Server release 6.5 (Santiago)'
# into 'redhat6'.
sub distribution {
    my ($self) = @_;

    my $distribution='generic';
    
    if (-f '/etc/redhat-release') {
        open (my $file_fh, '<', '/etc/redhat-release');
        my $redhat_version_line = <$file_fh>;

        $redhat_version_line =~ /\brelease\b\s+([0-9]+)\b/;
        my $redhat_version = $1;

        die 'Could not find redhat version!' unless $redhat_version;

        $distribution="redhat${redhat_version}"
    }
    
    return $distribution;
}

sub widgets_of {
    my ($self, $name) = @_;

    my $widgets = $self->{sources}{$name}
    || die "I do not know anything about '$name' . \n";

    return $widgets;
}

sub decode_bags {
    my ($self, $databases) = @_;

    my $sources = {};

    for my $filename (@{$databases}) {
        $self->decode_bag($sources, $filename);
    }

    return $sources;
}

sub decode_bag {
    my ($self, $sources, $filename) = @_;

    {
        no warnings;
        if($filename eq '<internal>' && tell(VC3::Builder::DATA) == -1) {
            $filename = './vc3-catalog.json';
            return $sources unless -f $filename; 
        }
    }

    my $catbag_f;
    if($filename eq '<internal>') {
        $catbag_f = *VC3::Builder::DATA;
    } else {
        open($catbag_f, '<:encoding(UTF-8)', $filename) ||
        die "Could not open '$filename': $!";
    }

    my $contents = do { local($/); <$catbag_f> };
    close($catbag_f);

    my $bag_raw = JSON::Tiny::decode_json($contents);

    for my $widget_name (keys %{$bag_raw}) {
        my @versions = map { VC3::Widget->new($self, $widget_name, $_) } @{$bag_raw->{$widget_name}};
        $sources->{$widget_name} = \@versions;
    }

    return $sources;
} 

sub build_widget {
    my ($self, $widget, $sh_on_error, $force_rebuild, $ignore_locks) = @_;

    $self->say("processing for @{[$widget->name]}-" . $widget->version->normal);

    my $s = $widget->active_source;

    my $exit_status = 0;
    if($s) {
        eval { $exit_status = -1; $exit_status = $s->execute_recipe($force_rebuild, $ignore_locks) };

        if($exit_status) {
            $widget->process_error($sh_on_error, $EVAL_ERROR, $exit_status);
            exit 1;
        }
    }

    return $exit_status;
}

sub dot_graph {
    my ($self, $dotname) = @_;
    return $self->plan->dot_graph($dotname);
}

sub to_parallel {
    my ($self, $dir, $make_jobs) = @_;

    my $abs_dir;
    if(File::Spec->file_name_is_absolute($dir)) {
        $abs_dir = $dir;
    } else {
        $abs_dir = File::Spec->join($self->home_dir, $dir);
    }

    my $dag_name       = 'dag';
    my $builder_name   = 'builder';
    my $local_database = 'recipes';

    File::Path::make_path($abs_dir);

    open my $script_f, '>', "$abs_dir/build" || die "Could not open '$abs_dir/build' for writing: $!";
    print { $script_f } <<EOFF;
#! /bin/sh
set -e

makeflow --shared-fs @{[$self->root_dir]} -r 5 $dag_name "\$@"

cat <<EOF
To run, from the current directory type:

./$builder_name --database $local_database --install @{[$self->root_dir]} @{[map { "--require $_" } @{$self->plan->requirements}]}

EOF
EOFF

    close $script_f;
    chmod 0755, "$abs_dir/build";

    copy($self->builder_path, "$abs_dir/$builder_name");
    chmod 0755, "$abs_dir/$builder_name";

    $self->plan->to_makeflow($abs_dir, $dag_name, $builder_name, $local_database, $make_jobs);

    $self->check_manual_requirements();
    $self->plan->prestage();
}

sub set_environment_variables {
    my ($self, $sh_f) = @_;

    my $env = $self->active_widgets();

    my $expansion = {};

    for my $var (@{$self->environment_variables}) {
        $expansion->{$var->{name}} = [$var->{value}];
    }

    for my $wid (@{$self->{order}}) {
        next unless $env->{$wid};
        $wid->consolidate_environment_variables($expansion);
    }

    $expansion->{'PATH'} ||= [];
    $expansion->{'LD_LIBRARY_PATH'} ||= [];

    # use default PATH:
    push @{$expansion->{'PATH'}}, $ENV{'PATH'} || '/bin:/usr/bin';
    push @{$expansion->{'LD_LIBRARY_PATH'}}, $ENV{'LD_LIBRARY_PATH'} || '/lib:/usr/lib:/usr/local/lib';

    for my $var_name (keys %{$expansion}) {
        eval { $expansion->{$var_name} = join(':', @{$expansion->{$var_name}}) };
        if($@) {
            carp("Environment variable '$var_name' is not defined.");
        }
    }

    my @ordered = $self->order_variables($expansion);

    for my $var_name (@ordered) {
        my $value = $expansion->{$var_name};
        print { $sh_f } "export $var_name=\"$value\"\n";
    }
}

sub order_variables {
    my ($self, $expansion) = @_;

    my @alpha = sort { $a cmp $b } keys %{$expansion};

    my $order = {};

    my $index = 1;
    for my $var (@alpha) {
        $order->{$var} = $index;
        $index++;
    }

    my $total_passes = 0;
    my $swap       = 1;

    while($swap) {
        $swap = 0;

        my @ordered = sort { ($order->{$a} <=> $order->{$b}) || ($a cmp $b) } keys %{$expansion};

        for my $var (@ordered) {
            my $value = $expansion->{$var};
            my @deps  = ($value =~ m/\$\{(\w+)\}/g);

            next unless @deps;

            my $org   = $order->{$var};
            my $nxt   = 1 + max(map { $order->{$_} || carp "Variable '$_' is not defined." } @deps);

            if($nxt > $org) {
                $swap++;
                $order->{$var} = $nxt;
            }
        }

        $total_passes++;
        carp "Cyclic dependency in environment variables." if $total_passes > @alpha;
    }

    my @ordered = sort { ($order->{$a} <=> $order->{$b}) || ($a cmp $b) } keys %{$expansion};
    return @ordered;
}


sub set_wrapper {
    my ($self, $wrapper_file, $profile_file) = @_;

    my $env = $self->active_widgets();

    my $payload = "/bin/sh -c '. $profile_file'";
    for my $w (@{$self->{order}}) {
        next unless $env->{$w};

        my $wrap = $w->wrapper;

        next unless $wrap;

        if( $wrap =~ /\{\}/ ) {
            $wrap =~ s/\{\}/$payload/;
            $payload = $wrap;
        } else {
            $payload = $wrap . ' ' . $payload;
        }
    }


    # write to $env_file
    open(my $sh_f, '>', "$wrapper_file")
    || die "Could not open file $wrapper_file: $!";

    print { $sh_f } "#!/usr/bin/env -i /bin/sh\n\n";

    $self->set_environment_variables($sh_f);

    print { $sh_f } "\ncd '" . $self->home_dir . "'\n";
    print { $sh_f } "exec $payload\n\n";
    return $payload;
}

sub consolidate_prologue {
    my ($self) = @_;

    my $env = $self->active_widgets();

    my @progs = ("cd '" . $self->home_dir . "'");

    for my $w (@{$self->{order}}) {
        next unless $env->{$w};

        if($w->prologue) {
            push @progs, @{$w->prologue};
        }
    }

    return \@progs;
}

sub set_profile {
    my ($self, $profile_file, @command_and_args) = @_;

    # write to $profile
    open(my $profile_f, '>', $profile_file)
    || die "Could not open file '$profile_file': $!";

    print { $profile_f } "#!/bin/sh\n\n";

    my $prologue = $self->consolidate_prologue();
    for my $line (@{$prologue}) {
        print { $profile_f } "$line\n";
    }

    if(@command_and_args) {
        print { $profile_f } join(' ', 'exec', @command_and_args, "\n");
    }
    close $profile_f;
}

sub set_environment {
    my ($self, $wrapper_file, @command_and_args) = @_;

    $wrapper_file = $self->sh_profile;
    my $profile_file = "$wrapper_file.cmd";

    $self->set_profile($profile_file, @command_and_args);
    $self->set_wrapper($wrapper_file, $profile_file);
}


sub execute {
    my ($self, @command_and_args) = @_;

    $self->set_environment($self->sh_profile, @command_and_args);

    my $pid = fork();

    if($pid == 0) {
        my @args = (
            '/usr/bin/env',
            '-i',
            '/bin/sh',
            '-c',
            ". " . $self->sh_profile);

        POSIX::setpgid(0, 0);

        exec { $args[0] } @args;
        die 'Could not exec payload';
    } elsif($pid > 0) {

        close(STDIN);
        close(STDOUT);
        POSIX::setpgid($pid, $pid);

        if($self->{interactive_run}) {
            $self->bring_to_foreground($pid);
        }

        $self->{child_pid} = $pid;
        waitpid $pid, 0;
        my $status = $?;
        $self->{child_pid} = undef;

        return POSIX::WEXITSTATUS($status);
    } else {
        die 'Could not fork to exec payload: ' . $!;
    }
}

sub bring_to_foreground {
    my ($self, $groupid) = @_;

    $SIG{TTOU} = 'IGNORE';

    open my $term, '+<', '/dev/tty';
    return unless $term;

    POSIX::tcsetpgrp(fileno($term), $groupid) or die "Could not bring child to foreground: $!";

    close $term;
}

sub shell {
    my ($self, $payload) = @_;

    $payload |= '/bin/sh';
    $self->set_environment($self->sh_profile, $payload);

    my $pid = open(my $input, '|-');
    if($pid == 0) {
        my @args = (
            '/usr/bin/env',
            '-i',
            '/bin/sh',
            '-c',
            ". " . $self->sh_profile);
        exec { $args[0] } @args;
        die 'Could not exec shell';
    } elsif($pid > 0) {
        $self->{child_pid} = $pid;
        # wait for this shell later.
    } else {
        die 'Could not fork to exec payload: ' . $!;
    }

    return ($pid, $input);
}

sub shell_user {
    my ($self) = @_;
    return $self->execute('/bin/sh');
}

sub say {
    my ($self, @rest) = @_;

    return if($self->{silent_run});

    print( ('.' x (2*$self->{indent_level})), join(' ', @rest), "\n");
}


package VC3::Widget;
use Carp;
use POSIX ":sys_wait_h";
use IO::Handle;
use Digest::Perl::MD5 qw(md5_hex);
use Cwd;
use File::Temp qw/tempdir/;
use Data::Dumper;


use JSON::Tiny;

# Attributes:
# name, version, sources, dependencies, environment_variables
sub new {
    my ($class, $bag, $name, $json_description) = @_;

    my $self = bless {}, $class;

    $self->bag($bag);
    $self->name($name);
    $self->version($json_description->{version});
    $self->sources($json_description->{sources});
    $self->dependencies($json_description->{dependencies});
    $self->wrapper($json_description->{wrapper});
    $self->prologue($json_description->{prologue});
    $self->environment_variables($json_description->{environment_variables});
    $self->phony($json_description->{phony});

    $self->add_widget_variable('ROOT',    $self->root_dir);

    my $majmin = $self->version->normal;
    $majmin =~ s/^v([0-9]+\.[0-9]+)\..*/$1/;

    $self->add_widget_variable('VERSION', $majmin);

    return $self;
}

sub add_widget_variable {
    my ($self, $varname, $value) = @_;

    my $vars    = $self->environment_variables || [];

    $varname = $self->widget_var($varname);

    my $var = {
        name     => $varname,
        value    => $value,
        clobber  => 1,
        absolute => 1
    };
    unshift @{$vars}, $var;

    $self->environment_variables($vars);
}

sub widget_var {
    my ($self, $varname) = @_;

    my $expanded = "VC3_${varname}_" . uc($self->name);

    # replace - with _, as env vars cannot have - in their names.
    $expanded =~ s/-/_/g;

    return $expanded;
}

sub bag {
    my ($self, $new_bag) = @_;

    $self->{bag} = $new_bag if($new_bag);

    croak 'No bag given'
    unless($self->{bag}); 

    return $self->{bag};
}

sub ribbon {
    my ($self) = @_;

    unless($self->{ribbon}) {
        $self->{ribbon} = VC3::Ribbon->new($self->name, $self->bookeeping_dir, $self->bag->tmp_dir, $self->checksum);
    }

    return $self->{ribbon};
}

sub name {
    my ($self, $new_name) = @_;

    if($new_name) {
        # names can only contain letters, numbers, - and _.
        my @badchars = ($new_name =~ /([^A-Za-z0-9-_])/g);
        if(@badchars) {
            die "The name '$new_name' containes the following disallowed charactares: " 
            . join ', ', map { "'$_'" } @badchars;
        } else {
            $self->{name} = $new_name if($new_name);
        }
    }

    die 'No name given'
    unless($self->{name}); 

    return $self->{name};
}

sub version {
    my ($self, $new_version) = @_;

    if($new_version) {
        $self->{version} = version->declare($new_version);
    }

    unless($self->{version}) {
        croak 'No version given';
    }

    return $self->{version};
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    $self->{dependencies} = $new_dependencies if($new_dependencies);

    return $self->{dependencies};
}

sub sources {
    my ($self, $new_sources) = @_;

    if($new_sources) {
        my @sources = map { VC3::Source->new($self, $_) } @{$new_sources};
        $self->{sources} = \@sources;
    }

    return $self->{sources};
}

sub active_source {
    my ($self, $source) = @_;

    if($source) {
        $self->{active_source} = $source;
        $self->checksum($source);
    }

    return $self->{active_source};
}

sub prologue {
    my ($self, $new_prologue) = @_;

    $self->{prologue} = $new_prologue if($new_prologue);

    return $self->{prologue};
}

sub wrapper {
    my ($self, $new_wrapper) = @_;

    $self->{wrapper} = $new_wrapper if($new_wrapper);

    return $self->{wrapper};
}


sub environment_variables {
    my ($self, $new_vars) = @_;

    $self->{environment_variables} = $new_vars if($new_vars);

    return $self->{environment_variables};
}

sub phony {
    my ($self, $new_phony) = @_;

    $self->{phony} = $new_phony if($new_phony);

    return $self->{phony};
}

sub root_dir {
    my ($self, $new) = @_;

    my $old = $self->{root_dir};

    if($new) {
        $self->{root_dir} = $new;
    }

    unless($self->{root_dir}) {
        my $rel = join('/', map { "$_" } ($self->bag->target, $self->name, $self->version->normal));

        $self->{root_dir} = File::Spec->rel2abs($vc3_root) . '/' . $rel;
    }

    if(!$old || $old ne $self->{root_dir}) {
        $self->add_widget_variable('ROOT', $self->{root_dir});
    }

    return $self->{root_dir};
}

sub bookeeping_dir {
    my ($self, $relative) = @_;

    my $rel = join('/', map { "$_" } ($self->bag->target, $self->name, $self->version->normal));

    if($relative) {
        return $rel;
    }

    return File::Spec->rel2abs($vc3_root) . '/' . $rel;
}

sub build_dir {
    my ($self) = @_;

    unless($self->{build_dir}) {
        my $root     = File::Spec->rel2abs($vc3_root) . '/builds';

        unless(-d $root) {
            File::Path::make_path($root);
        }

        my $template = $root . '/' . $self->name . '.XXXXXX';

        my $tmpdir   = File::Temp::tempdir($template, CLEANUP => 1);
        $self->{build_dir} = $tmpdir;
    }

    return $self->{build_dir};
}

sub build_log {
    my ($self) = @_;
    my $log_name = $self->bookeeping_dir . '/' . $self->name . '-build-log';

    return $log_name;
}

sub say {
    my $self = shift @_;

    return $self->bag->say(@_);
}

sub consolidate_environment_variables {
    my ($self, $expansion) = @_; 

    my $vars = $self->environment_variables
    || return;

    for my $var (reverse @{$vars}) {

        my $name = $var->{name}
        || carp "Environment variable does not have a name.";

        my $value = $var->{value}
        || carp "Environment variable '$name' did not define a value.";

        my $clobber  = $var->{clobber};
        my $absolute = $var->{absolute};

        if($expansion->{$name} && $clobber) {
            my @old_value = @{$expansion->{$name}};
            my $n = @old_value;
            if($n > 1) {
                carp("Asked to clobber variable '$name', but it already had a value.\n"
                    . "'$value' <> '" . join(',', @old_value) . "'\n");
            }
        }

        $expansion->{$name} ||= [];

        my @paths;
        if($clobber) {
            # when clobber, we use the value as is, and remove previous expansions.
            @paths = ($value);
            $expansion->{$name} = [];
        } else {
            # otherwise, split paths on :
            @paths = split /:/, $value;
        }

        my @current_expansions;
        for my $path (@paths) {
            if(!$absolute) {
                if($self->root_dir eq $self->bookeeping_dir) {
                    $path = '${' . $self->widget_var('ROOT') . '}/' . $path;
                } else {
                    $path = $self->root_dir . '/' . $path;
                }
            }

            push @current_expansions, $path;
        }

        unshift @{$expansion->{$name}}, @current_expansions;
    }
}

sub error_debug_info {
    my ($self, $eval_error) = @_;

    print "'", $self->name, "' failed to build for ", $self->bag->target, "\n";

    if($eval_error) {
        print $eval_error, "\n";
    }

    if(-f $self->build_log) {
        print "Last lines of log file:\n";
        system('tail', $self->build_log);
    }
}


sub process_error {
    my ($self, $sh_on_error, $eval_error, $status) = @_;

    if($eval_error || $status) {
        $self->error_debug_info($eval_error);

        if($sh_on_error) {
            warn $@ if $@;

            my $cwd = getcwd();

            $self->bag->shell_user();

            chdir $cwd;
        }
    }
}

sub checksum {
    my ($self, $load) = @_;

    if(!$self->{checksum}) {
        $load ||= 'no source';

        my $txt = $self->hash_to_canonical_str($load);
        my $dgt = md5_hex($txt);

        $self->{checksum} = $dgt;
    }

    return $self->{checksum};
}

sub hash_to_canonical_str {
    my ($self, $ref) = @_;

    my $str;

    if(ref($ref) eq 'HASH') {
        my @ks = sort { $a cmp $b } keys %{$ref};

        $str 
        = '{'
        . join(',', map { $_ .  ':' . $self->hash_to_canonical_str($ref->{$_}) } @ks)
        . '}';
    } elsif(ref($ref) eq 'ARRAY') {
        $str 
        = '['
        . join(',', map { $self->hash_to_canonical_str($_) } @{$ref})
        . ']';
    } else {
        $str = $ref;
    }

    return $str;
}


sub msgs_manual_requirements {
    my ($self) = @_;

    my $sources = $self->sources;

    my @restricted_unmet;
    for my $source (@{$sources}) {
        unless($source->check_manual_requirements()) {
            push @restricted_unmet, $source->msg_manual_requirement();
        }
    }

    return @restricted_unmet;
}


sub prepare_recipe_sandbox {
    my ($self, $no_erase) = @_;

    # clear build directory, to avoid bugs from uncleaned sources.
    my $build = $self->build_dir;
    if( -d $build ) {
        File::Path::rmtree($build);
    }

    # clear destination directory, to make sure we are running what we believe
    # we are running.
    unless($no_erase) {
        my $dir = $self->root_dir;
        if( -d $dir ) {
            File::Path::rmtree($dir);
        }

        if($self->root_dir ne $self->bookeeping_dir) {
            my $dir = $self->bookeeping_dir;
            if( -d $dir ) {
                File::Path::rmtree($dir);
            }
        }
    }

    # create the dirs we removed above.
    File::Path::make_path($self->build_dir);
    File::Path::make_path($self->root_dir);
    File::Path::make_path($self->bookeeping_dir);

    # make sure tmp dir exists
    File::Path::make_path($self->bag->tmp_dir);

    # set the destination directory as an environment variable before
    # setting up the shell, so that the child created inherets it.
    $self->bag->add_builder_variable('VC3_PREFIX', $self->root_dir);
    $self->bag->add_builder_variable('VC3_BUILD',  $self->build_dir);
}

sub cleanup_recipe_sandbox {
    my ($self, $result) = @_;

    $self->bag->del_builder_variable('VC3_PREFIX');
    $self->bag->del_builder_variable('VC3_BUILD');

    if($result eq '0') {
        File::Path::rmtree($self->build_dir);
        $self->ribbon->commit('DONE');
    }

    # we do not delete the buildir in case of error, to ease debugging.
}

sub setup_build_shell {
    my ($self, @log_messages) = @_;

    # log the recipe used. Since we are opening sh with -e, the recipe executes
    # as if all steps were &&-ed together.
    open(my $build_log, '>', $self->build_log);
    print { $build_log } join("\n && ", @log_messages . "\n");
    close $build_log;

    # open sh with -e. This terminates the shell at the first step that returns
    # a non-zero status.
    my ($pid, $build_in) = $self->bag->shell();

    croak 'Could not open /bin/sh for building.'
    unless $build_in;

    # redirect all output to our log file.
    print { $build_in } 'exec 1>> ' . $self->build_log . "\n";
    print { $build_in } "exec 2>&1\n";
    print { $build_in } "set -ex\n";

    # return the stdin of the shell, and the pid so we can wait for it.
    return ($pid, $build_in);
}

sub shell {
    my ($self) = @_;
    return $self->bag->shell();
}

package VC3::Ribbon;

use File::Basename; 
use LockFile::Simple qw(lock unlock);

sub new {
    my ($class, $name, $install_dir, $tmpdir, $checksum) = @_;

    my $self = bless {}, $class;

    $self->{filename} = $install_dir . '/.VC3_DEPENDENCY_BUILD';
    $self->{lockname} = $tmpdir . '/' . $name . '.lock';
    $self->{checksum} = $checksum;

    $self->{lockmgr} = LockFile::Simple->make(-hold => 3600, -autoclean => 1, -max => 99999, -delay => 5, -stale => 1, -wmin => 2,
        -wfunc => sub { LockFile::Simple::core_warn("Waiting for a lock for '$name'. If you think this lock is stale, please remove the file:\n'" . $self->{lockname} . "'\n") }
    );

    return $self;
}

sub commit {
    my ($self, $state) = @_;

    my $ribbon_fh = IO::Handle->new();
    open ($ribbon_fh, '>', $self->{filename});

    my $report = {};
    $report->{state}    = $state;
    $report->{checksum} = $self->{checksum};
    $report->{time}     = time();

    printf { $ribbon_fh } JSON::Tiny::encode_json($report);

    $ribbon_fh->flush();
    $ribbon_fh->sync();

    $ribbon_fh->close();
}

sub set_lock {
    my ($self) = @_;

    # make sure parent directory exists
    File::Path::make_path( dirname($self->{filename}) );

    $self->{lockobj} = $self->{lockmgr}->lock($self->{filename}, $self->{lockname});
}

sub release_lock {
    my ($self) = @_;
    $self->{lockobj}->release();
}

sub state {
    my ($self) = @_;

    my $name = $self->{filename};
    my $state = 'MISSING';

    if(-f $name) {
        open my $ribbon_fh, '<', $name || warn $!;

        if($ribbon_fh) {
            my $contents = do { local($/); <$ribbon_fh> };
            close($ribbon_fh);

            my $report;
            eval { $report = JSON::Tiny::decode_json($contents) };
            if($@) {
                $state = 'MISSING';
            }

            if(!$report->{state}) {
                $state = 'MISSING';
            #} elsif(!$report->{checksum}) {
            #     $state = 'MISSING';
            # } elsif($report->{checksum} ne $self->{checksum}) {
            # $state = 'OUT_OF_DATE';
            } elsif($report->{state} eq 'PROCESSING') {
                $state = 'PROCESSING';
            } else {
                $state = $report->{state};
            }
        }
    }

    return $state;
}

package VC3::Source;
use Carp;

sub new {
    my ($class, $widget, $source_raw) = @_;

    my $source;

    if($source_raw->{type} eq 'generic') {
        $source = VC3::Source::Generic->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'tarball') {
        $source = VC3::Source::Tarball->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'manual-distribution') {
        $source = VC3::Source::ManualDist->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'binary') {
        $source = VC3::Source::Binary->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'system') {
        $source = VC3::Source::System->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'cpan') {
        $source = VC3::Source::Perl->new($widget, $source_raw);
    }
    else {
        croak "Do not know about source type '" . $source_raw->{type} . "' for '" . $widget->name . "'";
    }

    return $source;
}

package VC3::Source::Generic;
use Carp;
use File::Basename;
use File::Copy;
use File::Path;
use File::Spec;
use HTTP::Tiny;
use POSIX ":sys_wait_h";
use parent;

sub new {
    my ($class, $widget, $json_description) = @_;

    my $self = bless {}, $class;

    $self->widget($widget);
    $self->recipe($json_description->{recipe});
    $self->files($json_description->{files});
    $self->msg_manual_requirement($json_description->{msg_manual_requirement});
    $self->dependencies($json_description->{dependencies});
    $self->prerequisites($json_description->{prerequisites});

    $self->{type} = $json_description->{type};

    return $self;
}

sub phony {
    my ($self) = @_;

    return 0;
}

sub widget {
    my ($self, $new_widget) = @_;

    $self->{widget} = $new_widget if($new_widget);

    croak 'No argument given'
    unless($self->{widget}); 

    return $self->{widget};
}

sub recipe {
    my ($self, $new_recipe) = @_;

    $self->{recipe} = $new_recipe if($new_recipe);

    croak 'No recipe given'
    unless($self->{recipe}); 

    return $self->{recipe};
}

sub files {
    my ($self, $new_files) = @_;

    $self->{files} = $new_files if($new_files);

    if($self->{files}) {
        return $self->{files};
    } else {
        return [];
    }
}

sub msg_manual_requirement {
    my ($self, $new_message) = @_;

    if($new_message) {
        $self->{msg_manual_requirement} = $new_message;
    }

    return $self->{msg_manual_requirement};
}

sub check_manual_requirements {
    my ($self, $new_message) = @_;

    # by default return true. Usually packages do not have manual requirements.
    return 1;
}

sub file_absolute {
    my ($self, $file) = @_;
    return File::Spec->rel2abs($vc3_distfiles . '/' . $file);
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    if($new_dependencies) {
        $self->{dependencies} = {};

        for my $name (keys %{$new_dependencies}) {
            my $versions = $new_dependencies->{$name};
            my ($min_version, $max_version) = @{$versions};

            if($min_version) {
                $min_version = version->declare($min_version);
            }

            if($max_version) {
                $max_version = version->declare($max_version);

                unless($min_version) {
                    $min_version = version->declare('v0.0.0');
                }
            }

            $self->{dependencies}{$name} = [];

            if($min_version) {
                push @{$self->{dependencies}{$name}}, $min_version;
            }

            if($max_version) {
                push @{$self->{dependencies}{$name}}, $max_version;
            }
        }
    }

    return $self->{dependencies};
}

sub prerequisites {
    my ($self, $new_prerequisites) = @_;

    $self->{prerequisites} = $new_prerequisites if($new_prerequisites);

    # by default return true. Usually packages do not have prerequisites.
    return $self->{prerequisites};
}

sub check_prerequisites {
    my ($self) = @_;

    # by default return true. Usually packages do not have prerequisites.
    unless($self->prerequisites()) {
        return 0;
    }

    my @steps = @{$self->prerequisites};

    my ($pid, $pre_in) = $self->widget->bag->shell();

    print { $pre_in } "exec 1>> /dev/null\n";
    print { $pre_in } "exec 2>&1\n";
    print { $pre_in } "set -ex\n";

    # add shifting to tmp directory as the first step.
    unshift @steps, 'cd ' . $self->widget->bag->tmp_dir;

    # add exiting cleanly from shell as a last step.
    push @steps, 'exit 0';

    for my $step (@steps) {
        print { $pre_in } "$step\n";
    }

    my $exit_status = -1;
    eval { close $pre_in; $exit_status = $? };

    if(!$@ && WIFEXITED($exit_status) && (WEXITSTATUS($exit_status) == 0)) {
        return 0;
    } else {
        return -1;
    }
}

sub say {
    my $self = shift @_;

    return $self->widget->say(@_);
}

sub get_file {
    my ($self, $file) = @_;

    unless(-f $self->file_absolute($file)) {
        $self->say("Downloading '" . $file . "' from $vc3_repository");

        #if make sure the destination directory exists
        File::Path::make_path($vc3_distfiles);

        my $ff = HTTP::Tiny->new();

        my $url    = $vc3_repository . '/' . $file;
        my $output = $vc3_distfiles  . '/' . $file;

        my $retries = 5;
        my $sleep_before_retry = 5; # seconds
        my $response;

        for my $i (1..$retries) {
            $response = $ff->mirror($url, $output);

            return if $response->{success};

            # 304 means file did not change from the last time we downloaded it
            return if $response->{status} == 304;

            # retries:
            # 408 is request timeout
            # 503 is service unavailable
            # 504 is a gatewat timeout
            # 524 is a cloudflare timeout
            # 599 is an internal exception of HTTP::Tiny, which may be a timeout too.

            if( grep { $response->{status} == $_ } (408,503,504,524,599) ) {
                print "Could not download '" . $file . "':\n" . "$response->{status}: $response->{reason}\n";
                print "$response->{content}\n" if $response->{content};
                print "Retrying @{[$retries - $i]} more time(s)\n"; 

                sleep $sleep_before_retry;

                next;
            }

            die "Could not download '" . $file . "':\n" . "$response->{status} $response->{reason}";
        }
    }
}

sub get_files {
    my ($self) = @_;

    my $files = $self->files;

    for my $file (@{$files}) {
        $self->get_file($file);
    }
}

sub prepare_files {
    my ($self, $build_dir) = @_;

    for my $file (@{$self->files}) {
        symlink($self->file_absolute($file), $build_dir . '/' . basename($file))
        || die "Could not link '" . $file . "' to build directory.\n";
    }
}


sub prepare_recipe_sandbox {
    my ($self) = @_;


    my $no_erase = $self->isa('VC3::Source::System');

    my $result = $self->widget->prepare_recipe_sandbox($no_erase);

    if($result == 0) {
        return 0;
    }

    # download to $vc3_distfiles the ingredient (i.e., input files) if missing.
    $self->get_files();

    # if generic, copy all files to build directory.
    # if tarball, expand first file to build directory, and copy the rest of
    # the files to build directory.
    $self->prepare_files($self->widget->build_dir);

    return 1;
}

sub cleanup_recipe_sandbox {
    my ($self, $result) = @_;
    return $self->widget->cleanup_recipe_sandbox($result);
}


sub execute_recipe {
    my ($self, $force_rebuild, $ignore_locks) = @_;

    my $result = 1;

    unless($ignore_locks) {
        $self->widget->ribbon->set_lock();
    }

    eval {
        my $state = $self->widget->ribbon->state;
        if($state eq 'DONE' && !$force_rebuild && !$self->widget->phony && !$self->phony) {
            $result = 0;
        } else {
            $self->say("preparing '" . $self->widget->name . "' for " . $self->widget->bag->target);
            if($self->widget->bag->dry_run) {
                $result = 0;
            } else {
                $self->prepare_recipe_sandbox();
                $result = $self->execute_recipe_unlocked();
                $self->cleanup_recipe_sandbox($result);
            }
        }
    };

    my $error_msg = $@;

    unless($ignore_locks) {
        $self->widget->ribbon->release_lock();
    }

    if($error_msg) {
        die $error_msg;
    }

    return $result;
}

sub execute_recipe_unlocked {
    my ($self) = @_;

    unless($self->isa('VC3::Source::System')) {
        $self->widget->ribbon->commit('PROCESSING');
    }

    my $result = -1;
    my ($pid, $build_in) = $self->setup_build_shell();

    my @steps = @{$self->recipe};

    # add shifting to build directory as the first step.
    unshift @steps, 'cd ' . $self->widget->build_dir;

    # add exiting cleanly from shell as a last step.
    push @steps, 'exit 0';

    $self->say("details: " .  $self->widget->build_log);

    for my $step (@steps) {
        my $date = gmtime();
        print { $build_in } ": $date\n";
        print { $build_in } "$step\n";
    }

    my $status = -1;
    eval { close $build_in; $status = $? };
    if($@) {
        carp $@;
    }

    $self->widget->{child_pid} = undef;

    if(!$@ && WIFEXITED($status) && (WEXITSTATUS($status) == 0)) {
        $result = 0;
    }

    return $result;
}

sub setup_build_shell {
    my ($self) = @_;
    return $self->widget->setup_build_shell(@{$self->recipe});
}

package VC3::Source::Tarball;
use base 'VC3::Source::Generic';
use Carp;

sub new {
    my ($class, $widget, $json_description) = @_;

    my $self = VC3::Source::Generic->new($widget, $json_description);

    unless($self->files) {
        croak "For type 'tarball', at least one file should be defined in the files list, and the first file in the list should be a tarball.";
    }

    $self = bless $self, $class;

    return $self;
}

sub prepare_files  {
    my ($self, $build_dir) = @_;

    # first file in $self->files is the tarball, by convention.
    my $tarball = @{$self->files}[0];
    $tarball = $self->file_absolute($tarball);

    system(qq/tar -C ${build_dir} --strip-components=1 -xpf ${tarball}/);
    die "Could not expand tarball $tarball.\n" if $?;

    # link in the rest of the input files.
    $self->SUPER::prepare_files($build_dir);
}

package VC3::Source::ManualDist;
use base 'VC3::Source::Generic';
use Carp;

sub get_file {
    my ($self, $file) = @_;

    unless(-f $self->file_absolute($file)) {
        die "Missing manual or restricted distribution file '$file'.\n";
    }
}

sub file_absolute {
    my ($self, $file) = @_;
    return File::Spec->rel2abs($vc3_distfiles . '/manual-distribution/'  . $file);
}

sub check_manual_requirements {
    my ($self) = @_;

    for my $file (@{$self->files}) {
        unless(-f $self->file_absolute($file)) {
            # check failed, return false
            return 0;
        }
    }

    return 1;
}

package VC3::Source::System;
use base 'VC3::Source::Generic';
use Carp;

sub phony {
    my ($self) = @_;

    return 1;
}

sub execute_recipe_unlocked {
    my ($self) = @_;

    my $output_filename = $self->widget->build_log;

    my $result;
    eval { $result = $self->SUPER::execute_recipe_unlocked(); };

    if($@) {
        die $@;
    } else {
        open(my $f, '<', $output_filename) || die 'Did not produce root directory file';
        my $root;
        while( my $line = <$f>) {
            if($line =~ m/^VC3_ROOT_SYSTEM:\s+(?<root>.*)$/) {
                $root = $+{root};
                chomp($root);
                # update root from widget with the new information:
                $self->widget->root_dir($root);
                last;
            }
        }
        close $f;
        if(!$root) {
            die 'Did not produce root directory information.';
        }
        $root = '' if $root eq '/';
    }

    return $result;
}

package VC3::Source::Binary;
use base 'VC3::Source::Generic';
use Carp;
# Right now, do the same as generic.


package VC3::Source::Perl;
use base 'VC3::Source::Generic';
use Carp;

sub new {
    my ($class, $widget, $json_description) = @_;

    unless($json_description->{recipe}) {
        my @steps;
        push @steps, "cpanm --notest --mirror \${VC3_MODULES_PERL_LOCAL_CPAN}/perl --mirror-only " . $json_description->{files}->[0];
        $json_description->{recipe} = \@steps;
    }

    my $self = VC3::Source::Generic->new($widget, $json_description);

    unless($self->files) {
        croak "For type 'perl', at least one file should be defined in the files list.";
    }

    unless($self->dependencies) {
        $self->dependencies({});
    }

    $self->{dependencies}{'perl-cpanminus'} ||= [];


    $self = bless $self, $class;

    return $self;
}

sub prepare_files  {
    my ($self, $build_dir) = @_;

    # do nothing
    return;
}

sub get_file {
    my ($self) = @_;

    # do nothing
    return;
}

package VC3::Plan;
use JSON::Tiny;

sub new {
    my ($class, $bag, $parent) = @_;

    my $self = bless {}, $class;

    $self->bag($bag);

    $self->elements($parent && $parent->elements || {});

    return $self;
}

sub bag {
    my ($self, $new) = @_;

    if($new) {
        $self->{bag} = $new;
    }

    return $self->{bag};
}

sub say {
    my ($self, @rest) = @_;

    return $self->bag->say(@rest);
}

sub elements {
    my ($self, $new) = @_;

    if($new) {
        $self->{elements} = \%{ $new };
    }

    return $self->{elements};
}

sub element_of {
    my ($self, $name) = @_;

    return $self->elements->{$name};
}

sub requirements {
    my ($self) = @_;

    unless($self->{requirements}) {
        $self->{requirements} = [];
    }

    return $self->{requirements};
}

sub add_target {
    my ($self, $name, $min, $max) = @_;

    $self->bag->{indent_level}++;

    $self->say("Plan:    $name => [@{[$min || '']}, @{[$max || '']}]");

    my $available = $self->bag->widgets_of($name);
    for my $widget (@{$available}) {

        if($self->add_widget($widget, $min, $max)) {
            $self->bag->{indent_level}--;
            return 1;
        }
    }

    $self->say("Failure: $name => [@{[$min || '']}, @{[$max || '']}]");
    $self->bag->{indent_level}--;

    return 0;
}

sub add_main_targets {
    my ($self, @requires) = @_;

    my $root_entry = { version => 'v0.0.1', phony => 1, dependencies => {} };

    for my $req (@requires) {
        my ($name, $min, $max) = $self->parse_requirement($req);

        my $versions = [];
        push @{$versions}, $min if($min);
        push @{$versions}, $max if($max);

        $root_entry->{dependencies}{$name} = $versions;
        
        unless($self->add_target($name)) {
            die "Could not find plan for $req.\n";
        }

        push @{$self->requirements}, $name;
    }

    return 1;
}

sub parse_requirement {
    my ($self, $req) = @_;

    $req =~ m/
    ^
    (?<name> [A-z0-9_-]+)
    (:                      # start of min version
    (?<min> [^:]*)
    (:                      # start of max version
    (?<max> [^:]*)
    )?)?
    $
    /x;

    my ($name, $min, $max) = ($+{name}, $+{min}, $+{max});

    if(!$min && $max) {
        $min = 'v0.0.0';
    }

    # turn into version strings
    $min = version->declare($min) if($min);
    $max = version->declare($max) if($max);

    return ($name, $min, $max);
}

sub version_str {
    my ($self, $v) = @_;

    return ''         unless $v;
    return $v->normal if $v->isa('version');
    return version->parse($v)->normal;
}

sub add_widget {
    my ($self, $widget, $min, $max) = @_;

    my $version = $widget->version;

    $self->say("Try:     " . $widget->name . " => @{[$version->normal]}");

    if($min && $min gt $version || $max && $max lt $version) {
        $self->say("Incorrect version: @{[$version->normal]} => [@{[$self->version_str($min)]},@{[$self->version_str($max)]}]");
        return 0;
    }

    my $saved_state = $self->elements();

    my $p = $self->elements->{$widget->name};
    my $e = $self->refine($widget, $p, $min, $max);

    my $success;
    if($p && !$e) {
        $self->say("conflicting versions: @{[$widget->name]} [@{[$p->{min}->normal || '']}, @{[$p->{max}->normal || '']}] <=> [@{[$min->normal || '']}, @{[$max->normal || '']}]");
        $success = 0;
    } elsif($p && $e) {
        # already in plan, simple refinenment of versions
        $success = 1;
    } elsif(!$e) {
        $success = 0;
        die('bug, this should not happen.');
    } else {

        if($self->add_dependencies($widget->dependencies)) {
            if($widget->sources) {
                my $s = $self->add_sources($widget->sources);
                if($s) {
                    $widget->active_source($s);
                    $success = 1;
                } else {
                    $self->say("could not add any source for: @{[$widget->name, $version]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
                    $success = 0;
                }
            } else {
                $success = 1;
            }
        } else {
            $self->say("could not set dependencies for: @{[$widget->name]} $version->normal => [@{[$min->normal || '']}, @{[$max->normal || '']}]");
            $success = 0;
        }
    }

    if($success) {
        # add new step to plan
        $self->elements->{$widget->name} = $e;
        $self->say("Success: @{[$widget->name]} @{[$e->widget->version->normal]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
    } else {
        # restore old plan on error
        $self->elements($saved_state);
    }

    return $success;
}

sub add_dependencies {
    my ($self, $dependencies) = @_;

    my $saved_state = $self->elements();

    my $success = 1;
    for my $name (keys %{$dependencies}) {

        my ($min, $max) = @{$dependencies->{$name}};
        unless($self->add_target($name, $min, $max)) {
            $success = 0;
            last;
        }
    }

    unless($success) {
        $self->elements($saved_state);
    }

    return $success;
}

sub add_sources {
    my ($self, $sources) = @_;

    my $saved_state = $self->elements();
    for my $s (@{$sources}) {

        if($self->bag->{no_system} && $s->isa('VC3::Source::System')) {
            next if $self->bag->{no_system}{ALL};
            next if $self->bag->{no_system}{$s->widget->name};
        }

        if($self->add_source($s)) {
            return $s;
        }
        $self->elements($saved_state);
    }

    return undef;
}


sub add_source {
    my ($self, $source) = @_;

    my $exit_status = -1;
    eval { $exit_status = $source->check_prerequisites() };
    if($exit_status) {
        $self->say("Fail-prereq: " . $source->widget->name . '-' . $source->widget->version->normal);
        return 0;
    }

    return $self->add_dependencies($source->dependencies);
}

sub refine {
    my ($self, $widget, $p, $min, $max) = @_;

    if($p) {
        return $p->refine($min, $max);
    } else {
        VC3::Plan::Element->new($widget, $min, $max, undef);
    }
}

sub order {
    my ($self) = @_;

    my $ordinal_of = {};

    my @names = keys %{$self->elements};

    for my $name (@names) {
        $ordinal_of->{$name} = 1;
    }

    my $to_go = @names;

    while($to_go >= 0) {
        my $change = 0;

        $to_go--;

        for my $name (@names) {
            my $e = $self->elements->{$name};
            my $o = $ordinal_of->{$name};

            my @deps;

            my $w = $e->{widget};

            if($w->dependencies) {
                push @deps, keys %{$w->dependencies};
            }

            if($w->active_source && $w->active_source->dependencies) {
                push @deps, keys %{$w->active_source->dependencies};
            }

            my $max = $o;
            if(@deps) {
                $max = 1 + List::Util::max( @{$ordinal_of}{@deps} );
            }

            if($max != $o) {
                $change = 1;
                $ordinal_of->{$w->name} = $max;
            }
        }

        if(!$change) {
            return $ordinal_of;
        }
    }

    die 'Circular dependency found';
}

sub dot_graph {
    my ($self, $dotname) = @_;
    my @names = keys %{$self->elements};

    open(my $dot_f, '>', $dotname) 
    || die "Could not open '$dotname': $!";

    print { $dot_f } "digraph {\n";

    print { $dot_f } "node [shape=record];\n";

    for my $name (@names) {
        my $e = $self->elements->{$name};
        my $w = $e->{widget};
        my $v = $w->version->normal;

        my $n = $name;
        $n =~ s/[^A-z0-9]//g;

        print { $dot_f } qq($n [label="$name&#92;n$v"];\n);
    }

    for my $name (@names) {
        my @deps;

        my $e = $self->elements->{$name};
        my $w = $e->{widget};

        if($w->dependencies) {
            push @deps, keys %{$w->dependencies};
        }

        if($w->active_source && $w->active_source->dependencies) {
            push @deps, keys %{$w->active_source->dependencies};
        }

        my $n = $name;
        $n =~ s/[^A-z0-9]//g;

        if(@deps) {
            for my $dep (@deps) {
                my $d = $dep;
                $d =~ s/[^A-z0-9]//g;

                print { $dot_f } qq(\t"$d"->"$n";\n);
            }
        }
    }

    print { $dot_f } "}\n";
    close $dot_f;
}

sub to_makeflow {
    my ($self, $dir, $dag_name, $builder_exec, $local_database, $cores) = @_;

    $self->to_file("$dir/$local_database");

    my $makeflow_name = 'dag';

    open(my $mflow_f, '>', "$dir/$makeflow_name") 
    || die "Could not open '$dir/$makeflow_name': $!";

    print { $mflow_f } ".MAKEFLOW CATEGORY builds\n";
    print { $mflow_f } ".MAKEFLOW CORES    $cores\n";
    print { $mflow_f } ".MAKEFLOW MEMORY   @{[$cores * 512]}\n";
    print { $mflow_f } ".MAKEFLOW DISK     20000\n";    # 20 GB of disk
    print { $mflow_f } "\n\n";

    my $bag    = $self->bag;
    my $root   = $bag->root_dir;
    my $target = $bag->root_dir . '/' . $bag->target;

    my $home   = $bag->home_dir;
    $home      =~ s/^\Q$root/\$(ROOT_DIR)/;

    print { $mflow_f } "RECIPES  = $local_database\n";
    print { $mflow_f } "ROOT_DIR = $root\n";
    print { $mflow_f } "TRGT_DIR = \$(ROOT_DIR)/@{[$bag->target]}\n";
    print { $mflow_f } "HOME_DIR = $home\n";
    print { $mflow_f } "DIST_DIR = $vc3_distfiles\n";
    print { $mflow_f } "REPO     = $vc3_repository\n";
    print { $mflow_f } "OPTIONS  = --make-jobs \$(CORES) --no-sys=ALL --no-run\n\n";

    print { $mflow_f } "RIBBON   = .VC3_DEPENDENCY_BUILD\n\n";

    print { $mflow_f } "\n";
    print { $mflow_f } "BUILD_COMMAND  = ./$builder_exec --database \$(RECIPES) --install \$(ROOT_DIR) --home \$(HOME_DIR) --distfiles \$(DIST_DIR) --repository \$(REPO) \$(OPTIONS) --ignore-locks\n";

    print { $mflow_f } "\n\n";
    
    my @names = keys %{$self->elements};
    for my $name (@names) {
        my @deps;

        my $e = $self->elements->{$name};
        my $w = $e->{widget};

        if($w->dependencies) {
            push @deps, keys %{$w->dependencies};
        }

        if($w->active_source && $w->active_source->dependencies) {
            push @deps, keys %{$w->active_source->dependencies};
        }

        my @inputs;
        for my $d (@deps) {
            my $rname = $self->elements->{$d}->{widget}->ribbon->{filename};

            $rname =~ s/.VC3_DEPENDENCY_BUILD$/\$(RIBBON)/;
            $rname =~ s/^\Q$target/\$(TRGT_DIR)/;

            push @inputs, $rname;
        }

        my $output = $w->ribbon->{filename};
        $output =~ s/.VC3_DEPENDENCY_BUILD$/\$(RIBBON)/;
        $output =~ s/^\Q$target/\$(TRGT_DIR)/;

        print { $mflow_f } "$output: $builder_exec $local_database @inputs\n";

        print { $mflow_f } "\t";

        if($w->phony || ($w->active_source && $w->active_source->phony)) {
            print { $mflow_f } "LOCAL "
        }

        print { $mflow_f } "\t\$(BUILD_COMMAND) --require $name\n\n";
    }

    close $mflow_f;
}

sub prestage {
    my ($self) = @_;

    for my $e (values %{$self->elements}) {
        my $s = $e->widget->active_source;
        next unless $s;

        $s->get_files();
    }
}

sub to_file {
    my ($self, $filename) = @_;

    my $output = {};

    for my $e (values %{$self->elements}) {
        my $n = {};
        my $w = $e->widget;
        $n->{version} = $w->version->normal;

        if($w->dependencies) {
            $n->{dependencies} = $w->dependencies;
        }

        if($w->wrapper) {
            $n->{wrapper} = $w->wrapper;
        }

        if($w->prologue) {
            $n->{prologue} = $w->prologue;
        }

        if($w->environment_variables) {
            $n->{environment_variables} = $w->environment_variables;
        }

        if($w->phony) {
            $n->{phony} = $w->phony;
        }

        if($w->active_source) {
            my $s = $w->active_source;
            my $m = {};

            $m->{type} = $s->{type};

            if($s->recipe) {
                $m->{recipe} = $s->recipe;
            }

            if($s->files) {
                $m->{files} = $s->files;
            }

            if($s->msg_manual_requirement) {
                $m->{msg_manual_requirement} = $s->msg_manual_requirement;
            }

            if($s->dependencies) {
                $m->{dependencies} = $s->dependencies;
            }

            if($s->prerequisites) {
                $m->{prerequisites} = $s->prerequisites;
            }

            $n->{sources} = [ $m ];
        }

        $output->{$w->name} = [ $n ];
    }

    open my $f_h, '>', $filename || die "Could not open $filename for writting: $!\n";

    my $json = JSON::Tiny::encode_json($output);

    print { $f_h } $json, "\n";

    close $f_h;
}

package VC3::Plan::Element;

sub new {
    my ($class, $widget, $min, $max, $source) = @_;

    my $self = bless {}, $class;

    if($min && $max && $min gt $max) {
        die 'Incompatible versions';
    }

    $self->{widget} = $widget;
    $self->{min}    = $min;
    $self->{max}    = $max;

    return $self;
}

sub widget {
    my ($self, $new) = @_;

    if($new) {
        $self->{widget} = $new;;
    }

    return $self->{widget};
}

sub min {
    my ($self, $new) = @_;

    if($new) {
        $self->{min} = $new;
    }

    return $self->{min};
}

sub max {
    my ($self, $new) = @_;

    if($new) {
        $self->{max} = $new;
    }

    return $self->{max};
}

sub refine {
    my ($self, $new_min, $new_max) = @_;

    if($new_min && $self->{max} && $new_min gt $self->{max}) {
        return undef;
    }

    if($new_max && $self->{min} && $new_max lt $self->{min}) {
        return undef;
    }

    my $min = $new_min || $self->{min};
    if($new_min && $self->{min}) {
        $min = $new_min lt $self->{min} ? $new_min : $self->{min};
    }

    my $max = $new_max || $self->{max};
    if($new_max && $self->{max}) {
        $max = $new_max lt $self->{max} ? $new_max : $self->{max};
    }

    if($min && $min gt $self->{widget}->version) { 
        return undef;
    }

    if($max) {
        my $v   = version->declare($max);
        my $num = $v->numify();
        my $fix = ($num * 1000000) % 1000;
        $num   += 0.000999 unless($fix);
        $v      = version->parse($num);
        
        if($v lt $self->{widget}->version) { 
            return undef;
        }
    }

    return VC3::Plan::Element->new($self->{widget}, $min, $max);
}

package version;
sub TO_JSON {
    my ($self) = @_;
    return $self->normal;
}


package VC3::Builder;
__DATA__
{
    "vc3-wq-factory":[
        {
            "version":"v0.000.001",
            "phony":1,
            "dependencies":{
                "cctools-statics":[
                    "v0.000.001"
                ],
                "vc3-factory":[
                    "v0.000.001"
                ]
            }
        },
        {
            "version":"v0.000.001",
            "phony":1,
            "version":"v6.000.016",
            "dependencies":{
                "cctools":[
                    "v6.000.016"
                ],
                "vc3-factory":[
                    "v0.000.001"
                ]
            }
        }
    ],

    "vc3-factory":[
        {
            "version":"v0.000.001",
            "phony":1,
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${HOME}/git && cd ${HOME}/git",
                        "[ -d autopyfactory ] || git clone https://github.com/btovar/autopyfactory.git",
                        "cd autopyfactory",
                        "rm -rf build",
                        "python setup.py install --home=${VC3_SERVICES_HOME}/apf"
                    ]
                }
            ],
            "dependencies":{
                "vc3-services-common-requirements":[
                    "v0.000.001"
                ],
                "vc3-info-service":[
                    "v0.000.001"
                ],
                "condor":[
                    "v8.006.000"
                ]
            },
            "environment_variables":[
                {
                    "name":"APF_HOME",
                    "value":"${VC3_SERVICES_HOME}/apf",
                    "absolute":1,
                    "clobber":1
                },
                {
                    "name":"PYTHONPATH",
                    "value":"${APF_HOME}/lib/python",
                    "absolute":1
                },
                {
                    "name":"PATH",
                    "value":"${APF_HOME}/bin",
                    "absolute":1
                }
            ]
        }
    ],

    "vc3-services":[
        {
            "version":"v0.000.001",
            "phony":1,
            "dependencies":{
                "vc3-builder":[
                    "v0.000.001"
                ],
                "vc3-pluginmanager":[
                    "v0.000.001"
                ],
                "vc3-certificates":[
                    "v0.000.001"
                ],
                "vc3-info-service":[
                    "v0.000.001"
                ],
                "vc3-wrappers":[
                    "v0.000.001"
                ],
                "vc3-core":[
                    "v0.000.001"
                ],
                "vc3-master":[
                    "v0.000.001"
                ],
                "vc3-wq-factory":[
                    "v0.000.001"
                ]
            }
        }
    ],

    "vc3-services-common-requirements":[
        {
            "version":"v0.000.001",
            "phony":1,
            "dependencies":{
                "python":[
                    "v2.007.012"
                ],
                "git":[
                    "v2.012.000"
                ]
            },
            "environment_variables":[
                {
                    "name":"VC3_SERVICES_HOME",
                    "value":"${HOME}/vc3-services",
                    "absolute":1,
                    "clobber":1
                },
                {
                    "name":"PATH",
                    "value":"${VC3_SERVICES_HOME}/bin",
                    "absolute":1
                },
                {
                    "name":"PYTHONPATH",
                    "value":"${VC3_SERVICES_HOME}/lib/python",
                    "absolute":1
                }
            ]
        }
    ],

    "vc3-dev":[
        {
            "version":"v0.000.001",
            "dependencies":{
                "vc3-services":[
                    "v0.000.001"
                ],
                "perl":[
                    "v2.024.000"
                ]
            }
        }
    ],

    "vc3-builder":[
        {
            "version":"v0.001",
            "phony":1,
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${VC3_SERVICES_HOME}/bin",
                        "name=$(basename $VC3_BUILDER_PATH)",
                        "cmp $VC3_BUILDER_PATH ${VC3_SERVICES_HOME}/bin/$name || cp $VC3_BUILDER_PATH ${VC3_SERVICES_HOME}/bin"
                    ]
                }
            ],
            "dependencies":{
                "vc3-services-common-requirements":[
                    "v0.000.001"
                ]
            }
        }
    ],

    "vc3-master":[
        {
            "version":"v0.001",
            "phony":1,
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${HOME}/git && cd ${HOME}/git",
                        "[ -d vc3-master ] || git clone https://github.com/vc3-project/vc3-master.git",
                        "cd vc3-master",
                        "rm -rf build",
                        "python setup.py install --home=${VC3_SERVICES_HOME}"
                    ]
                }
            ],
            "dependencies":{
                "vc3-core":[
                    "v0.000.001"
                ]
            }
        }
    ],

    "vc3-core":[
        {
            "version":"v0.001",
            "phony":1,
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${HOME}/git && cd ${HOME}/git",
                        "[ -d vc3-core ] || git clone https://github.com/vc3-project/vc3-core.git",
                        "cd vc3-core",
                        "rm -rf build",
                        "python setup.py install --home=${VC3_SERVICES_HOME}"
                    ]
                }
            ],
            "dependencies":{
                "vc3-pluginmanager":[
                    "v0.000.001"
                ],
                "vc3-info-service":[
                    "v0.000.001"
                ],
                "vc3-wrappers":[
                    "v0.000.001"
                ]
            }
        }
    ],

    "vc3-test-service":[
        {
            "version":"v0.001",
            "phony":1,
            "dependencies":{
                "vc3-wrappers":[
                    "v0.000.001"
                ]
            }
        }
    ],

    "vc3-wrappers":[
        {
            "version":"v0.001",
            "phony":1,
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${HOME}/git && cd ${HOME}/git",
                        "[ -d vc3-wrappers ] || git clone https://github.com/vc3-project/vc3-wrappers.git",
                        "cd vc3-wrappers",
                        "rm -rf build",
                        "python setup.py install --home=${VC3_SERVICES_HOME}"
                    ]
                }
            ],
            "dependencies":{
                "vc3-info-service":[
                    "v0.000.001"
                ]
            }
        }
    ],

    "vc3-info-service":[
        {
            "version":"v0.001",
            "phony":1,
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "if vc3-info-client --get 'hello-server'; then",
                        "   echo 'Server already installed and running'",
                        "   exit 0",
                        "fi",
                        "mkdir -p ${HOME}/git && cd ${HOME}/git",
                        "[ -d vc3-info-service ] || git clone https://github.com/vc3-project/vc3-info-service.git",
                        "cd vc3-info-service",
                        "rm -rf build",
                        "python setup.py install --home=${VC3_SERVICES_HOME}",
                        "ln -sf ${VC3_SERVICES_HOME}/lib/python/vc3/infoclient.py ${VC3_SERVICES_HOME}/lib/python"

                    ]
                }
            ],
            "dependencies":{
                "vc3-pluginmanager":[
                    "v0.000.001"
                ],
                "vc3-certificates":[
                    "v0.000.001"
                ],
                "python-cherrypy":[
                    "v3.002.002"
                ],
                "python-requests":[
                    "v2.007.000"
                ]
            },
            "environment_variables":[
                {
                    "name":"VC3_SERVICES_INFOSERVICE_INFOHOST",
                    "value":"localhost",
                    "absolute":1,
                    "clobber":1
                },
                {
                    "name":"VC3_SERVICES_INFOSERVICE_HTTP_PORT",
                    "value":"20333",
                    "absolute":1,
                    "clobber":1
                },
                {
                    "name":"VC3_SERVICES_INFOSERVICE_HTTPS_PORT",
                    "value":"20334",
                    "absolute":1,
                    "clobber":1
                }
            ]
        }
    ],

    "vc3-certificates":[
        {
            "version":"v0.001",
            "phony":1,
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${HOME}/git && cd ${HOME}/git",
                        "[ -d credible ] || git clone https://github.com/vc3-project/credible.git",
                        "cd ${HOME}/git/credible",
                        "rm -rf build",
                        "python setup.py install --home=${VC3_SERVICES_HOME}",
                        "credroot=${HOME}/var/credible/ssca/defaultca/intermediate",
                        "srvroot=${HOME}/vc3-services/etc/certs",
                        "missing=0",
                        "[ -f $svroot/localhost.cert.pem ]            || missing=1",
                        "[ -f $svroot/ca-chain.cert.pem ]             || missing=1",
                        "[ -f $svroot/certs/VC3Admin.cert.pem ]             || missing=1",
                        "[ -f $svroot/private/localhost.keynopw.pem ] || missing=1",
                        "[ -f $svroot/private/VC3Admin.keynopw.pem ]  || missing=1",
                        "if [ \"$missing\" = 1 ]; then",
                        "   exe=\"python ${HOME}/vc3-services/lib/python/credible/credible.py\"",
                        "   $exe -c ${HOME}/git/credible/etc/credible.conf hostcert localhost",
                        "   $exe -c ${HOME}/git/credible/etc/credible.conf certchain",
                        "   $exe -c ${HOME}/git/credible/etc/credible.conf usercert VC3Admin",
                        "   mkdir -p $srvroot/private",
                        "   cp -f $credroot/certs/localhost.cert.pem $srvroot",
                        "   cp -f $credroot/certs/ca-chain.cert.pem  $srvroot",
                        "   cp -f $credroot/certs/VC3Admin.cert.pem  $srvroot",
                        "   cp -f $credroot/private/localhost.keynopw.pem $srvroot/private",
                        "   cp -f $credroot/private/VC3Admin.keynopw.pem $srvroot/private",
                        "   ~/vc3-services/bin/credible ~/git/credible/etc/credible.conf -d hostcert localhost > /dev/null",
                        "   ~/vc3-services/bin/credible ~/git/credible/etc/credible.conf -d usercert VC3Admin > /dev/null",

                        "fi"
                    ]
                }
            ],
            "dependencies":{
                "vc3-services-common-requirements":[
                    "v0.000.001"
                ]
            },
            "environment_variables":[
                {
                    "name":"VC3_SERVICES_CERTS_HOME",
                    "value":"${VC3_SERVICES_HOME}/etc/ssca/certs",
                    "absolute":1,
                    "clobber":1
                },
                {
                    "name":"VC3_SERVICES_CERTS_CHAINFILE",
                    "value":"${VC3_SERVICES_CERTS_HOME}/ca-chain.cert.pem",
                    "absolute":1,
                    "clobber":1
                },
                {
                    "name":"VC3_SERVICES_CERTS_CERTFILE",
                    "value":"${VC3_SERVICES_CERTS_HOME}/VC3Admin.cert.pem",
                    "absolute":1,
                    "clobber":1
                },
                {
                    "name":"VC3_SERVICES_CERTS_KEYFILE",
                    "value":"${VC3_SERVICES_CERTS_HOME}/private/VC3Admin.keynopw.pem",
                    "absolute":1,
                    "clobber":1
                }
            ]
        }
    ],

    "vc3-pluginmanager":[
        {
            "version":"v0.001",
            "phony":1,
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${HOME}/git && cd $HOME/git",
                        "[ -d plugin-manager ] || git clone https://github.com/bnl-sdcc/plugin-manager.git",
                        "cd ${HOME}/git/plugin-manager",
                        "rm -rf build",
                        "python setup.py install --home=${VC3_SERVICES_HOME}"
                    ]
                }
            ],
            "dependencies":{
                "vc3-services-common-requirements":[
                    "v0.000.001"
                ],
                "python-cherrypy":[
                    "v3.002.002"
                ],
                "python-requests":[
                    "v2.007.000"
                ]
            }
        }
    ],

    "icecube-argonne-demo":[
        {
            "version":"v1.000",
            "phony":1,
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "icecube-argonne-demo-01.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${HOME}/icecube-argonne-demo-01",
                        "tar -C ${HOME}/icecube-argonne-demo-01 --strip-components=1 -xpf icecube-argonne-demo-01.tar.gz"
                    ]
                }
            ],
            "dependencies":{
                "icecube-environment":[
                    "v1.000"
                ],
                "python":[
                    "v2.006"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"${HOME}/icecube-argonne-demo-01",
                    "absolute":1
                }
            ]
        }
    ],

    "icecube-environment":[
        {
            "version":"v1.000",
            "phony":1,
            "prologue": [
                "eval $(/cvmfs/icecube.opensciencegrid.org/py2-v1/setup.sh)"
            ],
            "dependencies":{
                "cvmfs":[
                    "v2.000"
                ],
                "python":[
                    "v2.006"
                ]
            }
        }
    ],

    "htcondor-glidein-wrapper":[
        {
            "version":"v1.000",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "htcondor-glidein-wrapper"
                    ],
                    "recipe":[
                        "chmod 755 htcondor-glidein-wrapper",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "cp htcondor-glidein-wrapper ${VC3_PREFIX}/bin"
                    ],
                    "dependencies":{
                        "python":[
                            "v2.006"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "cvmfs":[
        {
            "version":"v2.000",
            "phony":1,
            "sources":[
                {
                    "type":"system",
                    "prerequisites":[
                        "stat /cvmfs/cms.cern.ch"
                    ],
                    "recipe":[
                        "echo /cvmfs"
                    ]
                },
                {
                    "type":"generic",
                    "recipe":[
                        "stat /cvmfs/cms.cern.ch"
                    ],
                    "dependencies":{
                        "parrot":[
                            "v6.000.016"
                        ]
                    }
                }
            ]
        }
    ],

    "parrot":[
        {
            "version":"v6.000.016",
            "versioncmd":"parrot_run --version",
            "versionreg":"^parrot_run version ([0-9.]*)",
            "phony":1,
            "wrapper":"parrot_run --dynamic-mounts -p ${PARROT_HTTP_PROXY} --cvmfs-repo-switching -- {}",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "parrot_run --dynamic-mounts -p ${PARROT_HTTP_PROXY} --cvmfs-repo-switching -M /hello-parrot=/bin -- /bin/ls /hello-parrot"
                    ],
                    "dependencies":{
                        "cctools":[
                            "v6.000.016"
                        ]
                    }
                }
            ]
        }
    ],

    "cctools-catalog-server":[
        {
            "version":"v6.000.016",
            "dependencies":{
                "cctools-statics":[
                    "v0.000.001"
                ]
            }
        },
        {
            "version":"v6.000.016",
            "dependencies":{
                "cctools":[
                    "v6.000.016"
                ]
            }
        }
    ],

    "cctools-statics":[
        {
            "version":"v6.000.016",
            "sources":[
                {
                    "type":"binary",
                    "files":[
                        "cctools-statics-6.0.16-x86_64.tar.gz"
                    ],
                    "prerequisites":[
                        "[ ${VC3_MACHINE_ARCH} = \"x86_64\" ] || exit 1"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-statics-6.0.16-x86_64.tar.gz"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "cctools":[
        {
            "version":"v6.000.016",
            "versioncmd":"parrot_run --version",
            "versionreg":"^parrot_run version ([0-9.]*)",
            "sources":[
                {
                    "type":"binary",
                    "files":[
                        "cctools-6.0.16-x86_64-redhat7.tar.gz"
                    ],
                    "prerequisites":[
                        "[ ${VC3_MACHINE_TARGET} = \"x86_64/redhat7\" ] || exit 1"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-6.0.16-x86_64-redhat7.tar.gz"
                    ],
                    "dependencies":{
                        "perl":[
                            "v5.016.000", "v5.016.003"
                        ],
                        "python":[
                            "v2.007.000", "v2.007.012"
                        ]
                    }
                },
                {
                    "type":"binary",
                    "files":[
                        "cctools-6.0.16-x86_64-redhat6.tar.gz"
                    ],
                    "prerequisites":[
                        "[ ${VC3_MACHINE_TARGET} = \"x86_64/redhat6\" ] || exit 1"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-6.0.16-x86_64-redhat6.tar.gz"
                    ],
                    "dependencies":{
                        "perl":[
                            "v5.010.000", "v5.010.001"
                        ],
                        "python":[
                            "v2.006.000", "v2.006.009"
                        ]
                    }
                },
                {
                    "type":"tarball",
                    "files":[
                        "cctools-6.0.16-source.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix ${VC3_PREFIX} --with-swig-path ${VC3_ROOT_SWIG} --with-python-path ${VC3_ROOT_PYTHON} --with-perl-path ${VC3_ROOT_PERL} --with-zlib-path ${VC3_ROOT_ZLIB} --with-cvmfs-path ${VC3_ROOT_LIBCVMFS} --with-uuid-path ${VC3_ROOT_UUID} --without-system-umbrella  --with-openssl-path ${VC3_ROOT_OPENSSL} --with-fuse-path ${VC3_ROOT_FUSE}",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "swig":[
                            "v3.000"
                        ],
                        "python":[
                            "v2.006"
                        ],
                        "perl":[
                            "v5.010"
                        ],
                        "libcvmfs":[
                            "v2.002"
                        ],
                        "fuse":[
                            "v2.009"
                        ],
                        "openssl":[
                            "v1.000"
                        ],
                        "uuid":[
                            "v1.000"
                        ]
                    }
                }
            ],
            "dependencies":{
                "zlib":[
                    "v1.002"
                ]
            },
            "environment_variables":[
                {
                    "name":"PARROT_HTTP_PROXY",
                    "value":"http://cache01.hep.wisc.edu:3128",
                    "clobber":1,
                    "absolute":1
                },
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"PYTHONPATH",
                    "value":"lib/python${VC3_VERSION_PYTHON}/site-packages"
                },
                {
                    "name":"PERL5LIB",
                    "value":"lib/perl5/site_perl"
                }
            ]
        }
    ],

    "swig":[
        {
            "version":"v3.000.002",
            "versioncmd":"swig -version",
            "versionreg":"SWIG Version ([0-9.]*)",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "swig-3.0.2.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "python":[
                            "v2.006"
                        ],
                        "perl":[
                            "v5.008"
                        ],
                        "pcre":[
                            "v8.034"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "gcc":[
        {
            "version":"v4.006.001",
            "sources":[
                {
                    "type":"binary",
                    "files":[
                        "gcc-4.6.1-2.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=2 -xpf gcc-4.6.1-2.tar.gz"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "patch":[
        {
            "version":"v2.007.005",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "patch-2.7.5.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX}",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "cmake":[
        {
            "version":"v3.005.002",
            "versioncmd":"cmake --version",
            "versionreg":"cmake version ([0-9.]*)",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "cmake-3.5.2.tar.gz"
                    ],
                    "recipe":[
                        "./bootstrap --prefix=${VC3_PREFIX}",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "libcvmfs":[
        {
            "version":"v2.003",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "cvmfs-0941e442.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p build",
                        "cd build",
                        ": set NO_INTERNET to stop parcparser tests",
                        "export NO_INTERNET=1",
                        "cmake -Wno-dev -DINSTALL_MOUNT_SCRIPTS=OFF -DBUILD_SERVER:BOOL=OFF -DBUILD_CVMFS:BOOL=OFF -DBUILD_LIBCVMFS:BOOL=ON -DINSTALL_BASH_COMPLETION:BOOL=OFF -DUUID_LIBRARY=${VC3_ROOT_UUID}/lib/libuuid.a -DUUID_INCLUDE_DIR:PATH=${VC3_ROOT_UUID}/include -DOPENSSL_ROOT_DIR:PATH=${VC3_ROOT_OPENSSL} -DOPENSSL_INCLUDE_DIR:PATH=${VC3_ROOT_OPENSSL}/include -DOPENSSL_LIBRARIES:PATH=${VC3_ROOT_OPENSSL}/lib -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} ..",
                        "make libpacparser",
                        "cd cvmfs",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "uuid":[
                            "v1.000"
                        ],
                        "fuse":[
                            "v2.009"
                        ],
                        "cmake":[
                            "v3.001"
                        ],
                        "patch":[
                            "v2.000"
                        ],
                        "attr":[
                            "v2.004"
                        ],
                        "openssl":[
                            "v1.000"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib64"
                }
            ]
        }
    ],

    "uuid":[
        {
            "version":"v1.000.003",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "libuuid-1.0.3.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --enable-shared",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "openssl":[
        {
            "version":"v1.000.002",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "openssl-1.0.2h.tar.gz"
                    ],
                    "recipe":[
                        "./config shared -fPIC --prefix=${VC3_PREFIX} --libdir=lib zlib-dynamic -Wl,-rpath=${VC3_PREFIX}/lib",
                        ": ./config -fPIC --prefix=${VC3_PREFIX} --libdir=lib zlib-dynamic",
                        "make depend",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "zlib":[
                    "v1.002"
                ]
            },
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                }
            ]
        }
    ],

    "libssh2":[
        {
            "version":"v1.008.000",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "libssh2-1.8.0.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --with-libssl-prefix=${VC3_ROOT_OPENSSL} --enable-static=yes --enable-shared=yes",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "openssl":[
                    "v1.000.002"
                ]
            },
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                }
            ]
        }
    ],

    "gss":[
        {
            "version":"v1.000.003",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "gss-1.0.3.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --enable-static=yes --enable-shared=yes",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                }
            ]
        }
    ],

    "curl":[
        {
            "version":"v7.053.001",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "curl-7.53.1.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --enable-static=yes --enable-shared=yes --enable-http --enable-ftp --enable-file --enable-proxy --enable-tftp --with-ssl=${VC3_ROOT_OPENSSL} --with-libssh2=${VC3_ROOT_LIBSSH2} --with-zlib=${VC3_ROOT_ZLIB}  --with-gssapi=${VC3_ROOT_GSS}/bin --with-gssapi-libs=${VC3_ROOT_GSS}/lib",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "zlib":[
                    "v1.002"
                ],
                "openssl":[
                    "v1.000.002"
                ],
                "gss":[
                    "v1.000.003"
                ],
                "libssh2":[
                    "v1.008.000"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                }
            ]
        }
    ],

    "git":[
        {
            "version":"v2.012.000",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "git-2.12.0.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --with-openssl=${VC3_ROOT_OPENSSL} --with-curl=${VC3_ROOT_CURL} --with-zlib=${VC3_ROOT_ZLIB} --with-perl=${VC3_ROOT_PERL}/bin/perl --with-python=${VC3_ROOT_PYTHON}/bin/python --without-tcltk",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "zlib":[
                    "v1.002"
                ],
                "openssl":[
                    "v1.000.002"
                ],
                "gss":[
                    "v1.000.003"
                ],
                "curl":[
                    "v7.053.001"
                ],
                "libssh2":[
                    "v1.008.000"
                ],
                "perl":[
                    "v5.024"
                ],
                "python":[
                    "v2.007"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                }
            ]
        }
    ],

    "condor":[
        {
            "version":"v8.006.000",
            "sources":[
                {
                    "type":"binary",
                    "files":[
                        "condor-8.6.0-x86_64_RedHat6-stripped.tar.gz"
                    ],
                    "prerequisites":[
                        "[ ${VC3_MACHINE_TARGET} = \"x86_64/redhat6\" ] || exit 1"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf condor-8.6.0-x86_64_RedHat6-stripped.tar.gz"
                    ]
                },
                {
                    "type":"binary",
                    "files":[
                        "condor-8.6.0-x86_64_RedHat7-stripped.tar.gz"
                    ],
                    "prerequisites":[
                        "[ ${VC3_MACHINE_TARGET} = \"x86_64/redhat7\" ] || exit 1"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf condor-8.6.0-x86_64_RedHat7-stripped.tar.gz"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PYTHONPATH",
                    "value":"lib/python"
                }
            ]
        }
    ],

    "berkeley-db":[
        {
            "version":"v6.002.023",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "db-6.2.23.tar.gz"
                    ],
                    "recipe":[
                        "cd build_unix",
                        "export CFLAGS=-fPIC",
                        "export CXXFLAGS=-fPIC",
                        "../dist/configure --prefix=${VC3_PREFIX} --enable-static --enable-shared --enable-compat185 --enable-dbm --enable-cxx",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "readline":[
        {
            "version":"v6.003",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "readline-6.3.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --enable-shared",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "glib":[
        {
            "version":"v2.018.001",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "glib-2.48.1.tar.gz"
                    ],
                    "recipe":[
                        ": system pcre is not working! using internal",
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --enable-shared --with-python=${VC3_ROOT_PYTHON}/bin/python --with-pcre=internal",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "libffi":[
                    "v3.002.001"
                ],
                "gettext":[
                    "v0.019"
                ],
                "zlib":[
                    "v1.002"
                ],
                "pcre":[
                    "v8.013"
                ],
                "python":[
                    "v2.005"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "attr":[
        {
            "version":"v2.004.047",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "attr-2.4.47.src.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --enable-static --enable-shared",
                        "make",
                        "make install install-dev install-lib",
                        "chmod -v 755 ${VC3_PREFIX}/lib/libattr.so"
                    ]
                }
            ],
            "dependencies":{
                "gettext":[
                    "v0.019"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "libffi":[
        {
            "version":"v3.002.001",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "libffi-3.2.1.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --enable-shared --enable-portable-binary",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib64:lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "pcre":[
        {
            "version":"v8.039",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "pcre-8.39.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --disable-shared --enable-unicode-properties --enable-pcre16 --enable-pcre32 ",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "fuse":[
        {
            "version":"v2.009.003",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "fuse-2.9.3.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib  --enable-lib --disable-util",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "perl":[
        {
            "version":"v5.010",
            "sources":[
                {
                    "type":"system",
                    "recipe":[
                        "perl -e 'exit($] < 5.010 || $] >= 5.011)'",
                        "perl -MConfig -e '$cmd = $Config{perlpath}; $cmd =~ s:(.*)\/bin/perl:\\1:; print \"VC3_ROOT_SYSTEM: $cmd\n\"'"
                    ]
                }
                ]
        },
        {
            "version":"v5.016",
            "sources":[
                {
                    "type":"system",
                    "recipe":[
                        "perl -e 'exit($] < 5.016 || $] >= 5.017)'",
                        "perl -MConfig -e '$cmd = $Config{perlpath}; $cmd =~ s:(.*)\/bin/perl:\\1:; print \"VC3_ROOT_SYSTEM: $cmd\n\"'"
                    ]
                }
                ]
        },
        {
            "version":"v5.024.000",
            "sources":[
                {
                    "type":"system",
                    "recipe":[
                        "perl -e 'exit($] < 5.024 || $] >= 5.025)'",
                        "perl -MConfig -e '$cmd = $Config{perlpath}; $cmd =~ s:(.*)\/bin/perl:\\1:; print \"VC3_ROOT_SYSTEM: $cmd\n\"'"
                    ]
                },
                {
                    "type":"tarball",
                    "files":[
                        "perl-5.24.0.tar.gz"
                    ],
                    "recipe":[
                        "CFLAGS='-m64 -mtune=nocona' ./Configure -Dprefix=${VC3_PREFIX} -des -A ccflags=-fPIC make",
                        "make install",
                        "mkdir -p ${VC3_PREFIX}/local_modules"
                    ]
                }
            ],
            "dependencies":{
                "perl-vc3-modules":[
                    "v0.001.000"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"PERL5LIB",
                    "value":"${VC3_MODULES_PERL}/lib/perl5",
                    "absolute":1
                },
                {
                    "name":"PERL5LIB",
                    "value":"lib/perl5/site_perl/5.24.0"
                },
                {
                    "name":"PERL_MB_OPT", 
                    "value":"--install_base ${VC3_MODULES_PERL}",
                    "clobber":1,
                    "absolute":1
                },
                {
                    "name":"PERL_MM_OPT", 
                    "value":"INSTALL_BASE=${VC3_MODULES_PERL}",
                    "clobber":1,
                    "absolute":1 
                },
                {
                    "name":"PATH",
                    "value":"${VC3_MODULES_PERL}/bin",
                    "absolute":1
                }
            ]
        }
    ],

    "perl-vc3-modules":[
        {
            "version":"v000.001.000",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "perl-vc3-modules-001.tar"
                    ],
                    "recipe":[
                        ": cpanm --force -L none --save-dists /path/ --scandeps PACKAGE", 
                        ": orepan2-indexer /path/",
                        "local_cpan=${VC3_ROOT}/${VC3_MACHINE_TARGET}/perl_local_modules/local_cpan",
                        "mkdir -p ${local_cpan}",
                        "tar -C ${local_cpan} -xf perl-vc3-modules-001.tar"
                    ]
                }
            ],
            "environment_variables":[
            {
                "name":"VC3_MODULES_PERL", 
                "value":"${VC3_ROOT}/${VC3_MACHINE_TARGET}/perl_local_modules",
                "clobber":1,
                "absolute":1
            },
            {
                "name":"VC3_MODULES_PERL_LOCAL_CPAN", 
                "value":"${VC3_MODULES_PERL}/local_cpan",
                "clobber":1,
                "absolute":1
            }
            ]
        }
    ],

    "perl-local-lib":[
        {
            "version":"v2.000019",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "local-lib-2.000019.tar.gz"
                    ],
                    "recipe":[
                        "perl Makefile.PL --bootstrap=${VC3_MODULES_PERL}",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "perl":[
                    "v5.010"
                ]
            }
        }
    ],

    "perl-cpanminus":[
        {
            "version":"v1.007",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "cpanminus-1.7.distribution"
                    ],
                    "recipe":[
                        "chmod 755 cpanminus-1.7.distribution",
                        "cp cpanminus-1.7.distribution ${VC3_MODULES_PERL}/bin/cpanm"
                    ]
                }
            ],
            "dependencies":{
                "perl-local-lib":[
                    "v2.000"
                ]
            }
        }
    ],

    "python-setuptools":[
        {
            "version":"v24.000.002",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "setuptools-24.0.2.tar.gz"
                    ],
                    "recipe":[
                        "dir=${VC3_MODULES_PYTHON}",
                        "mkdir -p $dir",
                        "python setup.py install --prefix=${VC3_MODULES_PYTHON}"
                    ]
                }
            ],
            "dependencies":{
                "python":[
                    "v2.006"
                ]
            }
        }
    ],

    "python-pip":[
        {
            "version":"v1.008.002",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "pip-8.1.2.distribution"
                    ],
                    "recipe":[
                        "python pip-8.1.2.distribution --prefix=${VC3_MODULES_PYTHON}"
                    ]
                }
            ],
            "dependencies":{
                "python":[
                    "v2.006"
                ],
                "python-setuptools":[
                    "v24.000"
                ]
            }
        }
    ],

    "python-virtualenv":[
        {
            "version":"v1.000.000",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "pip install --user virtualenv",
                        "cd ${HOME}",
                        ".local/bin/virtualenv ${VC3_MODULES_PYTHON}"
                    ]
                }
            ],
            "dependencies":{
                "python-pip":[
                    "v1.008"
                ]
            },
            "environment_variables":
            [
                {
                    "name":"PATH",
                    "value":"${HOME}/.local/bin",
                    "absolute":1
                }
            ]
        }
    ],

    "python-cryptography":[
        {
            "version":"v1.008.001",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "cryptography-1.8.1.tar.gz"
                    ],
                    "recipe":[
                        "python setup.py install --prefix=${VC3_MODULES_PYTHON}"
                    ]
                }
            ],
            "dependencies":{
                "python":[
                    "v2.006"
                ],
                "python-setuptools":[
                    "v24.000.000"
                ],
                "libffi":[
                    "v3.002.001"
                ],
                "openssl":[
                    "v1.000.000"
                ],
                "python-setuptools":[
                    "v24.000.000"
                ]
            }
        }
    ],

    "python-cherrypy":[
        {
            "version":"v3.002.002",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "cherrypy-cherrypy-3.2.2.tar.gz"
                    ],
                    "recipe":[
                        "python setup.py install --prefix=${VC3_MODULES_PYTHON}"
                    ]
                }
            ],
            "dependencies":{
                "python":[
                    "v2.006"
                ],
                "python-pyOpenSSL":[
                    "v17.000.000"
                ]
            }
        }
    ],

    "python-pyOpenSSL":[
        {
            "version":"v17.000.000",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "pyOpenSSL-17.0.0.tar.gz"
                    ],
                    "recipe":[
                        "python setup.py install --prefix=${VC3_MODULES_PYTHON}"
                    ]
                }
            ],
            "dependencies":{
                "python-cryptography":[
                    "v1.008.000"
                ]
            }
        }
    ],

    "python-requests":[
        {
            "version":"v2.007.000",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "requests-2.7.0.tar.gz"
                    ],
                    "recipe":[
                        "python setup.py install --prefix=${VC3_MODULES_PYTHON}"
                    ]
                }
            ],
            "dependencies":{
                "python":[
                    "v2.006"
                ]
            }
        }
    ],


    "python":[
        {
            "version":"v2.006",
            "sources":[
                {
                    "type":"system",
                    "recipe":[
                        "python -c 'import sys; (sys.version_info[0] == 2 and sys.version_info[1] == 6) or sys.exit(1)'",
                        "cmd=$(which python)",
                        "base=$(echo $cmd | sed -E -n -e 's:(^.*/)bin/python$:\\1:p')",
                        "[ -n \"$base\" ] || exit 1",
                        "echo \"VC3_ROOT_SYSTEM: $base\""
                    ]
                }
            ]
        },
        {
            "version":"v2.007.012",
            "sources":[
                {
                    "type":"system",
                    "recipe":[
                        "python -c 'import sys; (sys.version_info[0] == 2 and sys.version_info[1] == 7) or sys.exit(1)'",
                        "cmd=$(which python)",
                        "base=$(echo $cmd | sed -E -n -e 's:(^.*/)bin/python$:\\1:p')",
                        "[ -n \"$base\" ] || exit 1",
                        "echo \"VC3_ROOT_SYSTEM: $base\""
                    ]
                },
                {
                    "type":"tarball",
                    "files":[
                        "Python-2.7.12.tgz"
                    ],
                    "recipe":[
                        "sed -i Modules/Setup.dist -e \"217s:.*:_ssl _ssl.c -DUSE_SSL -I${VC3_ROOT_OPENSSL}/include -I${VC3_ROOT_OPENSSL}/include/openssl -L${VC3_ROOT_OPENSSL}/lib -lssl -lcrypto:\"",
                        "sed -i Modules/Setup.dist -e \"468s:.*:zlib zlibmodule.c -I${VC3_ROOT_ZLIB}/include -L${VC3_ROOT_ZLIB}/lib -lz:\"",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib",
                        "make",
                        "make install",
                        "ln -s ${VC3_PREFIX}/bin/pydoc{,2}"
                    ],
                    "dependencies":{
                        "zlib":[
                            "v1.002.008"
                        ],
                        "openssl":[
                            "v1.000"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"PYTHONPATH",
                    "value":"lib/python${VC3_VERSION_PYTHON}/site-packages"
                },
                {
                    "name":"VC3_MODULES_PYTHON",
                    "value":"${VC3_ROOT}/${VC3_MACHINE_TARGET}/python/local-modules",
                    "clobber":1,
                    "absolute":1
                },
                {
                    "name":"PATH",
                    "value":"${VC3_MODULES_PYTHON}/bin",
                    "absolute":1
                },
                {
                    "name":"PYTHONPATH",
                    "value":"${VC3_MODULES_PYTHON}/lib/python${VC3_VERSION_PYTHON}/site-packages",
                    "absolute":1
                }
            ]
        }
    ],

    "zlib": [
        {
            "version":"v1.002.008",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "zlib-1.2.8.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --static",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "gsl": [
        {
            "version":"v2.001",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "gsl-2.1.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --disable-shared",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "gettext": [
        {
            "version":"v0.019.008",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "gettext-0.19.8.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --enable-shared",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "cxx11": [
        {
            "version":"v4.009.002",
            "sources":[
                {
                    "type":"binary",
                    "files":[
                       "crossx86-x86_64-linux-musl-1.1.6.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf crossx86-x86_64-linux-musl-1.1.6.tar.gz",
                        "cd ${VC3_ROOT_CXX11}/bin; for exe in x86_64-linux-musl-*; do short=${exe#x86_64-linux-musl-}; ln -sf ${exe} ${short}; done"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "mash": [
        {
            "version":"v1.001",
            "sources":[
                {
                    "type":"binary",
                    "files":[
                       "mash-Linux64-v1.001.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf mash-Linux64-v1.001.tar.gz"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"${VC3_ROOT_MASH}",
                    "absolute":1
                }
            ]
        }
    ],


    "xrootd": [
        {
            "version":"v4.003.000",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "xrootd-4.3.0.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p build",
                        "cd build",
                        "cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} -DCMAKE_INSTALL_LIBDIR=lib ..",
                        "make",
                        "make install",
                        "find src -name '*.o' | xargs ar rcs ${VC3_PREFIX}/lib/libxrootd.a"
                    ],
                    "dependencies":{
                        "cmake":[
                            "v3.001"
                        ]
                    }
                }
            ],
            "dependencies":{
                "perl":[
                    "v5.010"
                ],
                "fuse":[
                    "v2.009"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "irods":[
        {
            "version":"v3.000",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "irods3.0.tgz"
                    ],
                    "recipe":[
                        "mv * ${VC3_PREFIX}",
                        "cd ${VC3_PREFIX}",
                        "./scripts/configure",
                        "make"
                    ],
                    "dependencies":{
                        "help2man":[
                            "v1.000.000"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"clients/icommands/bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib/core/obj"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"lib/api/include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"lib/api/include"
                }
            ]
        }
    ],

    "help2man":[
        {
            "version":"v1.043.003",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "help2man-1.43.3.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "perl-text-soundex":[
        {
            "version":"v3.000",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "Text::Soundex"
                    ]
                }
            ]
        }
    ],

    "perl-bioperl":[
        {
            "version":"v1.006",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "CJFIELDS/BioPerl-1.6.924.tar.gz"
                    ]
                }
            ],
            "dependencies":{
                "berkeley-db":[
                    "v6.000"
                ],
                "perl-DB_File":[
                    "v1.008"
                ]

            }
        }
    ],

    "perl-DB_File":[
        {
            "version":"v1.008",
            "sources":[
                {
                    "type":"tarball",
                    "files":["DB_File-1.838.tar.gz"],
                    "recipe":[
                        "sed -i -e 's%^INCLUDE.*%INCLUDE = '${VC3_ROOT_BERKELEY_DB}'/include%;s%^LIB.*%LIB = '${VC3_ROOT_BERKELEY_DB}'/lib%' config.in",
                        "perl Makefile.PL",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.007"
                ],
                "berkeley-db":[
                    "v6.000"
                ]
            }
        }
    ],

    "perl-dbi":[
        {
            "version":"v1.006",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "DBI"
                    ]
                }
            ]
        }
    ],

    "perl-file-which":[
        {
            "version":"v1.002",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "File::Which"
                    ]
                }
            ]
        }
    ],

    "perl-unsafe-signals":[
        {
            "version":"v0.003",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "Perl::Unsafe::Signals"
                    ]
                }
            ]
        }
    ],

    "perl-bit-vector":[
        {
            "version":"v7.004",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "STBEY/Bit-Vector-7.4.tar.gz"
                    ]
                }
            ]
        }
    ],

    "perl-inline":[
        {
            "version":"v0.008",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "Inline"
                    ]
                }
            ]
        }
    ],

    "perl-inline-c":[
        {
            "version":"v0.076",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "Inline::C"
                    ]
                }
            ]
        }
    ],

    "perl-forks":[
        {
            "version":"v0.036",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "forks"
                    ]
                }
            ]
        }
    ],

    "perl-io-all":[
        {
            "version":"v0.086",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "IO::All"
                    ]
                }
            ]
        }
    ],

    "perl-dbd-sqlite":[
        {
            "version":"v1.005",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "DBD::SQLite"
                    ]
                }
            ]
        }
    ],

    "perl-want":[
        {
            "version":"v0.029",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "Want"
                    ]
                }
            ]
        }
    ],

    "perl-lwp-simple":[
        {
            "version":"v6.015",
            "sources":[
                {
                    "type":"cpan",
                    "files":[
                        "LWP::Simple"
                    ]
                }
            ]
        }
    ],

    "hmmer":[
        {
            "version":"v3.001",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "hmmer-3.1b2.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix ${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-mpi",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "openmpi":[
                    "v1.010"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "openmpi":[
        {
            "version":"v1.010",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "openmpi-1.10.3.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix ${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-shared --disable-dependency-tracking --with-sge --disable-debug",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "ncbi-blast":[
        {
            "version":"v2.002.028",
            "sources":[
                {
                    "type":"binary",
                    "files":[
                        "ncbi-blast-2.2.28+-x64-linux.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf ncbi-blast-2.2.28+-x64-linux.tar.gz"
                    ]
                },
                {
                    "type":"tarball",
                    "files":[
                        "ncbi-blast-2.2.28+-src.tar.gz"
                    ],
                    "recipe":[
                        "cd c++",
                        "export CFLAGS=-fpermissive", 
                        "export CXXFLAGS=-fpermissive", 
                        ": patch ncbiconf so that blast compiles in RHEL6 with gcc4.4.7",
                        "sed -i -e '36s/^/#include <string.h>/' include/ncbiconf.h",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --with-mt --with-z=${VC3_ROOT_ZLIB} --with-pcre=${VC3_ROOT_PCRE} --with-python=${VC3_ROOT_PYTHON} --with-sqlite3=${VC3_ROOT_SQLITE3} --without-debug",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "zlib":[
                    "v1.002"
                ],
                "pcre":[
                    "v8.034"
                ],
                "python":[
                    "v2.006"
                ],
                "perl":[
                    "v5.008"
                ],
                "sqlite3":[
                    "v3.013"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "ncbi-rmblastn":[
        {
            "version":"v2.002.028",
            "sources":[
                {
                    "type":"binary",
                    "files":[
                        "ncbi-rmblastn-2.2.28-x64-linux.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf ncbi-rmblastn-2.2.28-x64-linux.tar.gz",
                        "cd ${VC3_PREFIX}/bin",
                        "for file in $VC3_ROOT_NCBI_BLAST/bin/*; do ln -s ../../${file#${VC3_ROOT}/${VC3_MACHINE_TARGET}/}; done"
                    ]
                },
                {
                    "type":"tarball",
                    "files":[
                        "rmblastn-2.2.28+-src.tar.gz"
                    ],
                    "recipe":[
                        "cd c++",
                        "export CFLAGS=-fpermissive", 
                        "export CXXFLAGS=-fpermissive", 
                        ": patch ncbiconf so that blast compiles in RHEL6 with gcc4.4.7",
                        "sed -i -e '36s/^/#include <string.h>/' include/ncbiconf.h",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --with-mt --with-z=${VC3_ROOT_ZLIB} --with-pcre=${VC3_ROOT_PCRE} --with-python=${VC3_ROOT_PYTHON} --with-sqlite3=${VC3_ROOT_SQLITE3} --without-debug",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "zlib":[
                    "v1.002"
                ],
                "pcre":[
                    "v8.034"
                ],
                "python":[
                    "v2.006"
                ],
                "perl":[
                    "v5.008"
                ],
                "ncbi-blast":[
                    "v2.002.028"
                ],
                "sqlite3":[
                    "v3.013"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "sqlite3":[
        {
            "version":"v3.013",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "sqlite-autoconf-3130000.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix ${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "exonerate":[
        {
            "version":"v2.002.000",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "exonerate-2.2.0.tar.gz"
                    ],
                    "recipe":[
                        ": exonerate does not like parallel compilation",
                        "export MAKEFLAGS=-j1",
                        ": for old glibc we need to manually link librt",
                        "export LDFLAGS=-lrt",
                        "./configure --prefix ${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-glib2 --enable-utilities",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "glib":[
                    "v2"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "snap":[
        {
            "version":"v2013.011.029",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "snap-2013-11-29.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "cp -af ${VC3_BUILD} ${VC3_PREFIX}/snap",
                        "cd ${VC3_PREFIX}/snap",
                        "sed -i -e '678s/h2->q_end/h1->q_end/;684s/h2->s_end/h1->s_end/' Zoe/zoeAlignment.c",
                        "sed -i -e 's/-Wall//;s/-Werror//' Makefile",
                        "sed -i -e 's/-Wall//;s/-Werror//' Zoe/Makefile",
                        "make"
                    ]
                }
            ],
            "dependencies":{
                "perl":[
                    "v5.008"
                ]
            },
            "environment_variables":[
                {
                    "name":"ZOE",
                    "value":"${VC3_ROOT_SNAP}/snap/Zoe",
                    "clobber":1,
                    "absolute":1
                },
                {
                    "name":"PATH",
                    "value":"${VC3_ROOT_SNAP}/snap",
                    "absolute":1
                }
            ]
        }
    ],

    "repeatmasker":[
        {
            "version":"v4.000.006",
            "sources":[
                {
                    "type":"manual-distribution",
                    "msg_manual_requirement":[
"RepeatMasker libraries have a restrictive distribution license, and have to",
"be downloaded manually. Please follow these steps:",
"    1) On http://www.girinst.org, click on 'Downloads'.",
"    2) Register for a free account.",
"    3) Download the most recent libray repeatmaskerlibraries-YEARMONTDAY.tar.gz.",
"    4) Copy the file into",
"${VC3_DISTFILES}/manual-distribution/repeatmaskerlibraries-LATEST.tar.gz.",
"    For example:",
"cp ~/Downloads/repeatmaskerlibraries-20150807.tar.gz ${VC3_DISTFILES}/manual-distribution/repeatmaskerlibraries-LATEST.tar.gz",
"    5) Try again '${VC3_COMMAND_LINE}'."],
                    "files":[
                        "repeatmaskerlibraries-LATEST.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_ROOT_REPEATMASKER_COMMON}",
                        "tar -C ${VC3_ROOT_REPEATMASKER_COMMON} -xpf repeatmaskerlibraries-LATEST.tar.gz",
                        "cd ${VC3_ROOT_REPEATMASKER_COMMON}",
                        "perl VC3_RepeatMasker-open-4-0-6.configure -re_exec_perl=${VC3_ROOT_PERL}/bin/perl -repeatmasker_dir=${VC3_ROOT_REPEATMASKER_COMMON} -trf_bin_path=${VC3_ROOT_TRF}/bin/trf -hmmer_bin_dir=${VC3_ROOT_HMMER}/bin -rmblast_bin_dir=${VC3_ROOT_NCBI_RMBLASTN}/bin -default_engine=rmblast"
                    ]
                }
            ],
            "dependencies":{
                "repeatmasker-free":[
                    "v4.000.006"
                ]
            }
        }
    ],

    "repeatmasker-free":[
        {
            "version":"v4.000.006",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "RepeatMasker-open-4-0-6.tar.gz",
                        "VC3_RepeatMasker-open-4-0-6.configure"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_ROOT_REPEATMASKER_COMMON}",
                        "tar -C ${VC3_ROOT_REPEATMASKER_COMMON} --strip-components=1 -xpf RepeatMasker-open-4-0-6.tar.gz",
                        "cp VC3_RepeatMasker-open-4-0-6.configure ${VC3_ROOT_REPEATMASKER_COMMON}/"
                    ]
                }
            ],
            "dependencies": {
                "repeatmasker-common":[
                    "v4.000.006"
                ],
                "perl":[
                    "v5.008"
                ],
                "hmmer":[
                    "v3.001"
                ],
                "ncbi-blast":[
                    "v2.002.028"
                ],
                "ncbi-rmblastn":[
                    "v2.002.028"
                ],
                "trf":[
                    "v4.000.009"
                ],
                "perl-text-soundex":[
                    "v3.000"
                ]
            }
        }
    ],

    "repeatmasker-common":[
        {
            "version":"v4.000.006",
            "sources": [
                {
                    "type":"generic",
                    "recipe":[
                        "echo setting variables..."
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"${VC3_ROOT_REPEATMASKER_COMMON}",
                    "absolute":1
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"${VC3_ROOT_REPEATMASKER_COMMON}/lib",
                    "absolute":1
                }
            ]
        }
    ],

    "augustus":[
        {
            "version":"v2.004",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "augustus.2.4.src.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf augustus.2.4.src.tar.gz",
                        "cd ${VC3_PREFIX}",
                        "make"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"AUGUSTUS_CONFIG_PATH",
                    "value":"config",
                    "clobber":1
                },
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "trf":[
        {
            "version":"v4.009",
            "sources":[
                {
                    "msg_manual_requirement":[
"Tandem Repeats Finder (trf) has a restrictive distribution license, and has to",
"be downloaded manually. Please follow these steps:",
"    1) On https://tandem.bu.edu/trf/trf.html, click on 'Download Your Own Copy of the Program'.",
"    2) Download the version appropiate for your machine.",
"      (Your machine is a ${VC3_MACHINE_OS}-${VC3_MACHINE_ARCH}, GLIBC version ${VC3_MACHINE_GLIBC_VERSION})",
"    3) Copy the file into",
"${VC3_DISTFILES}/manual-distribution/trf409",
"    For example:",
"cp ~/Downloads/trf409.legacylinux64 ${VC3_DISTFILES}/manual-distribution/trf409",
"    4) Try again '${VC3_COMMAND_LINE}'."],
                    "type":"manual-distribution",
                    "files":[
                        "trf409"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        ": -L to ensure real files are copied, and not only symlinks",
                        "cp -L trf409 ${VC3_PREFIX}/bin/trf",
                        "chmod 755 ${VC3_PREFIX}/bin/trf"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "maker":[
        {
            "version":"v2.031",
            "sources":[
                {
                    "type":"manual-distribution",
                    "msg_manual_requirement":[
"maker has a restrictive distribution license, and has to",
"be downloaded manually. Please follow these steps:",
"    1) On http://www.yandell-lab.org/software/maker.html, click on 'Registration Page'.",
"    2) Fill the form and click on 'Submit and Download MAKER.",
"    3) Download maker-2.31.8.tgz.",
"    4) Copy the file into",
"${VC3_DISTFILES}/manual-distribution/maker-2.31.8.tgz",
"    For example:",
"cp ~/Downloads/maker-2.31.8.tgz ${VC3_DISTFILES}/manual-distribution/",
"    5) Try again '${VC3_COMMAND_LINE}'."],
                    "files":[
                        "maker-2.31.8.tgz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf maker-2.31.8.tgz",
                        "cd ${VC3_PREFIX}/src",
                        ": y to activate MPI support",
                        "/bin/echo 'y' | perl Build.PL",
                        "./Build install"
                    ]
                }
            ],
            "dependencies":{
                "ncbi-blast":[
                    "v2.002.028"
                ],
                "snap":[
                    "v2013.011.029"
                ],
                "repeatmasker":[
                    "v4.000.006"
                ],
                "exonerate":[
                    "v2.002"
                ],
                "augustus":[
                    "v2.004"
                ],
                "openmpi":[
                    "v1.010"
                ],
                "perl-bioperl":[
                    "v1.006"
                ],
                "perl-dbi":[
                    "v1.006"
                ],
                "perl-dbd-sqlite":[
                    "v1.005"
                ],
                "perl-want":[
                    "v0.029"
                ],
                "perl-lwp-simple":[
                    "v6.015"
                ],
                "perl-file-which":[
                    "v1.002"
                ],
                "perl-unsafe-signals":[
                    "v0.003"
                ],
                "perl-bit-vector":[
                    "v7.004"
                ],
                "perl-inline":[
                    "v0.008"
                ],
                "perl-inline-c":[
                    "v0.076"
                ],
                "perl-forks":[
                    "v0.036"
                ],
                "perl-io-all":[
                    "v0.086"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"${VC3_ROOT_MAKER}/bin",
                    "absolute":1
                }
            ]
        }
    ],

    "findutils":[
        {
            "version":"v4.001.020",
            "sources":[
                {
                    "type":"system",
                    "recipe": [
                        "cmd=$(which find)",
                        "base=$(echo $cmd | sed -E -n -e 's:(^.*/)bin/find$:\\1:p')",
                        "[ -n \"$base\" ] || exit 1",
                        "echo \"VC3_ROOT_SYSTEM: $base\""
                    ]
                },
                {
                    "type":"tarball",
                    "files":[
                        "findutils-4.6.0.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix ${VC3_PREFIX}",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "maker-example-ecoli-01":[
        {
            "version":"v1",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "maker-example-ecoli-01.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${HOME}/maker-example-ecoli-01",
                        "tar -C ${HOME}/maker-example-ecoli-01 --strip-components=1 -xpf maker-example-ecoli-01.tar.gz"
                    ]
                }
            ],
            "dependencies":
            {
                "maker":[
                    "v2.031"
                ]
            }
        }
    ], 

    "namd":[
        {
            "version":"v2.012.000",
            "sources":[
                {
                    "type":"manual-distribution",
                    "msg_manual_requirement":[
"NAMD has a restrictive distribution license, and has to",
"be downloaded manually. Please follow these steps:",
"    1) On http://www.ks.uiuc.edu/Research, click on 'Sofware/NAMD/Download'.",
"    3) Click 'Source code' on the most recent stable release.",
"    2) Register for a free account.",
"    3) Download the most recent stable release.",
"    4) Copy the file into",
"${VC3_DISTFILES}/manual-distribution/NAMD_Source.tar.gz.",
"    For example:",
"cp ~/Downloads/NAMD_2.12_Source.tar.gz ${VC3_DISTFILES}/manual-distribution/NAMD_Source.tar.gz",
"    5) Try again '${VC3_COMMAND_LINE}'."],
                    "files":[
                        "NAMD_Source.tar.gz"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf NAMD_Source.tar.gz",
                        "cd ${VC3_PREFIX}",
                        "./config Linux-x86_64-g++ --charm-arch mpi-linux-x86_64 --charm-base ${VC3_ROOT_CHARM} --tcl-prefix ${VC3_ROOT_TCL} --fftw-prefix ${VC3_ROOT_FFTW} --python-prefix ${VC3_ROOT_PYTHON}",
                        "cd Linux-x86_64-g++",
                        "make"
                    ]
                }
            ],
            "dependencies":{
                "openmpi":[
                    "v1.010"
                ],
                "charm":[
                    "v6.007.001"
                ],
                "fftw":[
                    "v3.003.006"
                ],
                "tcl":[
                    "v8.005.009"
                ],
                "python":[
                    "v2.006.000"
                ]
            },
            "environment_variables":
            [
                {
                    "name":"PATH",
                    "value":"${VC3_ROOT_NAMD}/Linux-x86_64-g++",
                    "absolute":1
                }
            ]
        }
    ],

    "charm":[
        {
            "version":"v6.007.01",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "charm-6.7.1.tar.gz"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf charm-6.7.1.tar.gz",
                        "cd ${VC3_PREFIX}",
                        "env MPICXX=mpicxx ./build charm++ mpi-linux-x86_64 --with-production"
                    ]
                }
            ],
            "dependencies":{
                "openmpi":[
                    "v1.010"
                ]
            },
            "environment_variables":[
                {
                    "name":"CHARM_BASE",
                    "value":"$VC3_ROOT_CHARM/mpi-linux-x86_64",
                    "absolute":1,
                    "clobber":1
                },
                {
                    "name":"PATH",
                    "value":"${VC3_ROOT_CHARM}/mpi-linux-x86_64/bin",
                    "absolute":1
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"${VC3_ROOT_CHARM}/mpi-linux-x86_64/lib",
                    "absolute":1
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"${VC3_ROOT_CHARM}/mpi-linux-x86_64/include",
                    "absolute":1
                }
            ]
        }
    ],


    "tcl":[
        {
            "version":"v8.005.09",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "tcl8.5.9-src.tar.gz"
                    ],
                    "recipe":[
                        "cd unix",
                        "./configure --prefix ${VC3_PREFIX} --enable-threads --enable-64bit",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                }
            ]
        }
    ],

    "fftw":[
        {
            "version":"v3.003.006",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "fftw-3.3.6-pl2.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix ${VC3_PREFIX} --enable-openmp --enable-mpi --enable-shared --enable-float",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "openmpi":[
                            "v1.010"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                }
            ]
        }
    ],

    "octave":[
        {
            "version":"v4.002.001",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "octave-4.2.1.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix ${VC3_PREFIX} --disable-java --with-qhull-includedir=${VC3_ROOT_QHULL}/include --with-qhull-libdir=${VC3_ROOT_QHULL}/lib --with-z-includedir=${VC3_ROOT_ZLIB}/include --with-z-libdir=${VC3_ROOT_ZLIB}/lib  --with-hdf5-includedir=${VC3_ROOT_HDF5}/include --with-hdf5-libdir=${VC3_ROOT_HDF5}/lib --with-fftw3-includedir=${VC3_ROOT_FFTW}/include --with-fftw3-libdir=${VC3_ROOT_FFTW}/lib --with-fftw3f-includedir=${VC3_ROOT_FFTW}/include --with-fftw3f-libdir=${VC3_ROOT_FFTW}/lib --with-glpk-includedir=${VC3_ROOT_GLPK}/include --with-glpk-libdir=${VC3_ROOT_GLPK}/lib --with-curl-includedir=${VC3_ROOT_CURL}/include --with-curl-libdir=${VC3_ROOT_CURL}/lib --without-x --without-opengl --without-qt --without-fltk --with-blas=${VC3_ROOT_LAPACK}/lib64/libblas.so --with-lapack=${VC3_ROOT_LAPACK}/lib64/liblapack.so --with-qrupdate-includedir=${VC3_ROOT_QRUPDATE}/include --with-qrupdate-libdir=${VC3_ROOT_QRUPDATE}/lib --with-arpack-includedir=${VC3_ROOT_ARPACK}/includedir --with-arpack-libdir=${VC3_ROOT_ARPACK}/lib --with-openssl",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "qhull":[
                    "v7.002"
                ],
                "zlib":[
                    "v1.002"
                ],
                "hdf5":[
                    "v1.008"
                ],
                "fftw":[
                    "v3.003"
                ],
                "glpk":[
                    "v4.061"
                ],
                "curl":[
                    "v7.053"
                ],
                "lapack":[
                    "v3.007"
                ],
                "qrupdate":[
                    "v1.002"
                ],
                "arpack":[
                    "v3.004"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "qrupdate":[
        {
            "version":"v1.002.02",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "qrupdate-1.1.2.tar.gz"
                    ],
                    "recipe":[
                        "sed -i Makeconf -e 's:^BLAS=-lblas.*:BLAS=-L${VC3_ROOT_LAPACK}/lib -lblas:'",
                        "sed -i Makeconf -e 's:^LAPACK=-llapack.*:LAPACK=-L${VC3_ROOT_LAPACK}/lib64 -llapack:'",
                        "export CFLAGS=-fPIC",
                        "export FCFLAGS=-fPIC",
                        "make lib",
                        "make PREFIX=${VC3_PREFIX} install"
                    ]
                }
            ],
            "dependencies":{
                "lapack":[
                    "v3.007"
                ]
            },
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "hdf5":[
        {
            "version":"v1.008.018",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "hdf5-1.8.18.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "export FCFLAGS=-fPIC",
                        "mkdir -p build",
                        "cd build",
                        "cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} ..",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "openmpi":[
                            "v1.010"
                        ],
                        "cmake":[
                            "v3.000"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "qhull":[
        {
            "version":"v7.002.000",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "qhull-2015-src-7.2.0.tgz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "export FCFLAGS=-fPIC",
                        "mkdir -p build",
                        "cd build",
                        "cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} ..",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "cmake":[
                            "v3.000"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "glpk":[
        {
            "version":"v4.061.000",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "glpk-4.61.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "export FCFLAGS=-fPIC",
                        "./configure --prefix ${VC3_PREFIX} --with-pic",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "arpack":[
        {
            "version":"v3.004.000",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "arpack-ng-3.4.0.tar.gz"
                    ],
                    "recipe":[
                        "mkdir build",
                        "cd build",
                        "cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} -DMPI=ON -DBLAS_LIBRARIES=${VC3_ROOT_LAPACK} -DLAPACK_LIBRARIES=${VC3_ROOT_LAPACK} -DCMAKE_Fortran_FLAGS=-fPIC  ..",
                        "export CFLAGS=-fPIC",
                        "export FCFLAGS=-fPIC",
                        "make",
                        "mkdir -p ${VC3_PREFIX}/lib",
                        "cp *.a ${VC3_PREFIX}/lib"
                    ],
                    "dependencies":{
                        "cmake":[
                            "v3.000.000"
                        ],
                        "openmpi":[
                            "v1.010"
                        ],
                        "lapack":[
                            "v3.007.000"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "lapack":[
        {
            "version":"v3.007.000",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "lapack-3.7.0.tgz"
                    ],
                    "recipe":[
                        "mkdir build-static",
                        "cd build-static",
                        "cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} -DCMAKE_BUILD_TYPE=RELEASE ..",
                        "export FCFLAGS=-fPIC",
                        "make",
                        "make install",
                        "cd ..",
                        "mkdir build-shared",
                        "cd build-shared",
                        "cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} -DCMAKE_BUILD_TYPE=RELEASE -DBUILD_SHARED_LIBS=ON ..",
                        "export FCFLAGS=-fPIC",
                        "make",
                        "make install",
                        "mkdir -p ${VC3_PREFIX}/include",
                        "cp ../LAPACKE/include/* ${VC3_PREFIX}/include"
                    ],
                    "dependencies":{
                        "cmake":[
                            "3.000.000"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib64"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib64/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "openblas":[
        {
            "version":"v0.002.019",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "openblas-0.2.19.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "export FCFLAGS=-fPIC",
                        "make",
                        "make PREFIX=${VC3_PREFIX} install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ]
}

