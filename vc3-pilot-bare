#! /usr/bin/env perl

use v5.009;
use strict;
use warnings;

package VC3::Pilot;

use English qw/-mo_match_vars/;
use Getopt::Long qw/GetOptions/;

my $vc3_root       = $ENV{VC3_ROOT}       || "$ENV{PWD}/vc3-root";
my $vc3_distfiles  = $ENV{VC3_DISTFILES}  || "$ENV{PWD}/vc3-distfiles";
my $vc3_user_home  = $ENV{VC3_USER_HOME}  || "vc3-home";
my $vc3_repository = $ENV{VC3_REPOSITORY} || "http://download.virtualclusters.org/repository";

my %vc3_environment;

my @external_dependencies = qw/perl sh tail tar uname patch gcc g++ ld pkconfig make/;

# call main if running interactively
VC3::Pilot::main();

sub usage {
    my ($script_name) = @_;
    return <<EOF;
$script_name [options] [--database catalog] --require package [--require package]* [-- command-and-args]

    catalogs          defaults to ./vc3_catalog.json
    command-and-args  defaults to /bin/sh

    options are:
    --install <root>   Install with base <root>. 
                       Default is ${vc3_root}
    --home    <home>   Set \${HOME} to <root>/<home>.
                       Default is ${vc3_user_home}

    --distfiles  <dir> Directory to cache unbuilt packages locally.
                       Default is ${vc3_distfiles}
    --repository <url> Site to fetch packages if needed.
                       Default is ${vc3_repository}

    --make-jobs <n>    Concurrent make jobs.
                       Default is 2.
    --sh-on-error      On building error, run /bin/sh on the partially-built environment.

Examples:
    ${script_name} --require parrot 'parrot_run -p \$PARROT_HTTP_PROXY ls /cvmfs/atlas.cern.ch' 
    ${script_name} --require maker-example-ecoli-01
EOF

}

sub main {
    my $database     = 'vc3-catalog.json';
    my @requires     = ();

    my $print_help   = 0;
    my $make_jobs    = 2;
    my $sh_on_error  = 0;

    my $debug_modules_used = 0;

    # if the executable name does looks like "perl", we use $0, as it has the
    # name of the script. Otherwise, this is a static run, and we use the given
    # executable name.
    my $script_name = ${EXECUTABLE_NAME} =~ /perl/ ? $0 : ${EXECUTABLE_NAME};

    my $original_command = join(' ', $script_name, @ARGV);

    GetOptions(
        "help"        => \$print_help,

        "database=s"  => \$database,
        "require=s"   => \@requires, 

        "install=s"   => \$vc3_root, 
        "home"        => \$vc3_user_home,

        "distfiles=s"  => \$vc3_distfiles, 
        "repository=s" => \$vc3_repository, 

        "make-jobs=n" => \$make_jobs,
        "sh-on-error" => \$sh_on_error,

        # options for developing, not for runtime:
        "debug-modules-used" => \$debug_modules_used
    );

    if($print_help) {
        print usage($script_name);
        exit 0;
    }

    if($debug_modules_used) {
        print_modules_used();
        exit 0;
    }

    unless(@requires) {
        print "At least one --require option should be given.\n\n" . usage($script_name);
        exit 1;
    }

    # set defaults
    my @command_and_args = @ARGV;
    if(!@command_and_args) {
        @command_and_args = ('/bin/sh',);
    }

    # clean this!
    %ENV = ();
    $ENV{VC3_COMMAND_LINE} = File::Spec->rel2abs(join(" ", $original_command));
    $ENV{PATH}             = '/bin:/usr/bin';
    $ENV{MAKEFLAGS}        = "-j${make_jobs}";
    $ENV{TERM}             = 'linux';

    # clean this! set default path more cleanly (see also PATH above)
    # set to '2' so this paths come after the packages path (which are set to
    # 1)
    $vc3_environment{PATH}->{'/bin'}     = 2;
    $vc3_environment{PATH}->{'/usr/bin'} = 2;

    set_vc3_directories();

    # disable stdout buffering
    select(STDOUT); $OUTPUT_AUTOFLUSH = 1;

    my $bag = VC3::Bag->new($database, $sh_on_error, @requires);

    $bag->say("building phase done!");

    chdir "$vc3_root/$vc3_user_home";

    $bag->execute(@command_and_args);

    # we get here only when execute fails.
    exit -1;
}

sub set_vc3_directories {
    $vc3_root      = File::Spec->rel2abs("${vc3_root}");
    $vc3_distfiles = File::Spec->rel2abs("${vc3_distfiles}");

    my $home    = "$vc3_root/$vc3_user_home";
    my $tmp_dir = "$vc3_root/tmp";

    File::Path::make_path($vc3_root);
    File::Path::make_path($vc3_distfiles);
    File::Path::make_path("$vc3_distfiles/manual-distribution");
    File::Path::make_path($home);
    File::Path::make_path($tmp_dir);

    $ENV{VC3_ROOT}      = $vc3_root;
    $ENV{VC3_DISTFILES} = $vc3_distfiles;
    $ENV{HOME}          = $home;
    $ENV{TMP}           = $tmp_dir;
}

sub print_modules_used {
    my $file = "stub-debug-modules.txt";

    unlink "$vc3_distfiles/$file";

    File::Path::make_path($vc3_distfiles);

    my $ff       = HTTP::Tiny->new();
    my $url      = $vc3_repository . '/' . $file;
    my $output   = $vc3_distfiles  . '/' . $file;

    my $response_a = $ff->mirror($url, $output);
    my $response_b = $ff->mirror($url, $output);


    my @modules = grep { /\.pm$/ } keys %INC;

    # add modules that %INC sometimes does not find:
    @modules = (@modules, qw/strict PerlIO encoding/);

    # turn :: into /
    map { s^/^::^g }   @modules;

    # remove .pm extension
    map { s^\.pm$^^g } @modules;

    # remove duplicates
    @modules = uniq_words(@modules);

    @modules = sort { uc($a) cmp uc($b) } @modules;

    print join("\n", @modules), "\n";
}

sub uniq_words {
    my %words;
    for my $word (@_) {
        $words{$word} = 1;
    }

    return keys %words;
}

package VC3::Bag; 

use Carp qw/carp croak/;
use English qw/-mo_match_vars/;
use File::Spec ();
use version ();
use POSIX ();

use JSON::Tiny;

sub new {
    my ($class, $catalog, $sh_on_error, @requires) = @_;

    my $self = bless {}, $class;
    $self->set_machine_vars();

    $self->{sources} = $self->decode_bag($catalog);
    $self->{indent_level} = 0;

    $self->{order}    = {};
    $self->{wrapper}  = {};
    $self->{prologue} = {};

    for my $req (@requires) {
        my $widget = $self->select_version($req);
        $widget->runtime_dependencies($self->{order});
    }

    # list of all packages needed, from inner to outter.
    my @ordered_names = sort { $self->{order}{$b} <=> $self->{order}{$a} || $a cmp $b } keys %{$self->{order}};

    my $restricted_unmet = 0;
    for my $name (@ordered_names) {
        my $widget = $self->select_version($name);

        if($widget->check_manual_requirements()) {
            $restricted_unmet++;
        }
    }

    exit 1 if $restricted_unmet > 0;

    # do the actual bulding
    for my $req (@requires) {
        $self->set_environment($req, $sh_on_error);
    }

    return $self;
}

sub set_machine_vars {
    my ($self) = @_;

    ($self->{osname}, undef, undef, undef, $self->{architecture}) = POSIX::uname();

    $self->{target} = $self->architecture . '/' . $self->distribution;

    my $ldd_version_raw = qx(ldd --version);
    $ldd_version_raw =~ /
    # we are looking for a line starting with 'ldd'
    ^ldd
    # followed by anything
    .*
    # followed by at least one space
    \s+
    # followed by the version number (that we capture)
    ([0-9.]+)
    # followed by any number of spaces at the end of the line
    \s*$
    # options: x allows regexp comments. m treats each line indepedently
    /xm ;

    $self->{glibc_version} = $1
    || 'unknown';

    $ENV{VC3_MACHINE_OS}   = $self->osname;
    $ENV{VC3_MACHINE_ARCH} = $self->architecture;
    $ENV{VC3_MACHINE_GLIBC_VERSION} = $self->glibc_version;
}

sub target {
    my ($self) = @_;
    return $self->{target};
}

sub osname {
    my ($self) = @_;
    return $self->{osname};
}

sub architecture {
    my ($self) = @_;
    return $self->{architecture};
}

sub glibc_version {
    my ($self) = @_;
    return $self->{glibc_version};
}

# reads /etc/readhat-release and transforms something like:
# 'Red Hat Enterprise Linux Server release 6.5 (Santiago)'
# into 'redhat6'.
sub distribution {
    my ($self) = @_;

    my $distribution='generic';
    
    if (-f '/etc/redhat-release') {
        open (my $file_fh, '<', '/etc/redhat-release');
        my $redhat_version_line = <$file_fh>;

        $redhat_version_line =~ /\brelease\b\s+([0-9]+)\b/;
        my $redhat_version = $1;

        die 'Could not find redhat version!' unless $redhat_version;

        $distribution="redhat${redhat_version}"
    }
    
    return $distribution;
}

sub widget {
    my ($self, $widget_name) = @_;

    my $widget = $self->{sources}{$widget_name}
    || die "I do not know anything about '$widget_name' . \n";

    return $widget;
}

sub decode_bag {
    my ($self, $filename) = @_;
    open( my $catbag_f, '<:encoding(UTF-8)', $filename) ||
    die "Could not open '$filename': $!";

    my $contents = do { local($/); <$catbag_f> };
    close($catbag_f);

    my $bag_raw = JSON::Tiny::decode_json($contents);

    my $sources = {};
    
    for my $widget_name (keys %{$bag_raw}) {
        my @versions = map { VC3::Widget->new($self, $widget_name, $_) } @{$bag_raw->{$widget_name}};
        $sources->{$widget_name} = \@versions;
    }

    return $sources;
}

sub set_environment {
    my ($self, $widget_name, $sh_on_error, $min_version, $max_version) = @_;

    my $widget = $self->select_version($widget_name, $min_version, $max_version);

    $self->say("processing for $widget_name-" . $widget->version);

    # set root of this widget, in case dependencies need to refer to its parent.
    $ENV{$widget->var_root_name} = $widget->destination_dir;
    
    $self->set_dependencies($widget, $sh_on_error, $widget->dependencies);
    $widget->set_environment_variables();

    # check here missing, we are not checking anything here, only below at
    # sources!
    $self->say("checking for $widget_name-" . $widget->version);

    my $exit_status = 0;
    if($widget->sources) { 
        for my $source (@{$widget->sources}) {
            # save current environment so that we can rollback in case of error.
            my %old_ENV = %ENV;
            my %old_vc3_environment = %vc3_environment;


            # set dependencies particular to this source
            $self->set_dependencies($widget, $sh_on_error, $source->dependencies);
            eval {$exit_status = -1; $exit_status = $widget->execute_recipe($source);};

            if($exit_status) {
                # on error, reestablish old environment, and show last lines of log
                # file.
                
                $widget->process_error($sh_on_error, $EVAL_ERROR, $exit_status);

                %ENV = %old_ENV;
                my %vc3_environment = %old_vc3_environment;
            } else {
                # on success, we keep break out and do no try more recipes.
                last;
            }
        }
    }

    # last of the tries also failed, so we report failure for this widget.
    if($exit_status) {
        die "Could not set environment for '" . $widget->name . "' succesfully' . \n";
    }
    
    $self->add_to_prologue($widget);
    $self->add_to_wrapper($widget);
}

sub set_dependencies {
    my ($self, $widget, $sh_on_error, $dependencies) = @_;

    my $namev = $widget->name . '-' . $widget->version; 

    $self->{indent_level}++;

    if($dependencies) {
        for my $dependency (keys %{$dependencies}) {
            my ($min_dep_ver, $max_dep_ver) = @{$dependencies->{$dependency}};

            $self->say("$namev needs $dependency");
            $self->set_environment($dependency, $sh_on_error, $min_dep_ver, $max_dep_ver);
        }
    }

    $self->{indent_level}--;
}

# versions available, min desired version, max desired version
sub select_version {
    my ($self, $widget_name, $min_version, $max_version) = @_;

    if($min_version) {
        $min_version = version->parse($min_version);
    }

    if($max_version) {
        $max_version = version->parse($max_version);
    }

    my $min_found;
    my $max_found;

    my $versions = $self->widget($widget_name);

    for my $widget (@{$versions}) {
        if(!$min_version) {
            return $widget;
        }

        my $version = version->parse($widget->{version});

        $min_found = $version unless $min_found;
        $max_found = $version unless $max_found;

        $min_found = $min_found lt $version ? $version : $min_found;
        $max_found = $max_found gt $version ? $version : $max_found;

        next if $min_version gt $version;

        if(!$max_version) {
            return $widget;
        }

        next if $max_version lt $version;
        return $widget;
    }

    $max_version = $min_version unless $max_version;
    die "I did not find a suitable version for '$widget_name'.\n Found: ["
    . version::normal($min_found)
    . ',' . version::normal($max_found)
    . ']. Wanted ['
    . $min_version->normal
    . ',' . $max_version->normal
    . "]\n";
}

sub add_to_prologue {
    my ($self, $widget) = @_;

    if($widget->prologue) {
        $self->{prologue}{$widget->prologue} = $self->{order};
    }
}

sub add_to_wrapper {
    my ($self, $widget) = @_;

    if($widget->wrapper) {
        $self->{wrapper}{$widget->wrapper} = $self->{order};
    }
}

sub consolidate_prologue {
    my ($self) = @_;

    my @progs = keys %{$self->{prologue}};
    @progs = sort { $self->{prologue}{$b} <=> $self->{prologue}{$a} } @progs;
    @progs = ("cd $vc3_root/$vc3_user_home", @progs);

    return \@progs;
}

sub consolidate_wrapper {
    my ($self, @command_and_args) = @_;

    my $prologue = $self->consolidate_prologue();
    open(my $profile_f, '>', "$ENV{'HOME'}/.profile");

    print { $profile_f } "#!/bin/sh\n\n";

    for my $line (@{$prologue}) {
        print { $profile_f } "$line\n";
    }

    print { $profile_f } "\n\n";

    close $profile_f;

    my $payload = "/bin/sh -c '" . join(' ', ('. ~/.profile;', 'exec', @command_and_args)) . "'";

    my @wraps = keys %{$self->{wrapper}};
    @wraps = sort { $self->{wrapper}{$b} <=> $self->{wrapper}{$a} } @wraps;

    for my $wrap (@wraps) {
        if( $wrap =~ /\{\}/ ) {
            $wrap =~ s/\{\}/$payload/;
            $payload = $wrap;
        } else {
            $payload = $wrap . ' ' . $payload;
        }
    }

    return $payload;
}

sub execute  {
    my ($self, @command_and_args) = @_;

    my $command = $self->consolidate_wrapper(@command_and_args);

    exec $command;
}

sub shell {
    my ($self, $payload) = @_;

    $payload |= '/bin/sh';

    my $prologue = $self->consolidate_prologue();
    my $wrapper  = $self->consolidate_wrapper($payload);

    my $pid = open(my $input, '|-', $wrapper);

    for my $line (@{$prologue}) {
        print { $input } "$line\n";
    }

    return ($pid, $input);
}

sub expand_env_variable {
    my ($varvalue) = @_;

    $varvalue =~ s/\$\{(\w+)\}/env_variable_value($1)/eg;

    return $varvalue;
}

sub env_variable_value {
    my ($varname) = @_;

    my $value = $ENV{$varname}
    || die "Variable '$varname' has not been defined.";
}

sub say {
    my ($self, @rest) = @_;
    print(('.' x $self->{indent_level}), @rest, "\n");
}


package VC3::Widget;
use Carp;
use POSIX ":sys_wait_h";

# Attributes:
# name, version, sources, dependencies, environment_variables
sub new {
    my ($class, $bag, $name, $json_description) = @_;

    my $self = bless {}, $class;

    $self->bag($bag);
    $self->name($name);
    $self->version($json_description->{version});
    $self->sources($json_description->{sources});
    $self->dependencies($json_description->{dependencies});
    $self->wrapper($json_description->{wrapper});
    $self->prologue($json_description->{prologue});
    $self->environment_variables($json_description->{environment_variables});
    $self->phony($json_description->{phony});

    add_root_variable($self);

    return $self;
}

sub add_root_variable {
    my ($self) = @_;

    my $vars      = $self->environment_variables || [];

    my $root_name = 'VC3_' . uc($self->name) . '_ROOT';

    # replace - with _, as env vars cannot have - in their names.
    $root_name =~ s/-/_/g;

    my $root_var = {
        name     => $root_name,
        value    => $self->destination_dir,
        clobber  => 1,
        absolute => 1
    };

    unshift @{$vars}, $root_var;

    $self->var_root_name($root_name);
    $self->environment_variables($vars);
}

sub var_root_name {
    my ($self, $new_var_root_name) = @_;

    $self->{var_root_name} = $new_var_root_name if($new_var_root_name);

    return $self->{var_root_name};
}

sub bag {
    my ($self, $new_bag) = @_;

    $self->{bag} = $new_bag if($new_bag);

    croak 'No bag given'
    unless($self->{bag}); 

    return $self->{bag};
}

sub name {
    my ($self, $new_name) = @_;

    if($new_name) {
        # names can only contain letters, numbers, - and _.
        my @badchars = ($new_name =~ /([^A-Za-z0-9-_])/g);
        if(@badchars) {
            die "The name '$new_name' containes the following disallowed charactares: " 
            . join ', ', map { "'$_'" } @badchars;
        } else {
            $self->{name} = $new_name if($new_name);
        }
    }

    die 'No name given'
    unless($self->{name}); 

    return $self->{name};
}

sub version {
    my ($self, $new_version) = @_;

    $self->{version} = $new_version if($new_version);

    croak 'No version given'
    unless($self->{version}); 

    return $self->{version};
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    $self->{dependencies} = $new_dependencies if($new_dependencies);

    return $self->{dependencies};
}

sub sources {
    my ($self, $new_sources) = @_;

    if($new_sources) {
        my @sources = map { VC3::Source->new($self, $_) } @{$new_sources};
        $self->{sources} = \@sources;
    }

    return $self->{sources};
}

sub prologue {
    my ($self, $new_prologue) = @_;

    $self->{prologue} = $new_prologue if($new_prologue);

    return $self->{prologue};
}

sub wrapper {
    my ($self, $new_wrapper) = @_;

    $self->{wrapper} = $new_wrapper if($new_wrapper);

    return $self->{wrapper};
}


sub environment_variables {
    my ($self, $new_vars) = @_;

    $self->{environment_variables} = $new_vars if($new_vars);

    return $self->{environment_variables};
}

sub phony {
    my ($self, $new_phony) = @_;

    $self->{phony} = $new_phony if($new_phony);

    return $self->{phony};
}

sub destination_dir {
    my ($self) = @_;
    return File::Spec->rel2abs($vc3_root) . '/' . $self->bag->target . '/' . $self->name . '-' . $self->version;
}

sub build_dir {
    my ($self) = @_;
    return File::Spec->rel2abs($vc3_root) . '/builds/' . $self->name;
}

sub build_log {
    my ($self) = @_;
    my $log_name = $self->destination_dir . '/' . $self->name . '-build-log';

    return $log_name;
}

sub completion_ribbon {
    my ($self) = @_;
    my $ribbon = $self->destination_dir . '/.VC3_DEPENDENCY_BUILD_COMPLETE';

    return $ribbon;
}

sub set_environment_variables {
    my ($self) = @_; 

    my $vars = $self->environment_variables
    || return;

    for my $var (@{$vars}) {

        my $name = $var->{name}
        || carp "Environment variable does not have a name.";

        my $value = $var->{value}
        || carp "Environment variable '$name' did not define a value.";

        my $clobber  = $var->{clobber};
        my $absolute = $var->{absolute};

        # split paths on : if necessary
        my @paths;
        if($clobber) {
            $vc3_environment{$name} = {};
            @paths = ($value);
        } else {
            @paths = split /:/, $value;
        }

        for my $path (@paths) {
            if(!$absolute) {
                $path = $self->destination_dir . '/' . $path;
            }
            $path = VC3::Bag::expand_env_variable($path);
            $vc3_environment{$name}->{$path} = 1;
        }

        my $dirs = $vc3_environment{$name};

        my $dotted = join(':', sort { $dirs->{$a} <=> $dirs->{$b} || $a cmp $b } keys %{$dirs});
        $ENV{$name} = $dotted;
    }
}

# range is: [min_version, max_version];
# max_version is the prefered version. 
# [version] is considered as [min_version]
# sub check_version {
#     my ($self, @range) = @_;
# 
#     return 1 unless $self->versioncmd;
#     return 1 unless $self->version || @range > 0;
# 
#     if(@range == 0) {
#         @range = (version->parse($self->{version}));
#     }
# 
#     my $reg = $self->{versionreg} ? $self->{versionreg} : qr/(.*)/;
# 
#     my $version_output = qx/$self->{versioncmd}/;
# 
#     return 0 unless $version_output =~ $reg;
# 
#     my ($observed_version) = version->parse("$1");
# 
#     print $observed_version . "\n";
# 
#     return 0 if $observed_version < $range[0];
#     return 0 if $observed_version > $range[$#range];
# 
#     return $observed_version;
# }

sub error_debug_info {
    my ($self, $eval_error) = @_;

    print "'", $self->name, "' failed to build for ", $self->bag->target, "\n";

    if($eval_error) {
        print $eval_error, "\n";
    }

    print "Last lines of log file:\n";
    system('tail', $self->build_log);
}


sub process_error {
    my ($self, $sh_on_error, $eval_error, $status) = @_;

    if($eval_error || $status) {
        $self->error_debug_info($eval_error);

        if($sh_on_error) {
            warn $@ if $@;
            my $pid = fork();
            if($pid == 0) {
                my ($pid, $stdin) = $self->bag->shell();
                print { $stdin } 'cd ' . $self->build_dir . "\n";

                waitpid $pid, 0;

                exit -1;

            } elsif($pid > 0) {
                waitpid $pid, 0;
            } else {
                croak 'Could not fork for debugging shell.';
            }
        }
    }
}

sub create_ribbon {
    my ($self) = @_;

    open (my $ribbon_fh, '>', $self->completion_ribbon);
    close $ribbon_fh;
}

sub prepare_recipe_sandbox {
    my ($self, $source) = @_;

    # clear build directory, to avoid bugs from uncleaned sources.
    my $build = $self->build_dir;
    if( -d $build ) {
        File::Path::rmtree($build);
    }

    # clear destination directory, to make sure we are running what we believe
    # we are running.
    my $destination = $self->destination_dir;
    if( -d $destination ) {
        File::Path::rmtree($destination);
    }

    # create the dirs we cleared above.
    File::Path::make_path($self->build_dir);
    File::Path::make_path($self->destination_dir);

    # make sure tmp dir exists
    File::Path::make_path($ENV{'TMPDIR'});

    # download to $vc3_distfiles the ingredient (i.e., input files) if missing.
    $source->get_files();

    # if generic, copy all files to build directory.
    # if tarball, expand first file to build directory, and copy the rest of
    # the files to build directory.
    $source->prepare_files($build);
}

sub execute_recipe {
    my ($self, $source) = @_;

    # if nothing to do, we return no error:
    if(!$self->phony && -f $self->completion_ribbon()) {
        return 0;
    }

    $self->bag->say("preparing '" . $self->name . "' for ", $self->bag->target);

    $self->prepare_recipe_sandbox($source);

    # set the destination directory as an environment variable before
    # setting up the shell, so that the child created inherets it.
    $ENV{'VC3_PREFIX'} = $self->destination_dir;
    $ENV{'VC3_BUILD'}  = $self->build_dir;

    my ($pid, $build_in) = $self->setup_build_shell($source);

    my @steps = @{$source->recipe};

    # add shifting to build directory as the first step.
    unshift @steps, 'cd ' . $self->build_dir;

    # add exiting cleanly from shell as a last step.
    push @steps, 'exit 0';

    $self->bag->say("building '" . $self->name . "' for ", $self->bag->target);
    $self->bag->say("details: " . $self->build_log);

    for my $step (@steps) {
        my $date = gmtime();
        print { $build_in } ": $date\n";
        print { $build_in } "$step\n";
    }

    my $status = -1;
    eval { close $build_in; $status = $? };

    delete $ENV{VC3_PREFIX}; 
    delete $ENV{VC3_BUILD}; 

    if(!$@ && WIFEXITED($status) && (WEXITSTATUS($status) == 0)) {
        $self->create_ribbon();
        File::Path::rmtree($self->build_dir);
        return 0;
    } else {
        return -1;
    }
}

sub setup_build_shell {
    my ($self, $source) = @_;

    # log the recipe used. Since we are opening sh with -e, the recipe executes
    # as if all steps were &&-ed together.
    open(my $build_log, '>', $self->build_log);
    print { $build_log } join("\n && ", @{$source->recipe}) . "\n";
    close $build_log;

    # open sh with -e. This terminates the shell at the first step that returns
    # a non-zero status.
    my ($pid, $build_in) = $self->bag->shell();

    croak 'Could not open /bin/sh for building.'
    unless $build_in;

    # redirect all output to our log file.
    print { $build_in } 'exec 1>> ' . $self->build_log . "\n";
    print { $build_in } "exec 2>&1\n";
    print { $build_in } "set -ex\n";

    # return the stdin of the shell, and the pid so we can wait for it.
    return ($pid, $build_in);
}

sub check_manual_requirements {
    my ($self) = @_;

    my $sources = $self->sources;

    my $restricted_unmet = 0;
    for my $source (@{$sources}) {
        unless($source->check_manual_requirements()) {
            $restricted_unmet++;
            print "\n", $source->msg_manual_requirement(), "\n\n";
        }
    }

    return $restricted_unmet;
}


sub runtime_dependencies {
    my ($self, $order) = @_;

    # if no parents, then give level one, a root package
    # larger level means more inner 
    $order->{$self->name} |= 1;

    my $level = $order->{$self->name};

    my $dependencies = $self->dependencies;

    if($dependencies) {
        for my $dependency (keys %{$dependencies}) {
            my ($min_ver, $max_ver) = @{$dependencies->{$dependency}};
            my $next = $self->bag->select_version($dependency, $min_ver, $max_ver);

            my $next_level = $order->{$next->name} || 0;

            if($next_level < $level + 1) {
                $order->{$next->name} = $level + 1;
                $next->runtime_dependencies($order);
            }
        }
    }

    return $level;
}

package VC3::Source;
use Carp;

sub new {
    my ($class, $widget, $source_raw) = @_;

    my $source;

    if($source_raw->{type} eq 'generic') {
        $source = VC3::Source::Generic->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'tarball') {
        $source = VC3::Source::Tarball->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'manual-distribution') {
        $source = VC3::Source::ManualDist->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'service') {
        croak "Not implemented";
    }
    else {
        croak "Do not know about source type '" . $source_raw->{type} . "' for '" . $widget->name . "'";
    }

    return $source;
}

package VC3::Source::Generic;
use Carp;
use File::Copy;
use File::Path;
use File::Spec;
use HTTP::Tiny;
use parent;

sub new {
    my ($class, $widget, $json_description) = @_;

    my $self = bless {}, $class;

    $self->widget($widget);
    $self->recipe($json_description->{recipe});
    $self->files($json_description->{files});
    $self->msg_manual_requirement($json_description->{msg_manual_requirement});
    $self->dependencies($json_description->{dependencies});

    return $self;
}

sub widget {
    my ($self, $new_widget) = @_;

    $self->{widget} = $new_widget if($new_widget);

    croak 'No environment argument given'
    unless($self->{widget}); 

    return $self->{widget};
}

sub recipe {
    my ($self, $new_recipe) = @_;

    $self->{recipe} = $new_recipe if($new_recipe);

    croak 'No recipe given'
    unless($self->{recipe}); 

    return $self->{recipe};
}

sub files {
    my ($self, $new_files) = @_;

    $self->{files} = $new_files if($new_files);

    if($self->{files}) {
        return $self->{files};
    } else {
        return [];
    }
}

sub msg_manual_requirement {
    my ($self, $new_message) = @_;

    if($new_message) {
        my @expansions = map { VC3::Bag::expand_env_variable($_) } @{$new_message};
        $self->{msg_manual_requirement} = join("\n", @expansions);
        $self->{msg_manual_requirement} = "\n" . ${self}->{msg_manual_requirement};
    }

    return $self->{msg_manual_requirement};
}

sub check_manual_requirements {
    my ($self, $new_message) = @_;

    # by default return true. Usually packages do not have manual requirements.
    return 1;
}

sub file_absolute {
    my ($self, $file) = @_;
    return File::Spec->rel2abs($vc3_distfiles . '/' . $file);
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    $self->{dependencies} = $new_dependencies if($new_dependencies);

    return $self->{dependencies};
}

sub get_file {
    my ($self, $file) = @_;

    unless(-f $self->file_absolute($file)) {
        $self->widget->bag->say("Downloading '" . $file . "' from $vc3_repository");

        #if make sure the destination directory exists
        File::Path::make_path($vc3_distfiles);

        my $ff = HTTP::Tiny->new();

        my $url    = $vc3_repository . '/' . $file;
        my $output = $vc3_distfiles  . '/' . $file;

        my $retries = 5;
        my $sleep_before_retry = 5; # seconds
        my $response;

        for my $i (1..$retries) {
            $response = $ff->mirror($url, $output);

            return if $response->{success};

            # 304 means file did not change from the last time we downloaded it
            return if $response->{status} == 304;

            # retries:
            # 408 is request timeout
            # 503 is service unavailable
            # 504 is a gatewat timeout
            # 524 is a cloudflare timeout
            # 599 is an internal exception of HTTP::Tiny, which may be a timeout too.

            if( grep { $response->{status} == $_ } (408,503,504,524,599) ) {
                print "Could not download '" . $file . "':\n" . "$response->{status}: $response->{reason}\n";
                print "$response->{content}\n" if $response->{content};
                print "Retrying @{[$retries - $i]} more time(s)\n"; 

                sleep $sleep_before_retry;

                next;
            }

            die "Could not download '" . $file . "':\n" . "$response->{status} $response->{reason}";
        }
    }
}

sub get_files {
    my ($self) = @_;

    my $files = $self->files;

    for my $file (@{$files}) {
        $self->get_file($file);
    }
}

sub prepare_files {
    my ($self, $build_dir) = @_;

    for my $file (@{$self->files}) {
        symlink($self->file_absolute($file), $build_dir . '/' . $file)
        || die "Could not link '" . $file . "' to build directory.\n";
    }
}

package VC3::Source::Tarball;
use base 'VC3::Source::Generic';
use Carp;

sub new {
    my ($class, $widget, $json_description) = @_;

    my $self = VC3::Source::Generic->new($widget, $json_description);

    unless($self->files) {
        croak "For type 'tarball', at least one file should be defined in the files list, and the first file in the list should be a tarball.";
    }

    $self = bless $self, $class;

    return $self;
}

sub prepare_files  {
    my ($self, $build_dir) = @_;

    # first file in $self->files is the tarball, by convention.
    my $tarball = @{$self->files}[0];
    $tarball = $self->file_absolute($tarball);

    system(qq/tar -C ${build_dir} --strip-components=1 -xpf ${tarball}/);
    die "Could not expand tarball $tarball.\n" if $?;

    # link in the rest of the input files.
    $self->SUPER::prepare_files($build_dir);
}

package VC3::Source::ManualDist;
use base 'VC3::Source::Generic';
use Carp;

sub get_file {
    my ($self, $file) = @_;

    unless(-f $self->file_absolute($file)) {
        print $self->msg_manual_requirement . "\n";
        die "Missing manual or restricted distribution file.\n";
    }
}

sub file_absolute {
    my ($self, $file) = @_;
    return File::Spec->rel2abs($vc3_distfiles . '/manual-distribution/'  . $file);
}

sub check_manual_requirements {
    my ($self) = @_;

    for my $file (@{$self->files}) {
        unless(-f $self->file_absolute($file)) {
            # check failed, return false
            return 0;
        }
    }

    return 1;
}

